// Code generated from ../antlr/SolidityParser.g4 by ANTLR 4.13.0. DO NOT EDIT.

package parser // SolidityParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SolidityParser struct {
	*antlr.BaseParser
}

var SolidityParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func solidityparserParserInit() {
	staticData := &SolidityParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "'abstract'", "'address'", "'anonymous'", "'as'", "'assembly'",
		"'bool'", "", "'bytes'", "'calldata'", "'catch'", "'constant'", "'constructor'",
		"", "'contract'", "'delete'", "'do'", "'else'", "'emit'", "'enum'",
		"'error'", "'event'", "'external'", "'fallback'", "", "", "", "", "'from'",
		"", "'global'", "", "", "'immutable'", "'import'", "'indexed'", "'interface'",
		"'internal'", "'is'", "'library'", "'mapping'", "'memory'", "'modifier'",
		"'new'", "", "'override'", "'payable'", "'pragma'", "'private'", "'public'",
		"'pure'", "'receive'", "'return'", "'returns'", "'revert'", "", "'storage'",
		"'string'", "'struct'", "", "'try'", "'type'", "", "'unchecked'", "'unicode'",
		"", "'using'", "'view'", "'virtual'", "'while'", "", "", "'['", "']'",
		"", "", "':'", "", "", "'?'", "'=>'", "", "'='", "'|='", "'^='", "'&='",
		"'<<='", "'>>='", "'>>>='", "'+='", "'-='", "'*='", "'/='", "'%='",
		"", "'||'", "'&&'", "'|'", "'^'", "'&'", "'<<'", "'>>'", "'>>>'", "'+'",
		"'-'", "'*'", "'/'", "'%'", "'**'", "'=='", "'!='", "'<'", "'>'", "'<='",
		"'>='", "'!'", "'~'", "'++'", "'--'", "'\"'", "'''", "", "", "", "",
		"", "", "", "", "", "", "", "", "'\"evmasm\"'", "", "", "", "", "",
		"", "", "", "", "'case'", "", "'default'", "", "", "", "", "'leave'",
		"'let'", "'switch'", "", "", "", "", "", "", "", "':='",
	}
	staticData.SymbolicNames = []string{
		"", "ReservedKeywords", "Abstract", "Address", "Anonymous", "As", "Assembly",
		"Bool", "Break", "Bytes", "Calldata", "Catch", "Constant", "Constructor",
		"Continue", "Contract", "Delete", "Do", "Else", "Emit", "Enum", "Error",
		"Event", "External", "Fallback", "False", "Fixed", "FixedBytes", "For",
		"From", "Function", "Global", "Hex", "If", "Immutable", "Import", "Indexed",
		"Interface", "Internal", "Is", "Library", "Mapping", "Memory", "Modifier",
		"New", "SubDenomination", "Override", "Payable", "Pragma", "Private",
		"Public", "Pure", "Receive", "Return", "Returns", "Revert", "SignedIntegerType",
		"Storage", "String", "Struct", "True", "Try", "Type", "Ufixed", "Unchecked",
		"Unicode", "UnsignedIntegerType", "Using", "View", "Virtual", "While",
		"LParen", "RParen", "LBrack", "RBrack", "LBrace", "RBrace", "Colon",
		"Semicolon", "Period", "Conditional", "DoubleArrow", "RightArrow", "Assign",
		"AssignBitOr", "AssignBitXor", "AssignBitAnd", "AssignShl", "AssignSar",
		"AssignShr", "AssignAdd", "AssignSub", "AssignMul", "AssignDiv", "AssignMod",
		"Comma", "Or", "And", "BitOr", "BitXor", "BitAnd", "Shl", "Sar", "Shr",
		"Add", "Sub", "Mul", "Div", "Mod", "Exp", "Equal", "NotEqual", "LessThan",
		"GreaterThan", "LessThanOrEqual", "GreaterThanOrEqual", "Not", "BitNot",
		"Inc", "Dec", "DoubleQuote", "SingleQuote", "NonEmptyStringLiteral",
		"EmptyStringLiteral", "UnicodeStringLiteral", "HexString", "HexNumber",
		"OctalNumber", "DecimalNumber", "DecimalNumberFollowedByIdentifier",
		"Identifier", "WS", "COMMENT", "LINE_COMMENT", "AssemblyDialect", "AssemblyLBrace",
		"AssemblyFlagString", "AssemblyBlockLParen", "AssemblyBlockRParen",
		"AssemblyBlockComma", "AssemblyBlockWS", "AssemblyBlockCOMMENT", "AssemblyBlockLINE_COMMENT",
		"YulBreak", "YulCase", "YulContinue", "YulDefault", "YulFalse", "YulFor",
		"YulFunction", "YulIf", "YulLeave", "YulLet", "YulSwitch", "YulTrue",
		"YulHex", "YulEVMBuiltin", "YulLBrace", "YulRBrace", "YulLParen", "YulRParen",
		"YulAssign", "YulPeriod", "YulComma", "YulArrow", "YulIdentifier", "YulHexNumber",
		"YulDecimalNumber", "YulStringLiteral", "YulHexStringLiteral", "YulWS",
		"YulCOMMENT", "YulLINE_COMMENT", "PragmaToken", "PragmaSemicolon", "PragmaWS",
		"PragmaCOMMENT", "PragmaLINE_COMMENT",
	}
	staticData.RuleNames = []string{
		"sourceUnit", "pragmaDirective", "importDirective", "importAliases",
		"path", "symbolAliases", "contractDefinition", "interfaceDefinition",
		"libraryDefinition", "inheritanceSpecifierList", "inheritanceSpecifier",
		"contractBodyElement", "namedArgument", "callArgumentList", "identifierPath",
		"modifierInvocation", "visibility", "parameterList", "parameterDeclaration",
		"constructorDefinition", "stateMutability", "overrideSpecifier", "functionDefinition",
		"modifierDefinition", "fallbackFunctionDefinition", "receiveFunctionDefinition",
		"structDefinition", "structMember", "enumDefinition", "userDefinedValueTypeDefinition",
		"stateVariableDeclaration", "constantVariableDeclaration", "eventParameter",
		"eventDefinition", "errorParameter", "errorDefinition", "userDefinableOperator",
		"usingDirective", "typeName", "elementaryTypeName", "functionTypeName",
		"variableDeclaration", "dataLocation", "expression", "assignOp", "tupleExpression",
		"inlineArrayExpression", "identifier", "literal", "literalWithSubDenomination",
		"booleanLiteral", "stringLiteral", "hexStringLiteral", "unicodeStringLiteral",
		"numberLiteral", "block", "uncheckedBlock", "statement", "simpleStatement",
		"ifStatement", "forStatement", "whileStatement", "doWhileStatement",
		"continueStatement", "breakStatement", "tryStatement", "catchClause",
		"returnStatement", "emitStatement", "revertStatement", "assemblyStatement",
		"assemblyFlags", "variableDeclarationList", "variableDeclarationTuple",
		"variableDeclarationStatement", "expressionStatement", "mappingType",
		"mappingKeyType", "yulStatement", "yulBlock", "yulVariableDeclaration",
		"yulAssignment", "yulIfStatement", "yulForStatement", "yulSwitchCase",
		"yulSwitchStatement", "yulFunctionDefinition", "yulPath", "yulFunctionCall",
		"yulBoolean", "yulLiteral", "yulExpression",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 177, 1299, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
		0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0, 197, 8, 0, 10, 0, 12, 0, 200,
		9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 4, 1, 206, 8, 1, 11, 1, 12, 1, 207, 1, 1,
		1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 216, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 228, 8, 2, 1, 2, 1, 2, 1, 3,
		1, 3, 1, 3, 3, 3, 235, 8, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 5, 5,
		243, 8, 5, 10, 5, 12, 5, 246, 9, 5, 1, 5, 1, 5, 1, 6, 3, 6, 251, 8, 6,
		1, 6, 1, 6, 1, 6, 3, 6, 256, 8, 6, 1, 6, 1, 6, 5, 6, 260, 8, 6, 10, 6,
		12, 6, 263, 9, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 3, 7, 270, 8, 7, 1, 7,
		1, 7, 5, 7, 274, 8, 7, 10, 7, 12, 7, 277, 9, 7, 1, 7, 1, 7, 1, 8, 1, 8,
		1, 8, 1, 8, 5, 8, 285, 8, 8, 10, 8, 12, 8, 288, 9, 8, 1, 8, 1, 8, 1, 9,
		1, 9, 1, 9, 1, 9, 5, 9, 296, 8, 9, 10, 9, 12, 9, 299, 9, 9, 1, 10, 1, 10,
		3, 10, 303, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 317, 8, 11, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 327, 8, 13, 10, 13, 12, 13, 330,
		9, 13, 3, 13, 332, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 338, 8, 13,
		10, 13, 12, 13, 341, 9, 13, 3, 13, 343, 8, 13, 1, 13, 3, 13, 346, 8, 13,
		1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 5, 14, 353, 8, 14, 10, 14, 12, 14, 356,
		9, 14, 1, 15, 1, 15, 3, 15, 360, 8, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1,
		17, 5, 17, 367, 8, 17, 10, 17, 12, 17, 370, 9, 17, 1, 18, 1, 18, 3, 18,
		374, 8, 18, 1, 18, 3, 18, 377, 8, 18, 1, 19, 1, 19, 1, 19, 3, 19, 382,
		8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 5, 19, 395, 8, 19, 10, 19, 12, 19, 398, 9, 19, 1, 19, 1, 19,
		1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 409, 8, 21, 10,
		21, 12, 21, 412, 9, 21, 1, 21, 1, 21, 3, 21, 416, 8, 21, 1, 22, 1, 22,
		1, 22, 1, 22, 3, 22, 422, 8, 22, 1, 22, 1, 22, 3, 22, 426, 8, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 445, 8, 22, 10, 22, 12, 22,
		448, 9, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 455, 8, 22, 1, 22,
		1, 22, 3, 22, 459, 8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 465, 8, 23,
		1, 23, 3, 23, 468, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 5, 23, 477, 8, 23, 10, 23, 12, 23, 480, 9, 23, 1, 23, 1, 23, 3, 23,
		484, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 491, 8, 24, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 5, 24, 509, 8, 24, 10, 24, 12, 24, 512,
		9, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 521, 8,
		24, 1, 24, 1, 24, 3, 24, 525, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 25, 5, 25, 544, 8, 25, 10, 25, 12, 25, 547, 9, 25, 1, 25, 1, 25,
		3, 25, 551, 8, 25, 1, 26, 1, 26, 1, 26, 1, 26, 4, 26, 557, 8, 26, 11, 26,
		12, 26, 558, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 5, 28, 573, 8, 28, 10, 28, 12, 28, 576, 9, 28,
		1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 606, 8, 30, 10,
		30, 12, 30, 609, 9, 30, 1, 30, 1, 30, 1, 30, 3, 30, 614, 8, 30, 1, 30,
		1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 3,
		32, 627, 8, 32, 1, 32, 3, 32, 630, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 5, 33, 638, 8, 33, 10, 33, 12, 33, 641, 9, 33, 3, 33, 643, 8,
		33, 1, 33, 1, 33, 3, 33, 647, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 3, 34,
		653, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 661, 8, 35,
		10, 35, 12, 35, 664, 9, 35, 3, 35, 666, 8, 35, 1, 35, 1, 35, 1, 35, 1,
		36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 679, 8, 37,
		1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 685, 8, 37, 5, 37, 687, 8, 37, 10, 37,
		12, 37, 690, 9, 37, 1, 37, 1, 37, 3, 37, 694, 8, 37, 1, 37, 1, 37, 1, 37,
		3, 37, 699, 8, 37, 1, 37, 3, 37, 702, 8, 37, 1, 37, 1, 37, 1, 38, 1, 38,
		1, 38, 1, 38, 1, 38, 3, 38, 711, 8, 38, 1, 38, 1, 38, 1, 38, 3, 38, 716,
		8, 38, 1, 38, 5, 38, 719, 8, 38, 10, 38, 12, 38, 722, 9, 38, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39,
		3, 39, 736, 8, 39, 1, 40, 1, 40, 1, 40, 3, 40, 741, 8, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 752, 8, 40, 10,
		40, 12, 40, 755, 9, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 762,
		8, 40, 1, 41, 1, 41, 3, 41, 766, 8, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 790, 8, 43, 3,
		43, 792, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 840, 8, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 3, 43, 846, 8, 43, 1, 43, 1, 43, 3, 43, 850, 8, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 857, 8, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 5, 43, 864, 8, 43, 10, 43, 12, 43, 867, 9, 43, 3, 43,
		869, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 876, 8, 43, 10, 43,
		12, 43, 879, 9, 43, 1, 44, 1, 44, 1, 45, 1, 45, 3, 45, 885, 8, 45, 1, 45,
		1, 45, 3, 45, 889, 8, 45, 5, 45, 891, 8, 45, 10, 45, 12, 45, 894, 9, 45,
		1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 902, 8, 46, 10, 46, 12,
		46, 905, 9, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 3, 48, 916, 8, 48, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 51, 4,
		51, 924, 8, 51, 11, 51, 12, 51, 925, 1, 52, 4, 52, 929, 8, 52, 11, 52,
		12, 52, 930, 1, 53, 4, 53, 934, 8, 53, 11, 53, 12, 53, 935, 1, 54, 1, 54,
		1, 55, 1, 55, 1, 55, 5, 55, 943, 8, 55, 10, 55, 12, 55, 946, 9, 55, 1,
		55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 966, 8, 57, 1,
		58, 1, 58, 3, 58, 970, 8, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 3, 59, 979, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 985, 8, 60,
		1, 60, 1, 60, 3, 60, 989, 8, 60, 1, 60, 3, 60, 992, 8, 60, 1, 60, 1, 60,
		1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64,
		1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1024, 8, 65, 1,
		65, 1, 65, 4, 65, 1028, 8, 65, 11, 65, 12, 65, 1029, 1, 66, 1, 66, 3, 66,
		1034, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1040, 8, 66, 1, 66, 1,
		66, 1, 67, 1, 67, 3, 67, 1046, 8, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 3, 70, 1062,
		8, 70, 1, 70, 3, 70, 1065, 8, 70, 1, 70, 1, 70, 5, 70, 1069, 8, 70, 10,
		70, 12, 70, 1072, 9, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 5, 71,
		1080, 8, 71, 10, 71, 12, 71, 1083, 9, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1,
		72, 5, 72, 1090, 8, 72, 10, 72, 12, 72, 1093, 9, 72, 1, 73, 1, 73, 5, 73,
		1097, 8, 73, 10, 73, 12, 73, 1100, 9, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3,
		73, 1106, 8, 73, 5, 73, 1108, 8, 73, 10, 73, 12, 73, 1111, 9, 73, 1, 73,
		1, 73, 1, 74, 1, 74, 1, 74, 3, 74, 1118, 8, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 3, 74, 1124, 8, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76,
		1, 76, 1, 76, 3, 76, 1135, 8, 76, 1, 76, 1, 76, 1, 76, 3, 76, 1140, 8,
		76, 1, 76, 1, 76, 1, 77, 1, 77, 3, 77, 1146, 8, 77, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1159, 8,
		78, 1, 79, 1, 79, 5, 79, 1163, 8, 79, 10, 79, 12, 79, 1166, 9, 79, 1, 79,
		1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1174, 8, 80, 1, 80, 1, 80, 1,
		80, 1, 80, 5, 80, 1180, 8, 80, 10, 80, 12, 80, 1183, 9, 80, 1, 80, 1, 80,
		3, 80, 1187, 8, 80, 3, 80, 1189, 8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1,
		81, 1, 81, 1, 81, 4, 81, 1198, 8, 81, 11, 81, 12, 81, 1199, 1, 81, 1, 81,
		1, 81, 3, 81, 1205, 8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85,
		4, 85, 1224, 8, 85, 11, 85, 12, 85, 1225, 1, 85, 1, 85, 3, 85, 1230, 8,
		85, 1, 85, 1, 85, 3, 85, 1234, 8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86,
		1, 86, 5, 86, 1242, 8, 86, 10, 86, 12, 86, 1245, 9, 86, 3, 86, 1247, 8,
		86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 5, 86, 1254, 8, 86, 10, 86, 12,
		86, 1257, 9, 86, 3, 86, 1259, 8, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87,
		5, 87, 1266, 8, 87, 10, 87, 12, 87, 1269, 9, 87, 1, 88, 1, 88, 1, 88, 1,
		88, 1, 88, 5, 88, 1276, 8, 88, 10, 88, 12, 88, 1279, 9, 88, 3, 88, 1281,
		8, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3,
		90, 1292, 8, 90, 1, 91, 1, 91, 1, 91, 3, 91, 1297, 8, 91, 1, 91, 1, 297,
		2, 76, 86, 92, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
		68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
		104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132,
		134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162,
		164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 0, 18, 3, 0, 23, 23,
		38, 38, 49, 50, 3, 0, 47, 47, 51, 51, 68, 68, 4, 0, 98, 100, 104, 108,
		110, 115, 117, 117, 3, 0, 10, 10, 42, 42, 57, 57, 3, 0, 16, 16, 105, 105,
		116, 119, 1, 0, 106, 108, 1, 0, 104, 105, 1, 0, 101, 103, 1, 0, 112, 115,
		1, 0, 110, 111, 1, 0, 118, 119, 1, 0, 83, 94, 5, 0, 21, 21, 29, 29, 31,
		31, 55, 55, 130, 130, 2, 0, 25, 25, 60, 60, 1, 0, 122, 123, 2, 0, 126,
		126, 128, 128, 2, 0, 156, 156, 165, 165, 2, 0, 147, 147, 154, 154, 1446,
		0, 198, 1, 0, 0, 0, 2, 203, 1, 0, 0, 0, 4, 211, 1, 0, 0, 0, 6, 231, 1,
		0, 0, 0, 8, 236, 1, 0, 0, 0, 10, 238, 1, 0, 0, 0, 12, 250, 1, 0, 0, 0,
		14, 266, 1, 0, 0, 0, 16, 280, 1, 0, 0, 0, 18, 291, 1, 0, 0, 0, 20, 300,
		1, 0, 0, 0, 22, 316, 1, 0, 0, 0, 24, 318, 1, 0, 0, 0, 26, 322, 1, 0, 0,
		0, 28, 349, 1, 0, 0, 0, 30, 357, 1, 0, 0, 0, 32, 361, 1, 0, 0, 0, 34, 363,
		1, 0, 0, 0, 36, 371, 1, 0, 0, 0, 38, 378, 1, 0, 0, 0, 40, 401, 1, 0, 0,
		0, 42, 403, 1, 0, 0, 0, 44, 417, 1, 0, 0, 0, 46, 460, 1, 0, 0, 0, 48, 485,
		1, 0, 0, 0, 50, 526, 1, 0, 0, 0, 52, 552, 1, 0, 0, 0, 54, 562, 1, 0, 0,
		0, 56, 566, 1, 0, 0, 0, 58, 579, 1, 0, 0, 0, 60, 585, 1, 0, 0, 0, 62, 617,
		1, 0, 0, 0, 64, 624, 1, 0, 0, 0, 66, 631, 1, 0, 0, 0, 68, 650, 1, 0, 0,
		0, 70, 654, 1, 0, 0, 0, 72, 670, 1, 0, 0, 0, 74, 672, 1, 0, 0, 0, 76, 710,
		1, 0, 0, 0, 78, 735, 1, 0, 0, 0, 80, 737, 1, 0, 0, 0, 82, 763, 1, 0, 0,
		0, 84, 769, 1, 0, 0, 0, 86, 791, 1, 0, 0, 0, 88, 880, 1, 0, 0, 0, 90, 882,
		1, 0, 0, 0, 92, 897, 1, 0, 0, 0, 94, 908, 1, 0, 0, 0, 96, 915, 1, 0, 0,
		0, 98, 917, 1, 0, 0, 0, 100, 920, 1, 0, 0, 0, 102, 923, 1, 0, 0, 0, 104,
		928, 1, 0, 0, 0, 106, 933, 1, 0, 0, 0, 108, 937, 1, 0, 0, 0, 110, 939,
		1, 0, 0, 0, 112, 949, 1, 0, 0, 0, 114, 965, 1, 0, 0, 0, 116, 969, 1, 0,
		0, 0, 118, 971, 1, 0, 0, 0, 120, 980, 1, 0, 0, 0, 122, 996, 1, 0, 0, 0,
		124, 1002, 1, 0, 0, 0, 126, 1010, 1, 0, 0, 0, 128, 1013, 1, 0, 0, 0, 130,
		1016, 1, 0, 0, 0, 132, 1031, 1, 0, 0, 0, 134, 1043, 1, 0, 0, 0, 136, 1049,
		1, 0, 0, 0, 138, 1054, 1, 0, 0, 0, 140, 1059, 1, 0, 0, 0, 142, 1075, 1,
		0, 0, 0, 144, 1086, 1, 0, 0, 0, 146, 1094, 1, 0, 0, 0, 148, 1123, 1, 0,
		0, 0, 150, 1127, 1, 0, 0, 0, 152, 1130, 1, 0, 0, 0, 154, 1145, 1, 0, 0,
		0, 156, 1158, 1, 0, 0, 0, 158, 1160, 1, 0, 0, 0, 160, 1188, 1, 0, 0, 0,
		162, 1204, 1, 0, 0, 0, 164, 1206, 1, 0, 0, 0, 166, 1210, 1, 0, 0, 0, 168,
		1216, 1, 0, 0, 0, 170, 1220, 1, 0, 0, 0, 172, 1235, 1, 0, 0, 0, 174, 1262,
		1, 0, 0, 0, 176, 1270, 1, 0, 0, 0, 178, 1284, 1, 0, 0, 0, 180, 1291, 1,
		0, 0, 0, 182, 1296, 1, 0, 0, 0, 184, 197, 3, 2, 1, 0, 185, 197, 3, 4, 2,
		0, 186, 197, 3, 74, 37, 0, 187, 197, 3, 12, 6, 0, 188, 197, 3, 14, 7, 0,
		189, 197, 3, 16, 8, 0, 190, 197, 3, 44, 22, 0, 191, 197, 3, 62, 31, 0,
		192, 197, 3, 52, 26, 0, 193, 197, 3, 56, 28, 0, 194, 197, 3, 58, 29, 0,
		195, 197, 3, 70, 35, 0, 196, 184, 1, 0, 0, 0, 196, 185, 1, 0, 0, 0, 196,
		186, 1, 0, 0, 0, 196, 187, 1, 0, 0, 0, 196, 188, 1, 0, 0, 0, 196, 189,
		1, 0, 0, 0, 196, 190, 1, 0, 0, 0, 196, 191, 1, 0, 0, 0, 196, 192, 1, 0,
		0, 0, 196, 193, 1, 0, 0, 0, 196, 194, 1, 0, 0, 0, 196, 195, 1, 0, 0, 0,
		197, 200, 1, 0, 0, 0, 198, 196, 1, 0, 0, 0, 198, 199, 1, 0, 0, 0, 199,
		201, 1, 0, 0, 0, 200, 198, 1, 0, 0, 0, 201, 202, 5, 0, 0, 1, 202, 1, 1,
		0, 0, 0, 203, 205, 5, 48, 0, 0, 204, 206, 5, 173, 0, 0, 205, 204, 1, 0,
		0, 0, 206, 207, 1, 0, 0, 0, 207, 205, 1, 0, 0, 0, 207, 208, 1, 0, 0, 0,
		208, 209, 1, 0, 0, 0, 209, 210, 5, 174, 0, 0, 210, 3, 1, 0, 0, 0, 211,
		227, 5, 35, 0, 0, 212, 215, 3, 8, 4, 0, 213, 214, 5, 5, 0, 0, 214, 216,
		3, 94, 47, 0, 215, 213, 1, 0, 0, 0, 215, 216, 1, 0, 0, 0, 216, 228, 1,
		0, 0, 0, 217, 218, 3, 10, 5, 0, 218, 219, 5, 29, 0, 0, 219, 220, 3, 8,
		4, 0, 220, 228, 1, 0, 0, 0, 221, 222, 5, 106, 0, 0, 222, 223, 5, 5, 0,
		0, 223, 224, 3, 94, 47, 0, 224, 225, 5, 29, 0, 0, 225, 226, 3, 8, 4, 0,
		226, 228, 1, 0, 0, 0, 227, 212, 1, 0, 0, 0, 227, 217, 1, 0, 0, 0, 227,
		221, 1, 0, 0, 0, 228, 229, 1, 0, 0, 0, 229, 230, 5, 78, 0, 0, 230, 5, 1,
		0, 0, 0, 231, 234, 3, 94, 47, 0, 232, 233, 5, 5, 0, 0, 233, 235, 3, 94,
		47, 0, 234, 232, 1, 0, 0, 0, 234, 235, 1, 0, 0, 0, 235, 7, 1, 0, 0, 0,
		236, 237, 5, 122, 0, 0, 237, 9, 1, 0, 0, 0, 238, 239, 5, 75, 0, 0, 239,
		244, 3, 6, 3, 0, 240, 241, 5, 95, 0, 0, 241, 243, 3, 6, 3, 0, 242, 240,
		1, 0, 0, 0, 243, 246, 1, 0, 0, 0, 244, 242, 1, 0, 0, 0, 244, 245, 1, 0,
		0, 0, 245, 247, 1, 0, 0, 0, 246, 244, 1, 0, 0, 0, 247, 248, 5, 76, 0, 0,
		248, 11, 1, 0, 0, 0, 249, 251, 5, 2, 0, 0, 250, 249, 1, 0, 0, 0, 250, 251,
		1, 0, 0, 0, 251, 252, 1, 0, 0, 0, 252, 253, 5, 15, 0, 0, 253, 255, 3, 94,
		47, 0, 254, 256, 3, 18, 9, 0, 255, 254, 1, 0, 0, 0, 255, 256, 1, 0, 0,
		0, 256, 257, 1, 0, 0, 0, 257, 261, 5, 75, 0, 0, 258, 260, 3, 22, 11, 0,
		259, 258, 1, 0, 0, 0, 260, 263, 1, 0, 0, 0, 261, 259, 1, 0, 0, 0, 261,
		262, 1, 0, 0, 0, 262, 264, 1, 0, 0, 0, 263, 261, 1, 0, 0, 0, 264, 265,
		5, 76, 0, 0, 265, 13, 1, 0, 0, 0, 266, 267, 5, 37, 0, 0, 267, 269, 3, 94,
		47, 0, 268, 270, 3, 18, 9, 0, 269, 268, 1, 0, 0, 0, 269, 270, 1, 0, 0,
		0, 270, 271, 1, 0, 0, 0, 271, 275, 5, 75, 0, 0, 272, 274, 3, 22, 11, 0,
		273, 272, 1, 0, 0, 0, 274, 277, 1, 0, 0, 0, 275, 273, 1, 0, 0, 0, 275,
		276, 1, 0, 0, 0, 276, 278, 1, 0, 0, 0, 277, 275, 1, 0, 0, 0, 278, 279,
		5, 76, 0, 0, 279, 15, 1, 0, 0, 0, 280, 281, 5, 40, 0, 0, 281, 282, 3, 94,
		47, 0, 282, 286, 5, 75, 0, 0, 283, 285, 3, 22, 11, 0, 284, 283, 1, 0, 0,
		0, 285, 288, 1, 0, 0, 0, 286, 284, 1, 0, 0, 0, 286, 287, 1, 0, 0, 0, 287,
		289, 1, 0, 0, 0, 288, 286, 1, 0, 0, 0, 289, 290, 5, 76, 0, 0, 290, 17,
		1, 0, 0, 0, 291, 292, 5, 39, 0, 0, 292, 297, 3, 20, 10, 0, 293, 294, 5,
		95, 0, 0, 294, 296, 3, 20, 10, 0, 295, 293, 1, 0, 0, 0, 296, 299, 1, 0,
		0, 0, 297, 298, 1, 0, 0, 0, 297, 295, 1, 0, 0, 0, 298, 19, 1, 0, 0, 0,
		299, 297, 1, 0, 0, 0, 300, 302, 3, 28, 14, 0, 301, 303, 3, 26, 13, 0, 302,
		301, 1, 0, 0, 0, 302, 303, 1, 0, 0, 0, 303, 21, 1, 0, 0, 0, 304, 317, 3,
		38, 19, 0, 305, 317, 3, 44, 22, 0, 306, 317, 3, 46, 23, 0, 307, 317, 3,
		48, 24, 0, 308, 317, 3, 50, 25, 0, 309, 317, 3, 52, 26, 0, 310, 317, 3,
		56, 28, 0, 311, 317, 3, 58, 29, 0, 312, 317, 3, 60, 30, 0, 313, 317, 3,
		66, 33, 0, 314, 317, 3, 70, 35, 0, 315, 317, 3, 74, 37, 0, 316, 304, 1,
		0, 0, 0, 316, 305, 1, 0, 0, 0, 316, 306, 1, 0, 0, 0, 316, 307, 1, 0, 0,
		0, 316, 308, 1, 0, 0, 0, 316, 309, 1, 0, 0, 0, 316, 310, 1, 0, 0, 0, 316,
		311, 1, 0, 0, 0, 316, 312, 1, 0, 0, 0, 316, 313, 1, 0, 0, 0, 316, 314,
		1, 0, 0, 0, 316, 315, 1, 0, 0, 0, 317, 23, 1, 0, 0, 0, 318, 319, 3, 94,
		47, 0, 319, 320, 5, 77, 0, 0, 320, 321, 3, 86, 43, 0, 321, 25, 1, 0, 0,
		0, 322, 345, 5, 71, 0, 0, 323, 328, 3, 86, 43, 0, 324, 325, 5, 95, 0, 0,
		325, 327, 3, 86, 43, 0, 326, 324, 1, 0, 0, 0, 327, 330, 1, 0, 0, 0, 328,
		326, 1, 0, 0, 0, 328, 329, 1, 0, 0, 0, 329, 332, 1, 0, 0, 0, 330, 328,
		1, 0, 0, 0, 331, 323, 1, 0, 0, 0, 331, 332, 1, 0, 0, 0, 332, 346, 1, 0,
		0, 0, 333, 342, 5, 75, 0, 0, 334, 339, 3, 24, 12, 0, 335, 336, 5, 95, 0,
		0, 336, 338, 3, 24, 12, 0, 337, 335, 1, 0, 0, 0, 338, 341, 1, 0, 0, 0,
		339, 337, 1, 0, 0, 0, 339, 340, 1, 0, 0, 0, 340, 343, 1, 0, 0, 0, 341,
		339, 1, 0, 0, 0, 342, 334, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343, 344,
		1, 0, 0, 0, 344, 346, 5, 76, 0, 0, 345, 331, 1, 0, 0, 0, 345, 333, 1, 0,
		0, 0, 346, 347, 1, 0, 0, 0, 347, 348, 5, 72, 0, 0, 348, 27, 1, 0, 0, 0,
		349, 354, 3, 94, 47, 0, 350, 351, 5, 79, 0, 0, 351, 353, 3, 94, 47, 0,
		352, 350, 1, 0, 0, 0, 353, 356, 1, 0, 0, 0, 354, 352, 1, 0, 0, 0, 354,
		355, 1, 0, 0, 0, 355, 29, 1, 0, 0, 0, 356, 354, 1, 0, 0, 0, 357, 359, 3,
		28, 14, 0, 358, 360, 3, 26, 13, 0, 359, 358, 1, 0, 0, 0, 359, 360, 1, 0,
		0, 0, 360, 31, 1, 0, 0, 0, 361, 362, 7, 0, 0, 0, 362, 33, 1, 0, 0, 0, 363,
		368, 3, 36, 18, 0, 364, 365, 5, 95, 0, 0, 365, 367, 3, 36, 18, 0, 366,
		364, 1, 0, 0, 0, 367, 370, 1, 0, 0, 0, 368, 366, 1, 0, 0, 0, 368, 369,
		1, 0, 0, 0, 369, 35, 1, 0, 0, 0, 370, 368, 1, 0, 0, 0, 371, 373, 3, 76,
		38, 0, 372, 374, 3, 84, 42, 0, 373, 372, 1, 0, 0, 0, 373, 374, 1, 0, 0,
		0, 374, 376, 1, 0, 0, 0, 375, 377, 3, 94, 47, 0, 376, 375, 1, 0, 0, 0,
		376, 377, 1, 0, 0, 0, 377, 37, 1, 0, 0, 0, 378, 379, 5, 13, 0, 0, 379,
		381, 5, 71, 0, 0, 380, 382, 3, 34, 17, 0, 381, 380, 1, 0, 0, 0, 381, 382,
		1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383, 396, 5, 72, 0, 0, 384, 395, 3, 30,
		15, 0, 385, 386, 4, 19, 0, 1, 386, 387, 5, 47, 0, 0, 387, 395, 6, 19, -1,
		0, 388, 389, 4, 19, 1, 1, 389, 390, 5, 38, 0, 0, 390, 395, 6, 19, -1, 0,
		391, 392, 4, 19, 2, 1, 392, 393, 5, 50, 0, 0, 393, 395, 6, 19, -1, 0, 394,
		384, 1, 0, 0, 0, 394, 385, 1, 0, 0, 0, 394, 388, 1, 0, 0, 0, 394, 391,
		1, 0, 0, 0, 395, 398, 1, 0, 0, 0, 396, 394, 1, 0, 0, 0, 396, 397, 1, 0,
		0, 0, 397, 399, 1, 0, 0, 0, 398, 396, 1, 0, 0, 0, 399, 400, 3, 110, 55,
		0, 400, 39, 1, 0, 0, 0, 401, 402, 7, 1, 0, 0, 402, 41, 1, 0, 0, 0, 403,
		415, 5, 46, 0, 0, 404, 405, 5, 71, 0, 0, 405, 410, 3, 28, 14, 0, 406, 407,
		5, 95, 0, 0, 407, 409, 3, 28, 14, 0, 408, 406, 1, 0, 0, 0, 409, 412, 1,
		0, 0, 0, 410, 408, 1, 0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 413, 1, 0, 0,
		0, 412, 410, 1, 0, 0, 0, 413, 414, 5, 72, 0, 0, 414, 416, 1, 0, 0, 0, 415,
		404, 1, 0, 0, 0, 415, 416, 1, 0, 0, 0, 416, 43, 1, 0, 0, 0, 417, 421, 5,
		30, 0, 0, 418, 422, 3, 94, 47, 0, 419, 422, 5, 24, 0, 0, 420, 422, 5, 52,
		0, 0, 421, 418, 1, 0, 0, 0, 421, 419, 1, 0, 0, 0, 421, 420, 1, 0, 0, 0,
		422, 423, 1, 0, 0, 0, 423, 425, 5, 71, 0, 0, 424, 426, 3, 34, 17, 0, 425,
		424, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 446,
		5, 72, 0, 0, 428, 429, 4, 22, 3, 1, 429, 430, 3, 32, 16, 0, 430, 431, 6,
		22, -1, 0, 431, 445, 1, 0, 0, 0, 432, 433, 4, 22, 4, 1, 433, 434, 3, 40,
		20, 0, 434, 435, 6, 22, -1, 0, 435, 445, 1, 0, 0, 0, 436, 445, 3, 30, 15,
		0, 437, 438, 4, 22, 5, 1, 438, 439, 5, 69, 0, 0, 439, 445, 6, 22, -1, 0,
		440, 441, 4, 22, 6, 1, 441, 442, 3, 42, 21, 0, 442, 443, 6, 22, -1, 0,
		443, 445, 1, 0, 0, 0, 444, 428, 1, 0, 0, 0, 444, 432, 1, 0, 0, 0, 444,
		436, 1, 0, 0, 0, 444, 437, 1, 0, 0, 0, 444, 440, 1, 0, 0, 0, 445, 448,
		1, 0, 0, 0, 446, 444, 1, 0, 0, 0, 446, 447, 1, 0, 0, 0, 447, 454, 1, 0,
		0, 0, 448, 446, 1, 0, 0, 0, 449, 450, 5, 54, 0, 0, 450, 451, 5, 71, 0,
		0, 451, 452, 3, 34, 17, 0, 452, 453, 5, 72, 0, 0, 453, 455, 1, 0, 0, 0,
		454, 449, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 458, 1, 0, 0, 0, 456,
		459, 5, 78, 0, 0, 457, 459, 3, 110, 55, 0, 458, 456, 1, 0, 0, 0, 458, 457,
		1, 0, 0, 0, 459, 45, 1, 0, 0, 0, 460, 461, 5, 43, 0, 0, 461, 467, 3, 94,
		47, 0, 462, 464, 5, 71, 0, 0, 463, 465, 3, 34, 17, 0, 464, 463, 1, 0, 0,
		0, 464, 465, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0, 466, 468, 5, 72, 0, 0, 467,
		462, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 478, 1, 0, 0, 0, 469, 470,
		4, 23, 7, 1, 470, 471, 5, 69, 0, 0, 471, 477, 6, 23, -1, 0, 472, 473, 4,
		23, 8, 1, 473, 474, 3, 42, 21, 0, 474, 475, 6, 23, -1, 0, 475, 477, 1,
		0, 0, 0, 476, 469, 1, 0, 0, 0, 476, 472, 1, 0, 0, 0, 477, 480, 1, 0, 0,
		0, 478, 476, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 483, 1, 0, 0, 0, 480,
		478, 1, 0, 0, 0, 481, 484, 5, 78, 0, 0, 482, 484, 3, 110, 55, 0, 483, 481,
		1, 0, 0, 0, 483, 482, 1, 0, 0, 0, 484, 47, 1, 0, 0, 0, 485, 486, 5, 24,
		0, 0, 486, 490, 5, 71, 0, 0, 487, 488, 3, 34, 17, 0, 488, 489, 6, 24, -1,
		0, 489, 491, 1, 0, 0, 0, 490, 487, 1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491,
		492, 1, 0, 0, 0, 492, 510, 5, 72, 0, 0, 493, 494, 4, 24, 9, 1, 494, 495,
		5, 23, 0, 0, 495, 509, 6, 24, -1, 0, 496, 497, 4, 24, 10, 1, 497, 498,
		3, 40, 20, 0, 498, 499, 6, 24, -1, 0, 499, 509, 1, 0, 0, 0, 500, 509, 3,
		30, 15, 0, 501, 502, 4, 24, 11, 1, 502, 503, 5, 69, 0, 0, 503, 509, 6,
		24, -1, 0, 504, 505, 4, 24, 12, 1, 505, 506, 3, 42, 21, 0, 506, 507, 6,
		24, -1, 0, 507, 509, 1, 0, 0, 0, 508, 493, 1, 0, 0, 0, 508, 496, 1, 0,
		0, 0, 508, 500, 1, 0, 0, 0, 508, 501, 1, 0, 0, 0, 508, 504, 1, 0, 0, 0,
		509, 512, 1, 0, 0, 0, 510, 508, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511,
		520, 1, 0, 0, 0, 512, 510, 1, 0, 0, 0, 513, 514, 4, 24, 13, 1, 514, 515,
		5, 54, 0, 0, 515, 516, 5, 71, 0, 0, 516, 517, 3, 34, 17, 0, 517, 518, 5,
		72, 0, 0, 518, 521, 1, 0, 0, 0, 519, 521, 4, 24, 14, 1, 520, 513, 1, 0,
		0, 0, 520, 519, 1, 0, 0, 0, 521, 524, 1, 0, 0, 0, 522, 525, 5, 78, 0, 0,
		523, 525, 3, 110, 55, 0, 524, 522, 1, 0, 0, 0, 524, 523, 1, 0, 0, 0, 525,
		49, 1, 0, 0, 0, 526, 527, 5, 52, 0, 0, 527, 528, 5, 71, 0, 0, 528, 545,
		5, 72, 0, 0, 529, 530, 4, 25, 15, 1, 530, 531, 5, 23, 0, 0, 531, 544, 6,
		25, -1, 0, 532, 533, 4, 25, 16, 1, 533, 534, 5, 47, 0, 0, 534, 544, 6,
		25, -1, 0, 535, 544, 3, 30, 15, 0, 536, 537, 4, 25, 17, 1, 537, 538, 5,
		69, 0, 0, 538, 544, 6, 25, -1, 0, 539, 540, 4, 25, 18, 1, 540, 541, 3,
		42, 21, 0, 541, 542, 6, 25, -1, 0, 542, 544, 1, 0, 0, 0, 543, 529, 1, 0,
		0, 0, 543, 532, 1, 0, 0, 0, 543, 535, 1, 0, 0, 0, 543, 536, 1, 0, 0, 0,
		543, 539, 1, 0, 0, 0, 544, 547, 1, 0, 0, 0, 545, 543, 1, 0, 0, 0, 545,
		546, 1, 0, 0, 0, 546, 550, 1, 0, 0, 0, 547, 545, 1, 0, 0, 0, 548, 551,
		5, 78, 0, 0, 549, 551, 3, 110, 55, 0, 550, 548, 1, 0, 0, 0, 550, 549, 1,
		0, 0, 0, 551, 51, 1, 0, 0, 0, 552, 553, 5, 59, 0, 0, 553, 554, 3, 94, 47,
		0, 554, 556, 5, 75, 0, 0, 555, 557, 3, 54, 27, 0, 556, 555, 1, 0, 0, 0,
		557, 558, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559,
		560, 1, 0, 0, 0, 560, 561, 5, 76, 0, 0, 561, 53, 1, 0, 0, 0, 562, 563,
		3, 76, 38, 0, 563, 564, 3, 94, 47, 0, 564, 565, 5, 78, 0, 0, 565, 55, 1,
		0, 0, 0, 566, 567, 5, 20, 0, 0, 567, 568, 3, 94, 47, 0, 568, 569, 5, 75,
		0, 0, 569, 574, 3, 94, 47, 0, 570, 571, 5, 95, 0, 0, 571, 573, 3, 94, 47,
		0, 572, 570, 1, 0, 0, 0, 573, 576, 1, 0, 0, 0, 574, 572, 1, 0, 0, 0, 574,
		575, 1, 0, 0, 0, 575, 577, 1, 0, 0, 0, 576, 574, 1, 0, 0, 0, 577, 578,
		5, 76, 0, 0, 578, 57, 1, 0, 0, 0, 579, 580, 5, 62, 0, 0, 580, 581, 3, 94,
		47, 0, 581, 582, 5, 39, 0, 0, 582, 583, 3, 78, 39, 0, 583, 584, 5, 78,
		0, 0, 584, 59, 1, 0, 0, 0, 585, 607, 3, 76, 38, 0, 586, 587, 4, 30, 19,
		1, 587, 588, 5, 50, 0, 0, 588, 606, 6, 30, -1, 0, 589, 590, 4, 30, 20,
		1, 590, 591, 5, 49, 0, 0, 591, 606, 6, 30, -1, 0, 592, 593, 4, 30, 21,
		1, 593, 594, 5, 38, 0, 0, 594, 606, 6, 30, -1, 0, 595, 596, 4, 30, 22,
		1, 596, 597, 5, 12, 0, 0, 597, 606, 6, 30, -1, 0, 598, 599, 4, 30, 23,
		1, 599, 600, 3, 42, 21, 0, 600, 601, 6, 30, -1, 0, 601, 606, 1, 0, 0, 0,
		602, 603, 4, 30, 24, 1, 603, 604, 5, 34, 0, 0, 604, 606, 6, 30, -1, 0,
		605, 586, 1, 0, 0, 0, 605, 589, 1, 0, 0, 0, 605, 592, 1, 0, 0, 0, 605,
		595, 1, 0, 0, 0, 605, 598, 1, 0, 0, 0, 605, 602, 1, 0, 0, 0, 606, 609,
		1, 0, 0, 0, 607, 605, 1, 0, 0, 0, 607, 608, 1, 0, 0, 0, 608, 610, 1, 0,
		0, 0, 609, 607, 1, 0, 0, 0, 610, 613, 3, 94, 47, 0, 611, 612, 5, 83, 0,
		0, 612, 614, 3, 86, 43, 0, 613, 611, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0,
		614, 615, 1, 0, 0, 0, 615, 616, 5, 78, 0, 0, 616, 61, 1, 0, 0, 0, 617,
		618, 3, 76, 38, 0, 618, 619, 5, 12, 0, 0, 619, 620, 3, 94, 47, 0, 620,
		621, 5, 83, 0, 0, 621, 622, 3, 86, 43, 0, 622, 623, 5, 78, 0, 0, 623, 63,
		1, 0, 0, 0, 624, 626, 3, 76, 38, 0, 625, 627, 5, 36, 0, 0, 626, 625, 1,
		0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 629, 1, 0, 0, 0, 628, 630, 3, 94, 47,
		0, 629, 628, 1, 0, 0, 0, 629, 630, 1, 0, 0, 0, 630, 65, 1, 0, 0, 0, 631,
		632, 5, 22, 0, 0, 632, 633, 3, 94, 47, 0, 633, 642, 5, 71, 0, 0, 634, 639,
		3, 64, 32, 0, 635, 636, 5, 95, 0, 0, 636, 638, 3, 64, 32, 0, 637, 635,
		1, 0, 0, 0, 638, 641, 1, 0, 0, 0, 639, 637, 1, 0, 0, 0, 639, 640, 1, 0,
		0, 0, 640, 643, 1, 0, 0, 0, 641, 639, 1, 0, 0, 0, 642, 634, 1, 0, 0, 0,
		642, 643, 1, 0, 0, 0, 643, 644, 1, 0, 0, 0, 644, 646, 5, 72, 0, 0, 645,
		647, 5, 4, 0, 0, 646, 645, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 648,
		1, 0, 0, 0, 648, 649, 5, 78, 0, 0, 649, 67, 1, 0, 0, 0, 650, 652, 3, 76,
		38, 0, 651, 653, 3, 94, 47, 0, 652, 651, 1, 0, 0, 0, 652, 653, 1, 0, 0,
		0, 653, 69, 1, 0, 0, 0, 654, 655, 5, 21, 0, 0, 655, 656, 3, 94, 47, 0,
		656, 665, 5, 71, 0, 0, 657, 662, 3, 68, 34, 0, 658, 659, 5, 95, 0, 0, 659,
		661, 3, 68, 34, 0, 660, 658, 1, 0, 0, 0, 661, 664, 1, 0, 0, 0, 662, 660,
		1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 666, 1, 0, 0, 0, 664, 662, 1, 0,
		0, 0, 665, 657, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0,
		667, 668, 5, 72, 0, 0, 668, 669, 5, 78, 0, 0, 669, 71, 1, 0, 0, 0, 670,
		671, 7, 2, 0, 0, 671, 73, 1, 0, 0, 0, 672, 693, 5, 67, 0, 0, 673, 694,
		3, 28, 14, 0, 674, 675, 5, 75, 0, 0, 675, 678, 3, 28, 14, 0, 676, 677,
		5, 5, 0, 0, 677, 679, 3, 72, 36, 0, 678, 676, 1, 0, 0, 0, 678, 679, 1,
		0, 0, 0, 679, 688, 1, 0, 0, 0, 680, 681, 5, 95, 0, 0, 681, 684, 3, 28,
		14, 0, 682, 683, 5, 5, 0, 0, 683, 685, 3, 72, 36, 0, 684, 682, 1, 0, 0,
		0, 684, 685, 1, 0, 0, 0, 685, 687, 1, 0, 0, 0, 686, 680, 1, 0, 0, 0, 687,
		690, 1, 0, 0, 0, 688, 686, 1, 0, 0, 0, 688, 689, 1, 0, 0, 0, 689, 691,
		1, 0, 0, 0, 690, 688, 1, 0, 0, 0, 691, 692, 5, 76, 0, 0, 692, 694, 1, 0,
		0, 0, 693, 673, 1, 0, 0, 0, 693, 674, 1, 0, 0, 0, 694, 695, 1, 0, 0, 0,
		695, 698, 5, 28, 0, 0, 696, 699, 5, 106, 0, 0, 697, 699, 3, 76, 38, 0,
		698, 696, 1, 0, 0, 0, 698, 697, 1, 0, 0, 0, 699, 701, 1, 0, 0, 0, 700,
		702, 5, 31, 0, 0, 701, 700, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 703,
		1, 0, 0, 0, 703, 704, 5, 78, 0, 0, 704, 75, 1, 0, 0, 0, 705, 706, 6, 38,
		-1, 0, 706, 711, 3, 78, 39, 0, 707, 711, 3, 80, 40, 0, 708, 711, 3, 152,
		76, 0, 709, 711, 3, 28, 14, 0, 710, 705, 1, 0, 0, 0, 710, 707, 1, 0, 0,
		0, 710, 708, 1, 0, 0, 0, 710, 709, 1, 0, 0, 0, 711, 720, 1, 0, 0, 0, 712,
		713, 10, 1, 0, 0, 713, 715, 5, 73, 0, 0, 714, 716, 3, 86, 43, 0, 715, 714,
		1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 719, 5, 74,
		0, 0, 718, 712, 1, 0, 0, 0, 719, 722, 1, 0, 0, 0, 720, 718, 1, 0, 0, 0,
		720, 721, 1, 0, 0, 0, 721, 77, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 723, 736,
		5, 3, 0, 0, 724, 725, 4, 39, 26, 1, 725, 726, 5, 3, 0, 0, 726, 736, 5,
		47, 0, 0, 727, 736, 5, 7, 0, 0, 728, 736, 5, 58, 0, 0, 729, 736, 5, 9,
		0, 0, 730, 736, 5, 56, 0, 0, 731, 736, 5, 66, 0, 0, 732, 736, 5, 27, 0,
		0, 733, 736, 5, 26, 0, 0, 734, 736, 5, 63, 0, 0, 735, 723, 1, 0, 0, 0,
		735, 724, 1, 0, 0, 0, 735, 727, 1, 0, 0, 0, 735, 728, 1, 0, 0, 0, 735,
		729, 1, 0, 0, 0, 735, 730, 1, 0, 0, 0, 735, 731, 1, 0, 0, 0, 735, 732,
		1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 735, 734, 1, 0, 0, 0, 736, 79, 1, 0,
		0, 0, 737, 738, 5, 30, 0, 0, 738, 740, 5, 71, 0, 0, 739, 741, 3, 34, 17,
		0, 740, 739, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742,
		753, 5, 72, 0, 0, 743, 744, 4, 40, 27, 1, 744, 745, 3, 32, 16, 0, 745,
		746, 6, 40, -1, 0, 746, 752, 1, 0, 0, 0, 747, 748, 4, 40, 28, 1, 748, 749,
		3, 40, 20, 0, 749, 750, 6, 40, -1, 0, 750, 752, 1, 0, 0, 0, 751, 743, 1,
		0, 0, 0, 751, 747, 1, 0, 0, 0, 752, 755, 1, 0, 0, 0, 753, 751, 1, 0, 0,
		0, 753, 754, 1, 0, 0, 0, 754, 761, 1, 0, 0, 0, 755, 753, 1, 0, 0, 0, 756,
		757, 5, 54, 0, 0, 757, 758, 5, 71, 0, 0, 758, 759, 3, 34, 17, 0, 759, 760,
		5, 72, 0, 0, 760, 762, 1, 0, 0, 0, 761, 756, 1, 0, 0, 0, 761, 762, 1, 0,
		0, 0, 762, 81, 1, 0, 0, 0, 763, 765, 3, 76, 38, 0, 764, 766, 3, 84, 42,
		0, 765, 764, 1, 0, 0, 0, 765, 766, 1, 0, 0, 0, 766, 767, 1, 0, 0, 0, 767,
		768, 3, 94, 47, 0, 768, 83, 1, 0, 0, 0, 769, 770, 7, 3, 0, 0, 770, 85,
		1, 0, 0, 0, 771, 772, 6, 43, -1, 0, 772, 773, 5, 47, 0, 0, 773, 792, 3,
		26, 13, 0, 774, 775, 5, 62, 0, 0, 775, 776, 5, 71, 0, 0, 776, 777, 3, 76,
		38, 0, 777, 778, 5, 72, 0, 0, 778, 792, 1, 0, 0, 0, 779, 780, 7, 4, 0,
		0, 780, 792, 3, 86, 43, 19, 781, 782, 5, 44, 0, 0, 782, 792, 3, 76, 38,
		0, 783, 792, 3, 90, 45, 0, 784, 792, 3, 92, 46, 0, 785, 790, 3, 94, 47,
		0, 786, 790, 3, 96, 48, 0, 787, 790, 3, 98, 49, 0, 788, 790, 3, 78, 39,
		0, 789, 785, 1, 0, 0, 0, 789, 786, 1, 0, 0, 0, 789, 787, 1, 0, 0, 0, 789,
		788, 1, 0, 0, 0, 790, 792, 1, 0, 0, 0, 791, 771, 1, 0, 0, 0, 791, 774,
		1, 0, 0, 0, 791, 779, 1, 0, 0, 0, 791, 781, 1, 0, 0, 0, 791, 783, 1, 0,
		0, 0, 791, 784, 1, 0, 0, 0, 791, 789, 1, 0, 0, 0, 792, 877, 1, 0, 0, 0,
		793, 794, 10, 17, 0, 0, 794, 795, 5, 109, 0, 0, 795, 876, 3, 86, 43, 17,
		796, 797, 10, 16, 0, 0, 797, 798, 7, 5, 0, 0, 798, 876, 3, 86, 43, 17,
		799, 800, 10, 15, 0, 0, 800, 801, 7, 6, 0, 0, 801, 876, 3, 86, 43, 16,
		802, 803, 10, 14, 0, 0, 803, 804, 7, 7, 0, 0, 804, 876, 3, 86, 43, 15,
		805, 806, 10, 13, 0, 0, 806, 807, 5, 100, 0, 0, 807, 876, 3, 86, 43, 14,
		808, 809, 10, 12, 0, 0, 809, 810, 5, 99, 0, 0, 810, 876, 3, 86, 43, 13,
		811, 812, 10, 11, 0, 0, 812, 813, 5, 98, 0, 0, 813, 876, 3, 86, 43, 12,
		814, 815, 10, 10, 0, 0, 815, 816, 7, 8, 0, 0, 816, 876, 3, 86, 43, 11,
		817, 818, 10, 9, 0, 0, 818, 819, 7, 9, 0, 0, 819, 876, 3, 86, 43, 10, 820,
		821, 10, 8, 0, 0, 821, 822, 5, 97, 0, 0, 822, 876, 3, 86, 43, 9, 823, 824,
		10, 7, 0, 0, 824, 825, 5, 96, 0, 0, 825, 876, 3, 86, 43, 8, 826, 827, 10,
		6, 0, 0, 827, 828, 5, 80, 0, 0, 828, 829, 3, 86, 43, 0, 829, 830, 5, 77,
		0, 0, 830, 831, 3, 86, 43, 6, 831, 876, 1, 0, 0, 0, 832, 833, 10, 5, 0,
		0, 833, 834, 3, 88, 44, 0, 834, 835, 3, 86, 43, 5, 835, 876, 1, 0, 0, 0,
		836, 837, 10, 26, 0, 0, 837, 839, 5, 73, 0, 0, 838, 840, 3, 86, 43, 0,
		839, 838, 1, 0, 0, 0, 839, 840, 1, 0, 0, 0, 840, 841, 1, 0, 0, 0, 841,
		876, 5, 74, 0, 0, 842, 843, 10, 25, 0, 0, 843, 845, 5, 73, 0, 0, 844, 846,
		3, 86, 43, 0, 845, 844, 1, 0, 0, 0, 845, 846, 1, 0, 0, 0, 846, 847, 1,
		0, 0, 0, 847, 849, 5, 77, 0, 0, 848, 850, 3, 86, 43, 0, 849, 848, 1, 0,
		0, 0, 849, 850, 1, 0, 0, 0, 850, 851, 1, 0, 0, 0, 851, 876, 5, 74, 0, 0,
		852, 853, 10, 24, 0, 0, 853, 856, 5, 79, 0, 0, 854, 857, 3, 94, 47, 0,
		855, 857, 5, 3, 0, 0, 856, 854, 1, 0, 0, 0, 856, 855, 1, 0, 0, 0, 857,
		876, 1, 0, 0, 0, 858, 859, 10, 23, 0, 0, 859, 868, 5, 75, 0, 0, 860, 865,
		3, 24, 12, 0, 861, 862, 5, 95, 0, 0, 862, 864, 3, 24, 12, 0, 863, 861,
		1, 0, 0, 0, 864, 867, 1, 0, 0, 0, 865, 863, 1, 0, 0, 0, 865, 866, 1, 0,
		0, 0, 866, 869, 1, 0, 0, 0, 867, 865, 1, 0, 0, 0, 868, 860, 1, 0, 0, 0,
		868, 869, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 876, 5, 76, 0, 0, 871,
		872, 10, 22, 0, 0, 872, 876, 3, 26, 13, 0, 873, 874, 10, 18, 0, 0, 874,
		876, 7, 10, 0, 0, 875, 793, 1, 0, 0, 0, 875, 796, 1, 0, 0, 0, 875, 799,
		1, 0, 0, 0, 875, 802, 1, 0, 0, 0, 875, 805, 1, 0, 0, 0, 875, 808, 1, 0,
		0, 0, 875, 811, 1, 0, 0, 0, 875, 814, 1, 0, 0, 0, 875, 817, 1, 0, 0, 0,
		875, 820, 1, 0, 0, 0, 875, 823, 1, 0, 0, 0, 875, 826, 1, 0, 0, 0, 875,
		832, 1, 0, 0, 0, 875, 836, 1, 0, 0, 0, 875, 842, 1, 0, 0, 0, 875, 852,
		1, 0, 0, 0, 875, 858, 1, 0, 0, 0, 875, 871, 1, 0, 0, 0, 875, 873, 1, 0,
		0, 0, 876, 879, 1, 0, 0, 0, 877, 875, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0,
		878, 87, 1, 0, 0, 0, 879, 877, 1, 0, 0, 0, 880, 881, 7, 11, 0, 0, 881,
		89, 1, 0, 0, 0, 882, 884, 5, 71, 0, 0, 883, 885, 3, 86, 43, 0, 884, 883,
		1, 0, 0, 0, 884, 885, 1, 0, 0, 0, 885, 892, 1, 0, 0, 0, 886, 888, 5, 95,
		0, 0, 887, 889, 3, 86, 43, 0, 888, 887, 1, 0, 0, 0, 888, 889, 1, 0, 0,
		0, 889, 891, 1, 0, 0, 0, 890, 886, 1, 0, 0, 0, 891, 894, 1, 0, 0, 0, 892,
		890, 1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 895, 1, 0, 0, 0, 894, 892,
		1, 0, 0, 0, 895, 896, 5, 72, 0, 0, 896, 91, 1, 0, 0, 0, 897, 898, 5, 73,
		0, 0, 898, 903, 3, 86, 43, 0, 899, 900, 5, 95, 0, 0, 900, 902, 3, 86, 43,
		0, 901, 899, 1, 0, 0, 0, 902, 905, 1, 0, 0, 0, 903, 901, 1, 0, 0, 0, 903,
		904, 1, 0, 0, 0, 904, 906, 1, 0, 0, 0, 905, 903, 1, 0, 0, 0, 906, 907,
		5, 74, 0, 0, 907, 93, 1, 0, 0, 0, 908, 909, 7, 12, 0, 0, 909, 95, 1, 0,
		0, 0, 910, 916, 3, 102, 51, 0, 911, 916, 3, 108, 54, 0, 912, 916, 3, 100,
		50, 0, 913, 916, 3, 104, 52, 0, 914, 916, 3, 106, 53, 0, 915, 910, 1, 0,
		0, 0, 915, 911, 1, 0, 0, 0, 915, 912, 1, 0, 0, 0, 915, 913, 1, 0, 0, 0,
		915, 914, 1, 0, 0, 0, 916, 97, 1, 0, 0, 0, 917, 918, 3, 108, 54, 0, 918,
		919, 5, 45, 0, 0, 919, 99, 1, 0, 0, 0, 920, 921, 7, 13, 0, 0, 921, 101,
		1, 0, 0, 0, 922, 924, 7, 14, 0, 0, 923, 922, 1, 0, 0, 0, 924, 925, 1, 0,
		0, 0, 925, 923, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 103, 1, 0, 0, 0,
		927, 929, 5, 125, 0, 0, 928, 927, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930,
		928, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 105, 1, 0, 0, 0, 932, 934,
		5, 124, 0, 0, 933, 932, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935, 933, 1,
		0, 0, 0, 935, 936, 1, 0, 0, 0, 936, 107, 1, 0, 0, 0, 937, 938, 7, 15, 0,
		0, 938, 109, 1, 0, 0, 0, 939, 944, 5, 75, 0, 0, 940, 943, 3, 114, 57, 0,
		941, 943, 3, 112, 56, 0, 942, 940, 1, 0, 0, 0, 942, 941, 1, 0, 0, 0, 943,
		946, 1, 0, 0, 0, 944, 942, 1, 0, 0, 0, 944, 945, 1, 0, 0, 0, 945, 947,
		1, 0, 0, 0, 946, 944, 1, 0, 0, 0, 947, 948, 5, 76, 0, 0, 948, 111, 1, 0,
		0, 0, 949, 950, 5, 64, 0, 0, 950, 951, 3, 110, 55, 0, 951, 113, 1, 0, 0,
		0, 952, 966, 3, 110, 55, 0, 953, 966, 3, 116, 58, 0, 954, 966, 3, 118,
		59, 0, 955, 966, 3, 120, 60, 0, 956, 966, 3, 122, 61, 0, 957, 966, 3, 124,
		62, 0, 958, 966, 3, 126, 63, 0, 959, 966, 3, 128, 64, 0, 960, 966, 3, 130,
		65, 0, 961, 966, 3, 134, 67, 0, 962, 966, 3, 136, 68, 0, 963, 966, 3, 138,
		69, 0, 964, 966, 3, 140, 70, 0, 965, 952, 1, 0, 0, 0, 965, 953, 1, 0, 0,
		0, 965, 954, 1, 0, 0, 0, 965, 955, 1, 0, 0, 0, 965, 956, 1, 0, 0, 0, 965,
		957, 1, 0, 0, 0, 965, 958, 1, 0, 0, 0, 965, 959, 1, 0, 0, 0, 965, 960,
		1, 0, 0, 0, 965, 961, 1, 0, 0, 0, 965, 962, 1, 0, 0, 0, 965, 963, 1, 0,
		0, 0, 965, 964, 1, 0, 0, 0, 966, 115, 1, 0, 0, 0, 967, 970, 3, 148, 74,
		0, 968, 970, 3, 150, 75, 0, 969, 967, 1, 0, 0, 0, 969, 968, 1, 0, 0, 0,
		970, 117, 1, 0, 0, 0, 971, 972, 5, 33, 0, 0, 972, 973, 5, 71, 0, 0, 973,
		974, 3, 86, 43, 0, 974, 975, 5, 72, 0, 0, 975, 978, 3, 114, 57, 0, 976,
		977, 5, 18, 0, 0, 977, 979, 3, 114, 57, 0, 978, 976, 1, 0, 0, 0, 978, 979,
		1, 0, 0, 0, 979, 119, 1, 0, 0, 0, 980, 981, 5, 28, 0, 0, 981, 984, 5, 71,
		0, 0, 982, 985, 3, 116, 58, 0, 983, 985, 5, 78, 0, 0, 984, 982, 1, 0, 0,
		0, 984, 983, 1, 0, 0, 0, 985, 988, 1, 0, 0, 0, 986, 989, 3, 150, 75, 0,
		987, 989, 5, 78, 0, 0, 988, 986, 1, 0, 0, 0, 988, 987, 1, 0, 0, 0, 989,
		991, 1, 0, 0, 0, 990, 992, 3, 86, 43, 0, 991, 990, 1, 0, 0, 0, 991, 992,
		1, 0, 0, 0, 992, 993, 1, 0, 0, 0, 993, 994, 5, 72, 0, 0, 994, 995, 3, 114,
		57, 0, 995, 121, 1, 0, 0, 0, 996, 997, 5, 70, 0, 0, 997, 998, 5, 71, 0,
		0, 998, 999, 3, 86, 43, 0, 999, 1000, 5, 72, 0, 0, 1000, 1001, 3, 114,
		57, 0, 1001, 123, 1, 0, 0, 0, 1002, 1003, 5, 17, 0, 0, 1003, 1004, 3, 114,
		57, 0, 1004, 1005, 5, 70, 0, 0, 1005, 1006, 5, 71, 0, 0, 1006, 1007, 3,
		86, 43, 0, 1007, 1008, 5, 72, 0, 0, 1008, 1009, 5, 78, 0, 0, 1009, 125,
		1, 0, 0, 0, 1010, 1011, 5, 14, 0, 0, 1011, 1012, 5, 78, 0, 0, 1012, 127,
		1, 0, 0, 0, 1013, 1014, 5, 8, 0, 0, 1014, 1015, 5, 78, 0, 0, 1015, 129,
		1, 0, 0, 0, 1016, 1017, 5, 61, 0, 0, 1017, 1023, 3, 86, 43, 0, 1018, 1019,
		5, 54, 0, 0, 1019, 1020, 5, 71, 0, 0, 1020, 1021, 3, 34, 17, 0, 1021, 1022,
		5, 72, 0, 0, 1022, 1024, 1, 0, 0, 0, 1023, 1018, 1, 0, 0, 0, 1023, 1024,
		1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 1027, 3, 110, 55, 0, 1026, 1028,
		3, 132, 66, 0, 1027, 1026, 1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029, 1027,
		1, 0, 0, 0, 1029, 1030, 1, 0, 0, 0, 1030, 131, 1, 0, 0, 0, 1031, 1039,
		5, 11, 0, 0, 1032, 1034, 3, 94, 47, 0, 1033, 1032, 1, 0, 0, 0, 1033, 1034,
		1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1036, 5, 71, 0, 0, 1036, 1037,
		3, 34, 17, 0, 1037, 1038, 5, 72, 0, 0, 1038, 1040, 1, 0, 0, 0, 1039, 1033,
		1, 0, 0, 0, 1039, 1040, 1, 0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1042,
		3, 110, 55, 0, 1042, 133, 1, 0, 0, 0, 1043, 1045, 5, 53, 0, 0, 1044, 1046,
		3, 86, 43, 0, 1045, 1044, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046, 1047,
		1, 0, 0, 0, 1047, 1048, 5, 78, 0, 0, 1048, 135, 1, 0, 0, 0, 1049, 1050,
		5, 19, 0, 0, 1050, 1051, 3, 86, 43, 0, 1051, 1052, 3, 26, 13, 0, 1052,
		1053, 5, 78, 0, 0, 1053, 137, 1, 0, 0, 0, 1054, 1055, 5, 55, 0, 0, 1055,
		1056, 3, 86, 43, 0, 1056, 1057, 3, 26, 13, 0, 1057, 1058, 5, 78, 0, 0,
		1058, 139, 1, 0, 0, 0, 1059, 1061, 5, 6, 0, 0, 1060, 1062, 5, 134, 0, 0,
		1061, 1060, 1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1064, 1, 0, 0, 0,
		1063, 1065, 3, 142, 71, 0, 1064, 1063, 1, 0, 0, 0, 1064, 1065, 1, 0, 0,
		0, 1065, 1066, 1, 0, 0, 0, 1066, 1070, 5, 135, 0, 0, 1067, 1069, 3, 156,
		78, 0, 1068, 1067, 1, 0, 0, 0, 1069, 1072, 1, 0, 0, 0, 1070, 1068, 1, 0,
		0, 0, 1070, 1071, 1, 0, 0, 0, 1071, 1073, 1, 0, 0, 0, 1072, 1070, 1, 0,
		0, 0, 1073, 1074, 5, 158, 0, 0, 1074, 141, 1, 0, 0, 0, 1075, 1076, 5, 137,
		0, 0, 1076, 1081, 5, 136, 0, 0, 1077, 1078, 5, 139, 0, 0, 1078, 1080, 5,
		136, 0, 0, 1079, 1077, 1, 0, 0, 0, 1080, 1083, 1, 0, 0, 0, 1081, 1079,
		1, 0, 0, 0, 1081, 1082, 1, 0, 0, 0, 1082, 1084, 1, 0, 0, 0, 1083, 1081,
		1, 0, 0, 0, 1084, 1085, 5, 138, 0, 0, 1085, 143, 1, 0, 0, 0, 1086, 1091,
		3, 82, 41, 0, 1087, 1088, 5, 95, 0, 0, 1088, 1090, 3, 82, 41, 0, 1089,
		1087, 1, 0, 0, 0, 1090, 1093, 1, 0, 0, 0, 1091, 1089, 1, 0, 0, 0, 1091,
		1092, 1, 0, 0, 0, 1092, 145, 1, 0, 0, 0, 1093, 1091, 1, 0, 0, 0, 1094,
		1098, 5, 71, 0, 0, 1095, 1097, 5, 95, 0, 0, 1096, 1095, 1, 0, 0, 0, 1097,
		1100, 1, 0, 0, 0, 1098, 1096, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099,
		1101, 1, 0, 0, 0, 1100, 1098, 1, 0, 0, 0, 1101, 1102, 3, 82, 41, 0, 1102,
		1109, 1, 0, 0, 0, 1103, 1105, 5, 95, 0, 0, 1104, 1106, 3, 82, 41, 0, 1105,
		1104, 1, 0, 0, 0, 1105, 1106, 1, 0, 0, 0, 1106, 1108, 1, 0, 0, 0, 1107,
		1103, 1, 0, 0, 0, 1108, 1111, 1, 0, 0, 0, 1109, 1107, 1, 0, 0, 0, 1109,
		1110, 1, 0, 0, 0, 1110, 1112, 1, 0, 0, 0, 1111, 1109, 1, 0, 0, 0, 1112,
		1113, 5, 72, 0, 0, 1113, 147, 1, 0, 0, 0, 1114, 1117, 3, 82, 41, 0, 1115,
		1116, 5, 83, 0, 0, 1116, 1118, 3, 86, 43, 0, 1117, 1115, 1, 0, 0, 0, 1117,
		1118, 1, 0, 0, 0, 1118, 1124, 1, 0, 0, 0, 1119, 1120, 3, 146, 73, 0, 1120,
		1121, 5, 83, 0, 0, 1121, 1122, 3, 86, 43, 0, 1122, 1124, 1, 0, 0, 0, 1123,
		1114, 1, 0, 0, 0, 1123, 1119, 1, 0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125,
		1126, 5, 78, 0, 0, 1126, 149, 1, 0, 0, 0, 1127, 1128, 3, 86, 43, 0, 1128,
		1129, 5, 78, 0, 0, 1129, 151, 1, 0, 0, 0, 1130, 1131, 5, 41, 0, 0, 1131,
		1132, 5, 71, 0, 0, 1132, 1134, 3, 154, 77, 0, 1133, 1135, 3, 94, 47, 0,
		1134, 1133, 1, 0, 0, 0, 1134, 1135, 1, 0, 0, 0, 1135, 1136, 1, 0, 0, 0,
		1136, 1137, 5, 81, 0, 0, 1137, 1139, 3, 76, 38, 0, 1138, 1140, 3, 94, 47,
		0, 1139, 1138, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 1141, 1, 0, 0,
		0, 1141, 1142, 5, 72, 0, 0, 1142, 153, 1, 0, 0, 0, 1143, 1146, 3, 78, 39,
		0, 1144, 1146, 3, 28, 14, 0, 1145, 1143, 1, 0, 0, 0, 1145, 1144, 1, 0,
		0, 0, 1146, 155, 1, 0, 0, 0, 1147, 1159, 3, 158, 79, 0, 1148, 1159, 3,
		160, 80, 0, 1149, 1159, 3, 162, 81, 0, 1150, 1159, 3, 176, 88, 0, 1151,
		1159, 3, 164, 82, 0, 1152, 1159, 3, 166, 83, 0, 1153, 1159, 3, 170, 85,
		0, 1154, 1159, 5, 151, 0, 0, 1155, 1159, 5, 143, 0, 0, 1156, 1159, 5, 145,
		0, 0, 1157, 1159, 3, 172, 86, 0, 1158, 1147, 1, 0, 0, 0, 1158, 1148, 1,
		0, 0, 0, 1158, 1149, 1, 0, 0, 0, 1158, 1150, 1, 0, 0, 0, 1158, 1151, 1,
		0, 0, 0, 1158, 1152, 1, 0, 0, 0, 1158, 1153, 1, 0, 0, 0, 1158, 1154, 1,
		0, 0, 0, 1158, 1155, 1, 0, 0, 0, 1158, 1156, 1, 0, 0, 0, 1158, 1157, 1,
		0, 0, 0, 1159, 157, 1, 0, 0, 0, 1160, 1164, 5, 157, 0, 0, 1161, 1163, 3,
		156, 78, 0, 1162, 1161, 1, 0, 0, 0, 1163, 1166, 1, 0, 0, 0, 1164, 1162,
		1, 0, 0, 0, 1164, 1165, 1, 0, 0, 0, 1165, 1167, 1, 0, 0, 0, 1166, 1164,
		1, 0, 0, 0, 1167, 1168, 5, 158, 0, 0, 1168, 159, 1, 0, 0, 0, 1169, 1170,
		5, 152, 0, 0, 1170, 1173, 5, 165, 0, 0, 1171, 1172, 5, 161, 0, 0, 1172,
		1174, 3, 182, 91, 0, 1173, 1171, 1, 0, 0, 0, 1173, 1174, 1, 0, 0, 0, 1174,
		1189, 1, 0, 0, 0, 1175, 1176, 5, 152, 0, 0, 1176, 1181, 5, 165, 0, 0, 1177,
		1178, 5, 163, 0, 0, 1178, 1180, 5, 165, 0, 0, 1179, 1177, 1, 0, 0, 0, 1180,
		1183, 1, 0, 0, 0, 1181, 1179, 1, 0, 0, 0, 1181, 1182, 1, 0, 0, 0, 1182,
		1186, 1, 0, 0, 0, 1183, 1181, 1, 0, 0, 0, 1184, 1185, 5, 161, 0, 0, 1185,
		1187, 3, 176, 88, 0, 1186, 1184, 1, 0, 0, 0, 1186, 1187, 1, 0, 0, 0, 1187,
		1189, 1, 0, 0, 0, 1188, 1169, 1, 0, 0, 0, 1188, 1175, 1, 0, 0, 0, 1189,
		161, 1, 0, 0, 0, 1190, 1191, 3, 174, 87, 0, 1191, 1192, 5, 161, 0, 0, 1192,
		1193, 3, 182, 91, 0, 1193, 1205, 1, 0, 0, 0, 1194, 1197, 3, 174, 87, 0,
		1195, 1196, 5, 163, 0, 0, 1196, 1198, 3, 174, 87, 0, 1197, 1195, 1, 0,
		0, 0, 1198, 1199, 1, 0, 0, 0, 1199, 1197, 1, 0, 0, 0, 1199, 1200, 1, 0,
		0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 1202, 5, 161, 0, 0, 1202, 1203, 3,
		176, 88, 0, 1203, 1205, 1, 0, 0, 0, 1204, 1190, 1, 0, 0, 0, 1204, 1194,
		1, 0, 0, 0, 1205, 163, 1, 0, 0, 0, 1206, 1207, 5, 150, 0, 0, 1207, 1208,
		3, 182, 91, 0, 1208, 1209, 3, 158, 79, 0, 1209, 165, 1, 0, 0, 0, 1210,
		1211, 5, 148, 0, 0, 1211, 1212, 3, 158, 79, 0, 1212, 1213, 3, 182, 91,
		0, 1213, 1214, 3, 158, 79, 0, 1214, 1215, 3, 158, 79, 0, 1215, 167, 1,
		0, 0, 0, 1216, 1217, 5, 144, 0, 0, 1217, 1218, 3, 180, 90, 0, 1218, 1219,
		3, 158, 79, 0, 1219, 169, 1, 0, 0, 0, 1220, 1221, 5, 153, 0, 0, 1221, 1233,
		3, 182, 91, 0, 1222, 1224, 3, 168, 84, 0, 1223, 1222, 1, 0, 0, 0, 1224,
		1225, 1, 0, 0, 0, 1225, 1223, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226,
		1229, 1, 0, 0, 0, 1227, 1228, 5, 146, 0, 0, 1228, 1230, 3, 158, 79, 0,
		1229, 1227, 1, 0, 0, 0, 1229, 1230, 1, 0, 0, 0, 1230, 1234, 1, 0, 0, 0,
		1231, 1232, 5, 146, 0, 0, 1232, 1234, 3, 158, 79, 0, 1233, 1223, 1, 0,
		0, 0, 1233, 1231, 1, 0, 0, 0, 1234, 171, 1, 0, 0, 0, 1235, 1236, 5, 149,
		0, 0, 1236, 1237, 5, 165, 0, 0, 1237, 1246, 5, 159, 0, 0, 1238, 1243, 5,
		165, 0, 0, 1239, 1240, 5, 163, 0, 0, 1240, 1242, 5, 165, 0, 0, 1241, 1239,
		1, 0, 0, 0, 1242, 1245, 1, 0, 0, 0, 1243, 1241, 1, 0, 0, 0, 1243, 1244,
		1, 0, 0, 0, 1244, 1247, 1, 0, 0, 0, 1245, 1243, 1, 0, 0, 0, 1246, 1238,
		1, 0, 0, 0, 1246, 1247, 1, 0, 0, 0, 1247, 1248, 1, 0, 0, 0, 1248, 1258,
		5, 160, 0, 0, 1249, 1250, 5, 164, 0, 0, 1250, 1255, 5, 165, 0, 0, 1251,
		1252, 5, 163, 0, 0, 1252, 1254, 5, 165, 0, 0, 1253, 1251, 1, 0, 0, 0, 1254,
		1257, 1, 0, 0, 0, 1255, 1253, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256,
		1259, 1, 0, 0, 0, 1257, 1255, 1, 0, 0, 0, 1258, 1249, 1, 0, 0, 0, 1258,
		1259, 1, 0, 0, 0, 1259, 1260, 1, 0, 0, 0, 1260, 1261, 3, 158, 79, 0, 1261,
		173, 1, 0, 0, 0, 1262, 1267, 5, 165, 0, 0, 1263, 1264, 5, 162, 0, 0, 1264,
		1266, 7, 16, 0, 0, 1265, 1263, 1, 0, 0, 0, 1266, 1269, 1, 0, 0, 0, 1267,
		1265, 1, 0, 0, 0, 1267, 1268, 1, 0, 0, 0, 1268, 175, 1, 0, 0, 0, 1269,
		1267, 1, 0, 0, 0, 1270, 1271, 7, 16, 0, 0, 1271, 1280, 5, 159, 0, 0, 1272,
		1277, 3, 182, 91, 0, 1273, 1274, 5, 163, 0, 0, 1274, 1276, 3, 182, 91,
		0, 1275, 1273, 1, 0, 0, 0, 1276, 1279, 1, 0, 0, 0, 1277, 1275, 1, 0, 0,
		0, 1277, 1278, 1, 0, 0, 0, 1278, 1281, 1, 0, 0, 0, 1279, 1277, 1, 0, 0,
		0, 1280, 1272, 1, 0, 0, 0, 1280, 1281, 1, 0, 0, 0, 1281, 1282, 1, 0, 0,
		0, 1282, 1283, 5, 160, 0, 0, 1283, 177, 1, 0, 0, 0, 1284, 1285, 7, 17,
		0, 0, 1285, 179, 1, 0, 0, 0, 1286, 1292, 5, 167, 0, 0, 1287, 1292, 5, 168,
		0, 0, 1288, 1292, 5, 166, 0, 0, 1289, 1292, 3, 178, 89, 0, 1290, 1292,
		5, 169, 0, 0, 1291, 1286, 1, 0, 0, 0, 1291, 1287, 1, 0, 0, 0, 1291, 1288,
		1, 0, 0, 0, 1291, 1289, 1, 0, 0, 0, 1291, 1290, 1, 0, 0, 0, 1292, 181,
		1, 0, 0, 0, 1293, 1297, 3, 174, 87, 0, 1294, 1297, 3, 176, 88, 0, 1295,
		1297, 3, 180, 90, 0, 1296, 1293, 1, 0, 0, 0, 1296, 1294, 1, 0, 0, 0, 1296,
		1295, 1, 0, 0, 0, 1297, 183, 1, 0, 0, 0, 142, 196, 198, 207, 215, 227,
		234, 244, 250, 255, 261, 269, 275, 286, 297, 302, 316, 328, 331, 339, 342,
		345, 354, 359, 368, 373, 376, 381, 394, 396, 410, 415, 421, 425, 444, 446,
		454, 458, 464, 467, 476, 478, 483, 490, 508, 510, 520, 524, 543, 545, 550,
		558, 574, 605, 607, 613, 626, 629, 639, 642, 646, 652, 662, 665, 678, 684,
		688, 693, 698, 701, 710, 715, 720, 735, 740, 751, 753, 761, 765, 789, 791,
		839, 845, 849, 856, 865, 868, 875, 877, 884, 888, 892, 903, 915, 925, 930,
		935, 942, 944, 965, 969, 978, 984, 988, 991, 1023, 1029, 1033, 1039, 1045,
		1061, 1064, 1070, 1081, 1091, 1098, 1105, 1109, 1117, 1123, 1134, 1139,
		1145, 1158, 1164, 1173, 1181, 1186, 1188, 1199, 1204, 1225, 1229, 1233,
		1243, 1246, 1255, 1258, 1267, 1277, 1280, 1291, 1296,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SolidityParserInit initializes any static state used to implement SolidityParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSolidityParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SolidityParserInit() {
	staticData := &SolidityParserParserStaticData
	staticData.once.Do(solidityparserParserInit)
}

// NewSolidityParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSolidityParser(input antlr.TokenStream) *SolidityParser {
	SolidityParserInit()
	this := new(SolidityParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SolidityParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "SolidityParser.g4"

	return this
}

// SolidityParser tokens.
const (
	SolidityParserEOF                               = antlr.TokenEOF
	SolidityParserReservedKeywords                  = 1
	SolidityParserAbstract                          = 2
	SolidityParserAddress                           = 3
	SolidityParserAnonymous                         = 4
	SolidityParserAs                                = 5
	SolidityParserAssembly                          = 6
	SolidityParserBool                              = 7
	SolidityParserBreak                             = 8
	SolidityParserBytes                             = 9
	SolidityParserCalldata                          = 10
	SolidityParserCatch                             = 11
	SolidityParserConstant                          = 12
	SolidityParserConstructor                       = 13
	SolidityParserContinue                          = 14
	SolidityParserContract                          = 15
	SolidityParserDelete                            = 16
	SolidityParserDo                                = 17
	SolidityParserElse                              = 18
	SolidityParserEmit                              = 19
	SolidityParserEnum                              = 20
	SolidityParserError                             = 21
	SolidityParserEvent                             = 22
	SolidityParserExternal                          = 23
	SolidityParserFallback                          = 24
	SolidityParserFalse                             = 25
	SolidityParserFixed                             = 26
	SolidityParserFixedBytes                        = 27
	SolidityParserFor                               = 28
	SolidityParserFrom                              = 29
	SolidityParserFunction                          = 30
	SolidityParserGlobal                            = 31
	SolidityParserHex                               = 32
	SolidityParserIf                                = 33
	SolidityParserImmutable                         = 34
	SolidityParserImport                            = 35
	SolidityParserIndexed                           = 36
	SolidityParserInterface                         = 37
	SolidityParserInternal                          = 38
	SolidityParserIs                                = 39
	SolidityParserLibrary                           = 40
	SolidityParserMapping                           = 41
	SolidityParserMemory                            = 42
	SolidityParserModifier                          = 43
	SolidityParserNew                               = 44
	SolidityParserSubDenomination                   = 45
	SolidityParserOverride                          = 46
	SolidityParserPayable                           = 47
	SolidityParserPragma                            = 48
	SolidityParserPrivate                           = 49
	SolidityParserPublic                            = 50
	SolidityParserPure                              = 51
	SolidityParserReceive                           = 52
	SolidityParserReturn                            = 53
	SolidityParserReturns                           = 54
	SolidityParserRevert                            = 55
	SolidityParserSignedIntegerType                 = 56
	SolidityParserStorage                           = 57
	SolidityParserString_                           = 58
	SolidityParserStruct                            = 59
	SolidityParserTrue                              = 60
	SolidityParserTry                               = 61
	SolidityParserType                              = 62
	SolidityParserUfixed                            = 63
	SolidityParserUnchecked                         = 64
	SolidityParserUnicode                           = 65
	SolidityParserUnsignedIntegerType               = 66
	SolidityParserUsing                             = 67
	SolidityParserView                              = 68
	SolidityParserVirtual                           = 69
	SolidityParserWhile                             = 70
	SolidityParserLParen                            = 71
	SolidityParserRParen                            = 72
	SolidityParserLBrack                            = 73
	SolidityParserRBrack                            = 74
	SolidityParserLBrace                            = 75
	SolidityParserRBrace                            = 76
	SolidityParserColon                             = 77
	SolidityParserSemicolon                         = 78
	SolidityParserPeriod                            = 79
	SolidityParserConditional                       = 80
	SolidityParserDoubleArrow                       = 81
	SolidityParserRightArrow                        = 82
	SolidityParserAssign                            = 83
	SolidityParserAssignBitOr                       = 84
	SolidityParserAssignBitXor                      = 85
	SolidityParserAssignBitAnd                      = 86
	SolidityParserAssignShl                         = 87
	SolidityParserAssignSar                         = 88
	SolidityParserAssignShr                         = 89
	SolidityParserAssignAdd                         = 90
	SolidityParserAssignSub                         = 91
	SolidityParserAssignMul                         = 92
	SolidityParserAssignDiv                         = 93
	SolidityParserAssignMod                         = 94
	SolidityParserComma                             = 95
	SolidityParserOr                                = 96
	SolidityParserAnd                               = 97
	SolidityParserBitOr                             = 98
	SolidityParserBitXor                            = 99
	SolidityParserBitAnd                            = 100
	SolidityParserShl                               = 101
	SolidityParserSar                               = 102
	SolidityParserShr                               = 103
	SolidityParserAdd                               = 104
	SolidityParserSub                               = 105
	SolidityParserMul                               = 106
	SolidityParserDiv                               = 107
	SolidityParserMod                               = 108
	SolidityParserExp                               = 109
	SolidityParserEqual                             = 110
	SolidityParserNotEqual                          = 111
	SolidityParserLessThan                          = 112
	SolidityParserGreaterThan                       = 113
	SolidityParserLessThanOrEqual                   = 114
	SolidityParserGreaterThanOrEqual                = 115
	SolidityParserNot                               = 116
	SolidityParserBitNot                            = 117
	SolidityParserInc                               = 118
	SolidityParserDec                               = 119
	SolidityParserDoubleQuote                       = 120
	SolidityParserSingleQuote                       = 121
	SolidityParserNonEmptyStringLiteral             = 122
	SolidityParserEmptyStringLiteral                = 123
	SolidityParserUnicodeStringLiteral              = 124
	SolidityParserHexString                         = 125
	SolidityParserHexNumber                         = 126
	SolidityParserOctalNumber                       = 127
	SolidityParserDecimalNumber                     = 128
	SolidityParserDecimalNumberFollowedByIdentifier = 129
	SolidityParserIdentifier                        = 130
	SolidityParserWS                                = 131
	SolidityParserCOMMENT                           = 132
	SolidityParserLINE_COMMENT                      = 133
	SolidityParserAssemblyDialect                   = 134
	SolidityParserAssemblyLBrace                    = 135
	SolidityParserAssemblyFlagString                = 136
	SolidityParserAssemblyBlockLParen               = 137
	SolidityParserAssemblyBlockRParen               = 138
	SolidityParserAssemblyBlockComma                = 139
	SolidityParserAssemblyBlockWS                   = 140
	SolidityParserAssemblyBlockCOMMENT              = 141
	SolidityParserAssemblyBlockLINE_COMMENT         = 142
	SolidityParserYulBreak                          = 143
	SolidityParserYulCase                           = 144
	SolidityParserYulContinue                       = 145
	SolidityParserYulDefault                        = 146
	SolidityParserYulFalse                          = 147
	SolidityParserYulFor                            = 148
	SolidityParserYulFunction                       = 149
	SolidityParserYulIf                             = 150
	SolidityParserYulLeave                          = 151
	SolidityParserYulLet                            = 152
	SolidityParserYulSwitch                         = 153
	SolidityParserYulTrue                           = 154
	SolidityParserYulHex                            = 155
	SolidityParserYulEVMBuiltin                     = 156
	SolidityParserYulLBrace                         = 157
	SolidityParserYulRBrace                         = 158
	SolidityParserYulLParen                         = 159
	SolidityParserYulRParen                         = 160
	SolidityParserYulAssign                         = 161
	SolidityParserYulPeriod                         = 162
	SolidityParserYulComma                          = 163
	SolidityParserYulArrow                          = 164
	SolidityParserYulIdentifier                     = 165
	SolidityParserYulHexNumber                      = 166
	SolidityParserYulDecimalNumber                  = 167
	SolidityParserYulStringLiteral                  = 168
	SolidityParserYulHexStringLiteral               = 169
	SolidityParserYulWS                             = 170
	SolidityParserYulCOMMENT                        = 171
	SolidityParserYulLINE_COMMENT                   = 172
	SolidityParserPragmaToken                       = 173
	SolidityParserPragmaSemicolon                   = 174
	SolidityParserPragmaWS                          = 175
	SolidityParserPragmaCOMMENT                     = 176
	SolidityParserPragmaLINE_COMMENT                = 177
)

// SolidityParser rules.
const (
	SolidityParserRULE_sourceUnit                     = 0
	SolidityParserRULE_pragmaDirective                = 1
	SolidityParserRULE_importDirective                = 2
	SolidityParserRULE_importAliases                  = 3
	SolidityParserRULE_path                           = 4
	SolidityParserRULE_symbolAliases                  = 5
	SolidityParserRULE_contractDefinition             = 6
	SolidityParserRULE_interfaceDefinition            = 7
	SolidityParserRULE_libraryDefinition              = 8
	SolidityParserRULE_inheritanceSpecifierList       = 9
	SolidityParserRULE_inheritanceSpecifier           = 10
	SolidityParserRULE_contractBodyElement            = 11
	SolidityParserRULE_namedArgument                  = 12
	SolidityParserRULE_callArgumentList               = 13
	SolidityParserRULE_identifierPath                 = 14
	SolidityParserRULE_modifierInvocation             = 15
	SolidityParserRULE_visibility                     = 16
	SolidityParserRULE_parameterList                  = 17
	SolidityParserRULE_parameterDeclaration           = 18
	SolidityParserRULE_constructorDefinition          = 19
	SolidityParserRULE_stateMutability                = 20
	SolidityParserRULE_overrideSpecifier              = 21
	SolidityParserRULE_functionDefinition             = 22
	SolidityParserRULE_modifierDefinition             = 23
	SolidityParserRULE_fallbackFunctionDefinition     = 24
	SolidityParserRULE_receiveFunctionDefinition      = 25
	SolidityParserRULE_structDefinition               = 26
	SolidityParserRULE_structMember                   = 27
	SolidityParserRULE_enumDefinition                 = 28
	SolidityParserRULE_userDefinedValueTypeDefinition = 29
	SolidityParserRULE_stateVariableDeclaration       = 30
	SolidityParserRULE_constantVariableDeclaration    = 31
	SolidityParserRULE_eventParameter                 = 32
	SolidityParserRULE_eventDefinition                = 33
	SolidityParserRULE_errorParameter                 = 34
	SolidityParserRULE_errorDefinition                = 35
	SolidityParserRULE_userDefinableOperator          = 36
	SolidityParserRULE_usingDirective                 = 37
	SolidityParserRULE_typeName                       = 38
	SolidityParserRULE_elementaryTypeName             = 39
	SolidityParserRULE_functionTypeName               = 40
	SolidityParserRULE_variableDeclaration            = 41
	SolidityParserRULE_dataLocation                   = 42
	SolidityParserRULE_expression                     = 43
	SolidityParserRULE_assignOp                       = 44
	SolidityParserRULE_tupleExpression                = 45
	SolidityParserRULE_inlineArrayExpression          = 46
	SolidityParserRULE_identifier                     = 47
	SolidityParserRULE_literal                        = 48
	SolidityParserRULE_literalWithSubDenomination     = 49
	SolidityParserRULE_booleanLiteral                 = 50
	SolidityParserRULE_stringLiteral                  = 51
	SolidityParserRULE_hexStringLiteral               = 52
	SolidityParserRULE_unicodeStringLiteral           = 53
	SolidityParserRULE_numberLiteral                  = 54
	SolidityParserRULE_block                          = 55
	SolidityParserRULE_uncheckedBlock                 = 56
	SolidityParserRULE_statement                      = 57
	SolidityParserRULE_simpleStatement                = 58
	SolidityParserRULE_ifStatement                    = 59
	SolidityParserRULE_forStatement                   = 60
	SolidityParserRULE_whileStatement                 = 61
	SolidityParserRULE_doWhileStatement               = 62
	SolidityParserRULE_continueStatement              = 63
	SolidityParserRULE_breakStatement                 = 64
	SolidityParserRULE_tryStatement                   = 65
	SolidityParserRULE_catchClause                    = 66
	SolidityParserRULE_returnStatement                = 67
	SolidityParserRULE_emitStatement                  = 68
	SolidityParserRULE_revertStatement                = 69
	SolidityParserRULE_assemblyStatement              = 70
	SolidityParserRULE_assemblyFlags                  = 71
	SolidityParserRULE_variableDeclarationList        = 72
	SolidityParserRULE_variableDeclarationTuple       = 73
	SolidityParserRULE_variableDeclarationStatement   = 74
	SolidityParserRULE_expressionStatement            = 75
	SolidityParserRULE_mappingType                    = 76
	SolidityParserRULE_mappingKeyType                 = 77
	SolidityParserRULE_yulStatement                   = 78
	SolidityParserRULE_yulBlock                       = 79
	SolidityParserRULE_yulVariableDeclaration         = 80
	SolidityParserRULE_yulAssignment                  = 81
	SolidityParserRULE_yulIfStatement                 = 82
	SolidityParserRULE_yulForStatement                = 83
	SolidityParserRULE_yulSwitchCase                  = 84
	SolidityParserRULE_yulSwitchStatement             = 85
	SolidityParserRULE_yulFunctionDefinition          = 86
	SolidityParserRULE_yulPath                        = 87
	SolidityParserRULE_yulFunctionCall                = 88
	SolidityParserRULE_yulBoolean                     = 89
	SolidityParserRULE_yulLiteral                     = 90
	SolidityParserRULE_yulExpression                  = 91
)

// ISourceUnitContext is an interface to support dynamic dispatch.
type ISourceUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllPragmaDirective() []IPragmaDirectiveContext
	PragmaDirective(i int) IPragmaDirectiveContext
	AllImportDirective() []IImportDirectiveContext
	ImportDirective(i int) IImportDirectiveContext
	AllUsingDirective() []IUsingDirectiveContext
	UsingDirective(i int) IUsingDirectiveContext
	AllContractDefinition() []IContractDefinitionContext
	ContractDefinition(i int) IContractDefinitionContext
	AllInterfaceDefinition() []IInterfaceDefinitionContext
	InterfaceDefinition(i int) IInterfaceDefinitionContext
	AllLibraryDefinition() []ILibraryDefinitionContext
	LibraryDefinition(i int) ILibraryDefinitionContext
	AllFunctionDefinition() []IFunctionDefinitionContext
	FunctionDefinition(i int) IFunctionDefinitionContext
	AllConstantVariableDeclaration() []IConstantVariableDeclarationContext
	ConstantVariableDeclaration(i int) IConstantVariableDeclarationContext
	AllStructDefinition() []IStructDefinitionContext
	StructDefinition(i int) IStructDefinitionContext
	AllEnumDefinition() []IEnumDefinitionContext
	EnumDefinition(i int) IEnumDefinitionContext
	AllUserDefinedValueTypeDefinition() []IUserDefinedValueTypeDefinitionContext
	UserDefinedValueTypeDefinition(i int) IUserDefinedValueTypeDefinitionContext
	AllErrorDefinition() []IErrorDefinitionContext
	ErrorDefinition(i int) IErrorDefinitionContext

	// IsSourceUnitContext differentiates from other interfaces.
	IsSourceUnitContext()
}

type SourceUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceUnitContext() *SourceUnitContext {
	var p = new(SourceUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_sourceUnit
	return p
}

func InitEmptySourceUnitContext(p *SourceUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_sourceUnit
}

func (*SourceUnitContext) IsSourceUnitContext() {}

func NewSourceUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceUnitContext {
	var p = new(SourceUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_sourceUnit

	return p
}

func (s *SourceUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(SolidityParserEOF, 0)
}

func (s *SourceUnitContext) AllPragmaDirective() []IPragmaDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPragmaDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IPragmaDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPragmaDirectiveContext); ok {
			tst[i] = t.(IPragmaDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) PragmaDirective(i int) IPragmaDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaDirectiveContext)
}

func (s *SourceUnitContext) AllImportDirective() []IImportDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IImportDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDirectiveContext); ok {
			tst[i] = t.(IImportDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ImportDirective(i int) IImportDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDirectiveContext)
}

func (s *SourceUnitContext) AllUsingDirective() []IUsingDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUsingDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IUsingDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUsingDirectiveContext); ok {
			tst[i] = t.(IUsingDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) UsingDirective(i int) IUsingDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingDirectiveContext)
}

func (s *SourceUnitContext) AllContractDefinition() []IContractDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IContractDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractDefinitionContext); ok {
			tst[i] = t.(IContractDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ContractDefinition(i int) IContractDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractDefinitionContext)
}

func (s *SourceUnitContext) AllInterfaceDefinition() []IInterfaceDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceDefinitionContext); ok {
			tst[i] = t.(IInterfaceDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) InterfaceDefinition(i int) IInterfaceDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDefinitionContext)
}

func (s *SourceUnitContext) AllLibraryDefinition() []ILibraryDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILibraryDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ILibraryDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILibraryDefinitionContext); ok {
			tst[i] = t.(ILibraryDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) LibraryDefinition(i int) ILibraryDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryDefinitionContext)
}

func (s *SourceUnitContext) AllFunctionDefinition() []IFunctionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDefinitionContext); ok {
			tst[i] = t.(IFunctionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) FunctionDefinition(i int) IFunctionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *SourceUnitContext) AllConstantVariableDeclaration() []IConstantVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IConstantVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantVariableDeclarationContext); ok {
			tst[i] = t.(IConstantVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ConstantVariableDeclaration(i int) IConstantVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantVariableDeclarationContext)
}

func (s *SourceUnitContext) AllStructDefinition() []IStructDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IStructDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructDefinitionContext); ok {
			tst[i] = t.(IStructDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) StructDefinition(i int) IStructDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDefinitionContext)
}

func (s *SourceUnitContext) AllEnumDefinition() []IEnumDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IEnumDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumDefinitionContext); ok {
			tst[i] = t.(IEnumDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) EnumDefinition(i int) IEnumDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDefinitionContext)
}

func (s *SourceUnitContext) AllUserDefinedValueTypeDefinition() []IUserDefinedValueTypeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserDefinedValueTypeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IUserDefinedValueTypeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserDefinedValueTypeDefinitionContext); ok {
			tst[i] = t.(IUserDefinedValueTypeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) UserDefinedValueTypeDefinition(i int) IUserDefinedValueTypeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedValueTypeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedValueTypeDefinitionContext)
}

func (s *SourceUnitContext) AllErrorDefinition() []IErrorDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IErrorDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorDefinitionContext); ok {
			tst[i] = t.(IErrorDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ErrorDefinition(i int) IErrorDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorDefinitionContext)
}

func (s *SourceUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterSourceUnit(s)
	}
}

func (s *SourceUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitSourceUnit(s)
	}
}

func (p *SolidityParser) SourceUnit() (localctx ISourceUnitContext) {
	localctx = NewSourceUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SolidityParserRULE_sourceUnit)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(196)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(184)
					p.PragmaDirective()
				}

			case 2:
				{
					p.SetState(185)
					p.ImportDirective()
				}

			case 3:
				{
					p.SetState(186)
					p.UsingDirective()
				}

			case 4:
				{
					p.SetState(187)
					p.ContractDefinition()
				}

			case 5:
				{
					p.SetState(188)
					p.InterfaceDefinition()
				}

			case 6:
				{
					p.SetState(189)
					p.LibraryDefinition()
				}

			case 7:
				{
					p.SetState(190)
					p.FunctionDefinition()
				}

			case 8:
				{
					p.SetState(191)
					p.ConstantVariableDeclaration()
				}

			case 9:
				{
					p.SetState(192)
					p.StructDefinition()
				}

			case 10:
				{
					p.SetState(193)
					p.EnumDefinition()
				}

			case 11:
				{
					p.SetState(194)
					p.UserDefinedValueTypeDefinition()
				}

			case 12:
				{
					p.SetState(195)
					p.ErrorDefinition()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(201)
		p.Match(SolidityParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPragmaDirectiveContext is an interface to support dynamic dispatch.
type IPragmaDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pragma() antlr.TerminalNode
	PragmaSemicolon() antlr.TerminalNode
	AllPragmaToken() []antlr.TerminalNode
	PragmaToken(i int) antlr.TerminalNode

	// IsPragmaDirectiveContext differentiates from other interfaces.
	IsPragmaDirectiveContext()
}

type PragmaDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaDirectiveContext() *PragmaDirectiveContext {
	var p = new(PragmaDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaDirective
	return p
}

func InitEmptyPragmaDirectiveContext(p *PragmaDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaDirective
}

func (*PragmaDirectiveContext) IsPragmaDirectiveContext() {}

func NewPragmaDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaDirectiveContext {
	var p = new(PragmaDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaDirective

	return p
}

func (s *PragmaDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaDirectiveContext) Pragma() antlr.TerminalNode {
	return s.GetToken(SolidityParserPragma, 0)
}

func (s *PragmaDirectiveContext) PragmaSemicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserPragmaSemicolon, 0)
}

func (s *PragmaDirectiveContext) AllPragmaToken() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPragmaToken)
}

func (s *PragmaDirectiveContext) PragmaToken(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPragmaToken, i)
}

func (s *PragmaDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PragmaDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterPragmaDirective(s)
	}
}

func (s *PragmaDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitPragmaDirective(s)
	}
}

func (p *SolidityParser) PragmaDirective() (localctx IPragmaDirectiveContext) {
	localctx = NewPragmaDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SolidityParserRULE_pragmaDirective)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(203)
		p.Match(SolidityParserPragma)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SolidityParserPragmaToken {
		{
			p.SetState(204)
			p.Match(SolidityParserPragmaToken)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(209)
		p.Match(SolidityParserPragmaSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDirectiveContext is an interface to support dynamic dispatch.
type IImportDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnitAlias returns the unitAlias rule contexts.
	GetUnitAlias() IIdentifierContext

	// SetUnitAlias sets the unitAlias rule contexts.
	SetUnitAlias(IIdentifierContext)

	// Getter signatures
	Import() antlr.TerminalNode
	Semicolon() antlr.TerminalNode
	Path() IPathContext
	SymbolAliases() ISymbolAliasesContext
	From() antlr.TerminalNode
	Mul() antlr.TerminalNode
	As() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsImportDirectiveContext differentiates from other interfaces.
	IsImportDirectiveContext()
}

type ImportDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	unitAlias IIdentifierContext
}

func NewEmptyImportDirectiveContext() *ImportDirectiveContext {
	var p = new(ImportDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importDirective
	return p
}

func InitEmptyImportDirectiveContext(p *ImportDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importDirective
}

func (*ImportDirectiveContext) IsImportDirectiveContext() {}

func NewImportDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDirectiveContext {
	var p = new(ImportDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importDirective

	return p
}

func (s *ImportDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDirectiveContext) GetUnitAlias() IIdentifierContext { return s.unitAlias }

func (s *ImportDirectiveContext) SetUnitAlias(v IIdentifierContext) { s.unitAlias = v }

func (s *ImportDirectiveContext) Import() antlr.TerminalNode {
	return s.GetToken(SolidityParserImport, 0)
}

func (s *ImportDirectiveContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *ImportDirectiveContext) Path() IPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathContext)
}

func (s *ImportDirectiveContext) SymbolAliases() ISymbolAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolAliasesContext)
}

func (s *ImportDirectiveContext) From() antlr.TerminalNode {
	return s.GetToken(SolidityParserFrom, 0)
}

func (s *ImportDirectiveContext) Mul() antlr.TerminalNode {
	return s.GetToken(SolidityParserMul, 0)
}

func (s *ImportDirectiveContext) As() antlr.TerminalNode {
	return s.GetToken(SolidityParserAs, 0)
}

func (s *ImportDirectiveContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterImportDirective(s)
	}
}

func (s *ImportDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitImportDirective(s)
	}
}

func (p *SolidityParser) ImportDirective() (localctx IImportDirectiveContext) {
	localctx = NewImportDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SolidityParserRULE_importDirective)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(211)
		p.Match(SolidityParserImport)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserNonEmptyStringLiteral:
		{
			p.SetState(212)
			p.Path()
		}
		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserAs {
			{
				p.SetState(213)
				p.Match(SolidityParserAs)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(214)

				var _x = p.Identifier()

				localctx.(*ImportDirectiveContext).unitAlias = _x
			}

		}

	case SolidityParserLBrace:
		{
			p.SetState(217)
			p.SymbolAliases()
		}
		{
			p.SetState(218)
			p.Match(SolidityParserFrom)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(219)
			p.Path()
		}

	case SolidityParserMul:
		{
			p.SetState(221)
			p.Match(SolidityParserMul)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(222)
			p.Match(SolidityParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(223)

			var _x = p.Identifier()

			localctx.(*ImportDirectiveContext).unitAlias = _x
		}
		{
			p.SetState(224)
			p.Match(SolidityParserFrom)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(225)
			p.Path()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(229)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportAliasesContext is an interface to support dynamic dispatch.
type IImportAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSymbol returns the symbol rule contexts.
	GetSymbol() IIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetSymbol sets the symbol rule contexts.
	SetSymbol(IIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	As() antlr.TerminalNode

	// IsImportAliasesContext differentiates from other interfaces.
	IsImportAliasesContext()
}

type ImportAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	symbol IIdentifierContext
	alias  IIdentifierContext
}

func NewEmptyImportAliasesContext() *ImportAliasesContext {
	var p = new(ImportAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importAliases
	return p
}

func InitEmptyImportAliasesContext(p *ImportAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_importAliases
}

func (*ImportAliasesContext) IsImportAliasesContext() {}

func NewImportAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAliasesContext {
	var p = new(ImportAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importAliases

	return p
}

func (s *ImportAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAliasesContext) GetSymbol() IIdentifierContext { return s.symbol }

func (s *ImportAliasesContext) GetAlias() IIdentifierContext { return s.alias }

func (s *ImportAliasesContext) SetSymbol(v IIdentifierContext) { s.symbol = v }

func (s *ImportAliasesContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *ImportAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ImportAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportAliasesContext) As() antlr.TerminalNode {
	return s.GetToken(SolidityParserAs, 0)
}

func (s *ImportAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterImportAliases(s)
	}
}

func (s *ImportAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitImportAliases(s)
	}
}

func (p *SolidityParser) ImportAliases() (localctx IImportAliasesContext) {
	localctx = NewImportAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SolidityParserRULE_importAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(231)

		var _x = p.Identifier()

		localctx.(*ImportAliasesContext).symbol = _x
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserAs {
		{
			p.SetState(232)
			p.Match(SolidityParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(233)

			var _x = p.Identifier()

			localctx.(*ImportAliasesContext).alias = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathContext is an interface to support dynamic dispatch.
type IPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NonEmptyStringLiteral() antlr.TerminalNode

	// IsPathContext differentiates from other interfaces.
	IsPathContext()
}

type PathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathContext() *PathContext {
	var p = new(PathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_path
	return p
}

func InitEmptyPathContext(p *PathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_path
}

func (*PathContext) IsPathContext() {}

func NewPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathContext {
	var p = new(PathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_path

	return p
}

func (s *PathContext) GetParser() antlr.Parser { return s.parser }

func (s *PathContext) NonEmptyStringLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserNonEmptyStringLiteral, 0)
}

func (s *PathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterPath(s)
	}
}

func (s *PathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitPath(s)
	}
}

func (p *SolidityParser) Path() (localctx IPathContext) {
	localctx = NewPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SolidityParserRULE_path)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(236)
		p.Match(SolidityParserNonEmptyStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISymbolAliasesContext is an interface to support dynamic dispatch.
type ISymbolAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_importAliases returns the _importAliases rule contexts.
	Get_importAliases() IImportAliasesContext

	// Set_importAliases sets the _importAliases rule contexts.
	Set_importAliases(IImportAliasesContext)

	// GetAliases returns the aliases rule context list.
	GetAliases() []IImportAliasesContext

	// SetAliases sets the aliases rule context list.
	SetAliases([]IImportAliasesContext)

	// Getter signatures
	LBrace() antlr.TerminalNode
	RBrace() antlr.TerminalNode
	AllImportAliases() []IImportAliasesContext
	ImportAliases(i int) IImportAliasesContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsSymbolAliasesContext differentiates from other interfaces.
	IsSymbolAliasesContext()
}

type SymbolAliasesContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_importAliases IImportAliasesContext
	aliases        []IImportAliasesContext
}

func NewEmptySymbolAliasesContext() *SymbolAliasesContext {
	var p = new(SymbolAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_symbolAliases
	return p
}

func InitEmptySymbolAliasesContext(p *SymbolAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_symbolAliases
}

func (*SymbolAliasesContext) IsSymbolAliasesContext() {}

func NewSymbolAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolAliasesContext {
	var p = new(SymbolAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_symbolAliases

	return p
}

func (s *SymbolAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolAliasesContext) Get_importAliases() IImportAliasesContext { return s._importAliases }

func (s *SymbolAliasesContext) Set_importAliases(v IImportAliasesContext) { s._importAliases = v }

func (s *SymbolAliasesContext) GetAliases() []IImportAliasesContext { return s.aliases }

func (s *SymbolAliasesContext) SetAliases(v []IImportAliasesContext) { s.aliases = v }

func (s *SymbolAliasesContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *SymbolAliasesContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *SymbolAliasesContext) AllImportAliases() []IImportAliasesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportAliasesContext); ok {
			len++
		}
	}

	tst := make([]IImportAliasesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportAliasesContext); ok {
			tst[i] = t.(IImportAliasesContext)
			i++
		}
	}

	return tst
}

func (s *SymbolAliasesContext) ImportAliases(i int) IImportAliasesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAliasesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAliasesContext)
}

func (s *SymbolAliasesContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *SymbolAliasesContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *SymbolAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterSymbolAliases(s)
	}
}

func (s *SymbolAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitSymbolAliases(s)
	}
}

func (p *SolidityParser) SymbolAliases() (localctx ISymbolAliasesContext) {
	localctx = NewSymbolAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SolidityParserRULE_symbolAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(238)
		p.Match(SolidityParserLBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(239)

		var _x = p.ImportAliases()

		localctx.(*SymbolAliasesContext)._importAliases = _x
	}
	localctx.(*SymbolAliasesContext).aliases = append(localctx.(*SymbolAliasesContext).aliases, localctx.(*SymbolAliasesContext)._importAliases)
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserComma {
		{
			p.SetState(240)
			p.Match(SolidityParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(241)

			var _x = p.ImportAliases()

			localctx.(*SymbolAliasesContext)._importAliases = _x
		}
		localctx.(*SymbolAliasesContext).aliases = append(localctx.(*SymbolAliasesContext).aliases, localctx.(*SymbolAliasesContext)._importAliases)

		p.SetState(246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(247)
		p.Match(SolidityParserRBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContractDefinitionContext is an interface to support dynamic dispatch.
type IContractDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	Contract() antlr.TerminalNode
	LBrace() antlr.TerminalNode
	RBrace() antlr.TerminalNode
	Identifier() IIdentifierContext
	Abstract() antlr.TerminalNode
	InheritanceSpecifierList() IInheritanceSpecifierListContext
	AllContractBodyElement() []IContractBodyElementContext
	ContractBodyElement(i int) IContractBodyElementContext

	// IsContractDefinitionContext differentiates from other interfaces.
	IsContractDefinitionContext()
}

type ContractDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyContractDefinitionContext() *ContractDefinitionContext {
	var p = new(ContractDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_contractDefinition
	return p
}

func InitEmptyContractDefinitionContext(p *ContractDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_contractDefinition
}

func (*ContractDefinitionContext) IsContractDefinitionContext() {}

func NewContractDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContractDefinitionContext {
	var p = new(ContractDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_contractDefinition

	return p
}

func (s *ContractDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ContractDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *ContractDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ContractDefinitionContext) Contract() antlr.TerminalNode {
	return s.GetToken(SolidityParserContract, 0)
}

func (s *ContractDefinitionContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *ContractDefinitionContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *ContractDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContractDefinitionContext) Abstract() antlr.TerminalNode {
	return s.GetToken(SolidityParserAbstract, 0)
}

func (s *ContractDefinitionContext) InheritanceSpecifierList() IInheritanceSpecifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceSpecifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceSpecifierListContext)
}

func (s *ContractDefinitionContext) AllContractBodyElement() []IContractBodyElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractBodyElementContext); ok {
			len++
		}
	}

	tst := make([]IContractBodyElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractBodyElementContext); ok {
			tst[i] = t.(IContractBodyElementContext)
			i++
		}
	}

	return tst
}

func (s *ContractDefinitionContext) ContractBodyElement(i int) IContractBodyElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractBodyElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractBodyElementContext)
}

func (s *ContractDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContractDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContractDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterContractDefinition(s)
	}
}

func (s *ContractDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitContractDefinition(s)
	}
}

func (p *SolidityParser) ContractDefinition() (localctx IContractDefinitionContext) {
	localctx = NewContractDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SolidityParserRULE_contractDefinition)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(250)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserAbstract {
		{
			p.SetState(249)
			p.Match(SolidityParserAbstract)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(252)
		p.Match(SolidityParserContract)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(253)

		var _x = p.Identifier()

		localctx.(*ContractDefinitionContext).name = _x
	}
	p.SetState(255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserIs {
		{
			p.SetState(254)
			p.InheritanceSpecifierList()
		}

	}
	{
		p.SetState(257)
		p.Match(SolidityParserLBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(258)
				p.ContractBodyElement()
			}

		}
		p.SetState(263)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(264)
		p.Match(SolidityParserRBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDefinitionContext is an interface to support dynamic dispatch.
type IInterfaceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	Interface() antlr.TerminalNode
	LBrace() antlr.TerminalNode
	RBrace() antlr.TerminalNode
	Identifier() IIdentifierContext
	InheritanceSpecifierList() IInheritanceSpecifierListContext
	AllContractBodyElement() []IContractBodyElementContext
	ContractBodyElement(i int) IContractBodyElementContext

	// IsInterfaceDefinitionContext differentiates from other interfaces.
	IsInterfaceDefinitionContext()
}

type InterfaceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyInterfaceDefinitionContext() *InterfaceDefinitionContext {
	var p = new(InterfaceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_interfaceDefinition
	return p
}

func InitEmptyInterfaceDefinitionContext(p *InterfaceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_interfaceDefinition
}

func (*InterfaceDefinitionContext) IsInterfaceDefinitionContext() {}

func NewInterfaceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDefinitionContext {
	var p = new(InterfaceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_interfaceDefinition

	return p
}

func (s *InterfaceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *InterfaceDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *InterfaceDefinitionContext) Interface() antlr.TerminalNode {
	return s.GetToken(SolidityParserInterface, 0)
}

func (s *InterfaceDefinitionContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *InterfaceDefinitionContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *InterfaceDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceDefinitionContext) InheritanceSpecifierList() IInheritanceSpecifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceSpecifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceSpecifierListContext)
}

func (s *InterfaceDefinitionContext) AllContractBodyElement() []IContractBodyElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractBodyElementContext); ok {
			len++
		}
	}

	tst := make([]IContractBodyElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractBodyElementContext); ok {
			tst[i] = t.(IContractBodyElementContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDefinitionContext) ContractBodyElement(i int) IContractBodyElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractBodyElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractBodyElementContext)
}

func (s *InterfaceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterInterfaceDefinition(s)
	}
}

func (s *InterfaceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitInterfaceDefinition(s)
	}
}

func (p *SolidityParser) InterfaceDefinition() (localctx IInterfaceDefinitionContext) {
	localctx = NewInterfaceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SolidityParserRULE_interfaceDefinition)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(266)
		p.Match(SolidityParserInterface)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(267)

		var _x = p.Identifier()

		localctx.(*InterfaceDefinitionContext).name = _x
	}
	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserIs {
		{
			p.SetState(268)
			p.InheritanceSpecifierList()
		}

	}
	{
		p.SetState(271)
		p.Match(SolidityParserLBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(272)
				p.ContractBodyElement()
			}

		}
		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(278)
		p.Match(SolidityParserRBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILibraryDefinitionContext is an interface to support dynamic dispatch.
type ILibraryDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	Library() antlr.TerminalNode
	LBrace() antlr.TerminalNode
	RBrace() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllContractBodyElement() []IContractBodyElementContext
	ContractBodyElement(i int) IContractBodyElementContext

	// IsLibraryDefinitionContext differentiates from other interfaces.
	IsLibraryDefinitionContext()
}

type LibraryDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyLibraryDefinitionContext() *LibraryDefinitionContext {
	var p = new(LibraryDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_libraryDefinition
	return p
}

func InitEmptyLibraryDefinitionContext(p *LibraryDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_libraryDefinition
}

func (*LibraryDefinitionContext) IsLibraryDefinitionContext() {}

func NewLibraryDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDefinitionContext {
	var p = new(LibraryDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_libraryDefinition

	return p
}

func (s *LibraryDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *LibraryDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *LibraryDefinitionContext) Library() antlr.TerminalNode {
	return s.GetToken(SolidityParserLibrary, 0)
}

func (s *LibraryDefinitionContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *LibraryDefinitionContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *LibraryDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LibraryDefinitionContext) AllContractBodyElement() []IContractBodyElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractBodyElementContext); ok {
			len++
		}
	}

	tst := make([]IContractBodyElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractBodyElementContext); ok {
			tst[i] = t.(IContractBodyElementContext)
			i++
		}
	}

	return tst
}

func (s *LibraryDefinitionContext) ContractBodyElement(i int) IContractBodyElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractBodyElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractBodyElementContext)
}

func (s *LibraryDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterLibraryDefinition(s)
	}
}

func (s *LibraryDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitLibraryDefinition(s)
	}
}

func (p *SolidityParser) LibraryDefinition() (localctx ILibraryDefinitionContext) {
	localctx = NewLibraryDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SolidityParserRULE_libraryDefinition)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.Match(SolidityParserLibrary)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(281)

		var _x = p.Identifier()

		localctx.(*LibraryDefinitionContext).name = _x
	}
	{
		p.SetState(282)
		p.Match(SolidityParserLBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(283)
				p.ContractBodyElement()
			}

		}
		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(289)
		p.Match(SolidityParserRBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritanceSpecifierListContext is an interface to support dynamic dispatch.
type IInheritanceSpecifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_inheritanceSpecifier returns the _inheritanceSpecifier rule contexts.
	Get_inheritanceSpecifier() IInheritanceSpecifierContext

	// Set_inheritanceSpecifier sets the _inheritanceSpecifier rule contexts.
	Set_inheritanceSpecifier(IInheritanceSpecifierContext)

	// GetInheritanceSpecifiers returns the inheritanceSpecifiers rule context list.
	GetInheritanceSpecifiers() []IInheritanceSpecifierContext

	// SetInheritanceSpecifiers sets the inheritanceSpecifiers rule context list.
	SetInheritanceSpecifiers([]IInheritanceSpecifierContext)

	// Getter signatures
	Is() antlr.TerminalNode
	AllInheritanceSpecifier() []IInheritanceSpecifierContext
	InheritanceSpecifier(i int) IInheritanceSpecifierContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsInheritanceSpecifierListContext differentiates from other interfaces.
	IsInheritanceSpecifierListContext()
}

type InheritanceSpecifierListContext struct {
	antlr.BaseParserRuleContext
	parser                antlr.Parser
	_inheritanceSpecifier IInheritanceSpecifierContext
	inheritanceSpecifiers []IInheritanceSpecifierContext
}

func NewEmptyInheritanceSpecifierListContext() *InheritanceSpecifierListContext {
	var p = new(InheritanceSpecifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifierList
	return p
}

func InitEmptyInheritanceSpecifierListContext(p *InheritanceSpecifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifierList
}

func (*InheritanceSpecifierListContext) IsInheritanceSpecifierListContext() {}

func NewInheritanceSpecifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceSpecifierListContext {
	var p = new(InheritanceSpecifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifierList

	return p
}

func (s *InheritanceSpecifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceSpecifierListContext) Get_inheritanceSpecifier() IInheritanceSpecifierContext {
	return s._inheritanceSpecifier
}

func (s *InheritanceSpecifierListContext) Set_inheritanceSpecifier(v IInheritanceSpecifierContext) {
	s._inheritanceSpecifier = v
}

func (s *InheritanceSpecifierListContext) GetInheritanceSpecifiers() []IInheritanceSpecifierContext {
	return s.inheritanceSpecifiers
}

func (s *InheritanceSpecifierListContext) SetInheritanceSpecifiers(v []IInheritanceSpecifierContext) {
	s.inheritanceSpecifiers = v
}

func (s *InheritanceSpecifierListContext) Is() antlr.TerminalNode {
	return s.GetToken(SolidityParserIs, 0)
}

func (s *InheritanceSpecifierListContext) AllInheritanceSpecifier() []IInheritanceSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInheritanceSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IInheritanceSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInheritanceSpecifierContext); ok {
			tst[i] = t.(IInheritanceSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *InheritanceSpecifierListContext) InheritanceSpecifier(i int) IInheritanceSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceSpecifierContext)
}

func (s *InheritanceSpecifierListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *InheritanceSpecifierListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *InheritanceSpecifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceSpecifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceSpecifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterInheritanceSpecifierList(s)
	}
}

func (s *InheritanceSpecifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitInheritanceSpecifierList(s)
	}
}

func (p *SolidityParser) InheritanceSpecifierList() (localctx IInheritanceSpecifierListContext) {
	localctx = NewInheritanceSpecifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SolidityParserRULE_inheritanceSpecifierList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)
		p.Match(SolidityParserIs)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(292)

		var _x = p.InheritanceSpecifier()

		localctx.(*InheritanceSpecifierListContext)._inheritanceSpecifier = _x
	}
	localctx.(*InheritanceSpecifierListContext).inheritanceSpecifiers = append(localctx.(*InheritanceSpecifierListContext).inheritanceSpecifiers, localctx.(*InheritanceSpecifierListContext)._inheritanceSpecifier)
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(293)
				p.Match(SolidityParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(294)

				var _x = p.InheritanceSpecifier()

				localctx.(*InheritanceSpecifierListContext)._inheritanceSpecifier = _x
			}
			localctx.(*InheritanceSpecifierListContext).inheritanceSpecifiers = append(localctx.(*InheritanceSpecifierListContext).inheritanceSpecifiers, localctx.(*InheritanceSpecifierListContext)._inheritanceSpecifier)

		}
		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritanceSpecifierContext is an interface to support dynamic dispatch.
type IInheritanceSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierPathContext

	// GetArguments returns the arguments rule contexts.
	GetArguments() ICallArgumentListContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierPathContext)

	// SetArguments sets the arguments rule contexts.
	SetArguments(ICallArgumentListContext)

	// Getter signatures
	IdentifierPath() IIdentifierPathContext
	CallArgumentList() ICallArgumentListContext

	// IsInheritanceSpecifierContext differentiates from other interfaces.
	IsInheritanceSpecifierContext()
}

type InheritanceSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	name      IIdentifierPathContext
	arguments ICallArgumentListContext
}

func NewEmptyInheritanceSpecifierContext() *InheritanceSpecifierContext {
	var p = new(InheritanceSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier
	return p
}

func InitEmptyInheritanceSpecifierContext(p *InheritanceSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier
}

func (*InheritanceSpecifierContext) IsInheritanceSpecifierContext() {}

func NewInheritanceSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceSpecifierContext {
	var p = new(InheritanceSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier

	return p
}

func (s *InheritanceSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceSpecifierContext) GetName() IIdentifierPathContext { return s.name }

func (s *InheritanceSpecifierContext) GetArguments() ICallArgumentListContext { return s.arguments }

func (s *InheritanceSpecifierContext) SetName(v IIdentifierPathContext) { s.name = v }

func (s *InheritanceSpecifierContext) SetArguments(v ICallArgumentListContext) { s.arguments = v }

func (s *InheritanceSpecifierContext) IdentifierPath() IIdentifierPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPathContext)
}

func (s *InheritanceSpecifierContext) CallArgumentList() ICallArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentListContext)
}

func (s *InheritanceSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterInheritanceSpecifier(s)
	}
}

func (s *InheritanceSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitInheritanceSpecifier(s)
	}
}

func (p *SolidityParser) InheritanceSpecifier() (localctx IInheritanceSpecifierContext) {
	localctx = NewInheritanceSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SolidityParserRULE_inheritanceSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)

		var _x = p.IdentifierPath()

		localctx.(*InheritanceSpecifierContext).name = _x
	}
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserLParen {
		{
			p.SetState(301)

			var _x = p.CallArgumentList()

			localctx.(*InheritanceSpecifierContext).arguments = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContractBodyElementContext is an interface to support dynamic dispatch.
type IContractBodyElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstructorDefinition() IConstructorDefinitionContext
	FunctionDefinition() IFunctionDefinitionContext
	ModifierDefinition() IModifierDefinitionContext
	FallbackFunctionDefinition() IFallbackFunctionDefinitionContext
	ReceiveFunctionDefinition() IReceiveFunctionDefinitionContext
	StructDefinition() IStructDefinitionContext
	EnumDefinition() IEnumDefinitionContext
	UserDefinedValueTypeDefinition() IUserDefinedValueTypeDefinitionContext
	StateVariableDeclaration() IStateVariableDeclarationContext
	EventDefinition() IEventDefinitionContext
	ErrorDefinition() IErrorDefinitionContext
	UsingDirective() IUsingDirectiveContext

	// IsContractBodyElementContext differentiates from other interfaces.
	IsContractBodyElementContext()
}

type ContractBodyElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContractBodyElementContext() *ContractBodyElementContext {
	var p = new(ContractBodyElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_contractBodyElement
	return p
}

func InitEmptyContractBodyElementContext(p *ContractBodyElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_contractBodyElement
}

func (*ContractBodyElementContext) IsContractBodyElementContext() {}

func NewContractBodyElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContractBodyElementContext {
	var p = new(ContractBodyElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_contractBodyElement

	return p
}

func (s *ContractBodyElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContractBodyElementContext) ConstructorDefinition() IConstructorDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDefinitionContext)
}

func (s *ContractBodyElementContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *ContractBodyElementContext) ModifierDefinition() IModifierDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierDefinitionContext)
}

func (s *ContractBodyElementContext) FallbackFunctionDefinition() IFallbackFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFallbackFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFallbackFunctionDefinitionContext)
}

func (s *ContractBodyElementContext) ReceiveFunctionDefinition() IReceiveFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveFunctionDefinitionContext)
}

func (s *ContractBodyElementContext) StructDefinition() IStructDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDefinitionContext)
}

func (s *ContractBodyElementContext) EnumDefinition() IEnumDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDefinitionContext)
}

func (s *ContractBodyElementContext) UserDefinedValueTypeDefinition() IUserDefinedValueTypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedValueTypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedValueTypeDefinitionContext)
}

func (s *ContractBodyElementContext) StateVariableDeclaration() IStateVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateVariableDeclarationContext)
}

func (s *ContractBodyElementContext) EventDefinition() IEventDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventDefinitionContext)
}

func (s *ContractBodyElementContext) ErrorDefinition() IErrorDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorDefinitionContext)
}

func (s *ContractBodyElementContext) UsingDirective() IUsingDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingDirectiveContext)
}

func (s *ContractBodyElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContractBodyElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContractBodyElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterContractBodyElement(s)
	}
}

func (s *ContractBodyElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitContractBodyElement(s)
	}
}

func (p *SolidityParser) ContractBodyElement() (localctx IContractBodyElementContext) {
	localctx = NewContractBodyElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SolidityParserRULE_contractBodyElement)
	p.SetState(316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(304)
			p.ConstructorDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(305)
			p.FunctionDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(306)
			p.ModifierDefinition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(307)
			p.FallbackFunctionDefinition()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(308)
			p.ReceiveFunctionDefinition()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(309)
			p.StructDefinition()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(310)
			p.EnumDefinition()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(311)
			p.UserDefinedValueTypeDefinition()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(312)
			p.StateVariableDeclaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(313)
			p.EventDefinition()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(314)
			p.ErrorDefinition()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(315)
			p.UsingDirective()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentContext is an interface to support dynamic dispatch.
type INamedArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	Colon() antlr.TerminalNode
	Identifier() IIdentifierContext
	Expression() IExpressionContext

	// IsNamedArgumentContext differentiates from other interfaces.
	IsNamedArgumentContext()
}

type NamedArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
	value  IExpressionContext
}

func NewEmptyNamedArgumentContext() *NamedArgumentContext {
	var p = new(NamedArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_namedArgument
	return p
}

func InitEmptyNamedArgumentContext(p *NamedArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_namedArgument
}

func (*NamedArgumentContext) IsNamedArgumentContext() {}

func NewNamedArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_namedArgument

	return p
}

func (s *NamedArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentContext) GetName() IIdentifierContext { return s.name }

func (s *NamedArgumentContext) GetValue() IExpressionContext { return s.value }

func (s *NamedArgumentContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedArgumentContext) SetValue(v IExpressionContext) { s.value = v }

func (s *NamedArgumentContext) Colon() antlr.TerminalNode {
	return s.GetToken(SolidityParserColon, 0)
}

func (s *NamedArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterNamedArgument(s)
	}
}

func (s *NamedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitNamedArgument(s)
	}
}

func (p *SolidityParser) NamedArgument() (localctx INamedArgumentContext) {
	localctx = NewNamedArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SolidityParserRULE_namedArgument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)

		var _x = p.Identifier()

		localctx.(*NamedArgumentContext).name = _x
	}
	{
		p.SetState(319)
		p.Match(SolidityParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(320)

		var _x = p.expression(0)

		localctx.(*NamedArgumentContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallArgumentListContext is an interface to support dynamic dispatch.
type ICallArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	LBrace() antlr.TerminalNode
	RBrace() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllNamedArgument() []INamedArgumentContext
	NamedArgument(i int) INamedArgumentContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsCallArgumentListContext differentiates from other interfaces.
	IsCallArgumentListContext()
}

type CallArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallArgumentListContext() *CallArgumentListContext {
	var p = new(CallArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_callArgumentList
	return p
}

func InitEmptyCallArgumentListContext(p *CallArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_callArgumentList
}

func (*CallArgumentListContext) IsCallArgumentListContext() {}

func NewCallArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallArgumentListContext {
	var p = new(CallArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_callArgumentList

	return p
}

func (s *CallArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *CallArgumentListContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *CallArgumentListContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *CallArgumentListContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *CallArgumentListContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *CallArgumentListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CallArgumentListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CallArgumentListContext) AllNamedArgument() []INamedArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedArgumentContext); ok {
			len++
		}
	}

	tst := make([]INamedArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedArgumentContext); ok {
			tst[i] = t.(INamedArgumentContext)
			i++
		}
	}

	return tst
}

func (s *CallArgumentListContext) NamedArgument(i int) INamedArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentContext)
}

func (s *CallArgumentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *CallArgumentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *CallArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterCallArgumentList(s)
	}
}

func (s *CallArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitCallArgumentList(s)
	}
}

func (p *SolidityParser) CallArgumentList() (localctx ICallArgumentListContext) {
	localctx = NewCallArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SolidityParserRULE_callArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(322)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.SetState(331)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(323)
				p.expression(0)
			}
			p.SetState(328)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SolidityParserComma {
				{
					p.SetState(324)
					p.Match(SolidityParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(325)
					p.expression(0)
				}

				p.SetState(330)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(333)
			p.Match(SolidityParserLBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserIdentifier {
			{
				p.SetState(334)
				p.NamedArgument()
			}
			p.SetState(339)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SolidityParserComma {
				{
					p.SetState(335)
					p.Match(SolidityParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(336)
					p.NamedArgument()
				}

				p.SetState(341)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(344)
			p.Match(SolidityParserRBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(347)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierPathContext is an interface to support dynamic dispatch.
type IIdentifierPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllPeriod() []antlr.TerminalNode
	Period(i int) antlr.TerminalNode

	// IsIdentifierPathContext differentiates from other interfaces.
	IsIdentifierPathContext()
}

type IdentifierPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierPathContext() *IdentifierPathContext {
	var p = new(IdentifierPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_identifierPath
	return p
}

func InitEmptyIdentifierPathContext(p *IdentifierPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_identifierPath
}

func (*IdentifierPathContext) IsIdentifierPathContext() {}

func NewIdentifierPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierPathContext {
	var p = new(IdentifierPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_identifierPath

	return p
}

func (s *IdentifierPathContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierPathContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierPathContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierPathContext) AllPeriod() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPeriod)
}

func (s *IdentifierPathContext) Period(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPeriod, i)
}

func (s *IdentifierPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterIdentifierPath(s)
	}
}

func (s *IdentifierPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitIdentifierPath(s)
	}
}

func (p *SolidityParser) IdentifierPath() (localctx IIdentifierPathContext) {
	localctx = NewIdentifierPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SolidityParserRULE_identifierPath)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(349)
		p.Identifier()
	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(350)
				p.Match(SolidityParserPeriod)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(351)
				p.Identifier()
			}

		}
		p.SetState(356)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifierInvocationContext is an interface to support dynamic dispatch.
type IModifierInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierPath() IIdentifierPathContext
	CallArgumentList() ICallArgumentListContext

	// IsModifierInvocationContext differentiates from other interfaces.
	IsModifierInvocationContext()
}

type ModifierInvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierInvocationContext() *ModifierInvocationContext {
	var p = new(ModifierInvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierInvocation
	return p
}

func InitEmptyModifierInvocationContext(p *ModifierInvocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierInvocation
}

func (*ModifierInvocationContext) IsModifierInvocationContext() {}

func NewModifierInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierInvocationContext {
	var p = new(ModifierInvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierInvocation

	return p
}

func (s *ModifierInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierInvocationContext) IdentifierPath() IIdentifierPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPathContext)
}

func (s *ModifierInvocationContext) CallArgumentList() ICallArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentListContext)
}

func (s *ModifierInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterModifierInvocation(s)
	}
}

func (s *ModifierInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitModifierInvocation(s)
	}
}

func (p *SolidityParser) ModifierInvocation() (localctx IModifierInvocationContext) {
	localctx = NewModifierInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SolidityParserRULE_modifierInvocation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(357)
		p.IdentifierPath()
	}
	p.SetState(359)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(358)
			p.CallArgumentList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVisibilityContext is an interface to support dynamic dispatch.
type IVisibilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Internal() antlr.TerminalNode
	External() antlr.TerminalNode
	Private() antlr.TerminalNode
	Public() antlr.TerminalNode

	// IsVisibilityContext differentiates from other interfaces.
	IsVisibilityContext()
}

type VisibilityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityContext() *VisibilityContext {
	var p = new(VisibilityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_visibility
	return p
}

func InitEmptyVisibilityContext(p *VisibilityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_visibility
}

func (*VisibilityContext) IsVisibilityContext() {}

func NewVisibilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityContext {
	var p = new(VisibilityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_visibility

	return p
}

func (s *VisibilityContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilityContext) Internal() antlr.TerminalNode {
	return s.GetToken(SolidityParserInternal, 0)
}

func (s *VisibilityContext) External() antlr.TerminalNode {
	return s.GetToken(SolidityParserExternal, 0)
}

func (s *VisibilityContext) Private() antlr.TerminalNode {
	return s.GetToken(SolidityParserPrivate, 0)
}

func (s *VisibilityContext) Public() antlr.TerminalNode {
	return s.GetToken(SolidityParserPublic, 0)
}

func (s *VisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterVisibility(s)
	}
}

func (s *VisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitVisibility(s)
	}
}

func (p *SolidityParser) Visibility() (localctx IVisibilityContext) {
	localctx = NewVisibilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SolidityParserRULE_visibility)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(361)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1689124746559488) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_parameterDeclaration returns the _parameterDeclaration rule contexts.
	Get_parameterDeclaration() IParameterDeclarationContext

	// Set_parameterDeclaration sets the _parameterDeclaration rule contexts.
	Set_parameterDeclaration(IParameterDeclarationContext)

	// GetParameters returns the parameters rule context list.
	GetParameters() []IParameterDeclarationContext

	// SetParameters sets the parameters rule context list.
	SetParameters([]IParameterDeclarationContext)

	// Getter signatures
	AllParameterDeclaration() []IParameterDeclarationContext
	ParameterDeclaration(i int) IParameterDeclarationContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser                antlr.Parser
	_parameterDeclaration IParameterDeclarationContext
	parameters            []IParameterDeclarationContext
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) Get_parameterDeclaration() IParameterDeclarationContext {
	return s._parameterDeclaration
}

func (s *ParameterListContext) Set_parameterDeclaration(v IParameterDeclarationContext) {
	s._parameterDeclaration = v
}

func (s *ParameterListContext) GetParameters() []IParameterDeclarationContext { return s.parameters }

func (s *ParameterListContext) SetParameters(v []IParameterDeclarationContext) { s.parameters = v }

func (s *ParameterListContext) AllParameterDeclaration() []IParameterDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IParameterDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterDeclarationContext); ok {
			tst[i] = t.(IParameterDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) ParameterDeclaration(i int) IParameterDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationContext)
}

func (s *ParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *ParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (p *SolidityParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SolidityParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)

		var _x = p.ParameterDeclaration()

		localctx.(*ParameterListContext)._parameterDeclaration = _x
	}
	localctx.(*ParameterListContext).parameters = append(localctx.(*ParameterListContext).parameters, localctx.(*ParameterListContext)._parameterDeclaration)
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserComma {
		{
			p.SetState(364)
			p.Match(SolidityParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(365)

			var _x = p.ParameterDeclaration()

			localctx.(*ParameterListContext)._parameterDeclaration = _x
		}
		localctx.(*ParameterListContext).parameters = append(localctx.(*ParameterListContext).parameters, localctx.(*ParameterListContext)._parameterDeclaration)

		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterDeclarationContext is an interface to support dynamic dispatch.
type IParameterDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeNameContext

	// GetLocation returns the location rule contexts.
	GetLocation() IDataLocationContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeNameContext)

	// SetLocation sets the location rule contexts.
	SetLocation(IDataLocationContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	TypeName() ITypeNameContext
	DataLocation() IDataLocationContext
	Identifier() IIdentifierContext

	// IsParameterDeclarationContext differentiates from other interfaces.
	IsParameterDeclarationContext()
}

type ParameterDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	type_    ITypeNameContext
	location IDataLocationContext
	name     IIdentifierContext
}

func NewEmptyParameterDeclarationContext() *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_parameterDeclaration
	return p
}

func InitEmptyParameterDeclarationContext(p *ParameterDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_parameterDeclaration
}

func (*ParameterDeclarationContext) IsParameterDeclarationContext() {}

func NewParameterDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_parameterDeclaration

	return p
}

func (s *ParameterDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclarationContext) GetType_() ITypeNameContext { return s.type_ }

func (s *ParameterDeclarationContext) GetLocation() IDataLocationContext { return s.location }

func (s *ParameterDeclarationContext) GetName() IIdentifierContext { return s.name }

func (s *ParameterDeclarationContext) SetType_(v ITypeNameContext) { s.type_ = v }

func (s *ParameterDeclarationContext) SetLocation(v IDataLocationContext) { s.location = v }

func (s *ParameterDeclarationContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ParameterDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ParameterDeclarationContext) DataLocation() IDataLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataLocationContext)
}

func (s *ParameterDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParameterDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterParameterDeclaration(s)
	}
}

func (s *ParameterDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitParameterDeclaration(s)
	}
}

func (p *SolidityParser) ParameterDeclaration() (localctx IParameterDeclarationContext) {
	localctx = NewParameterDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SolidityParserRULE_parameterDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)

		var _x = p.typeName(0)

		localctx.(*ParameterDeclarationContext).type_ = _x
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&144119586122368000) != 0 {
		{
			p.SetState(372)

			var _x = p.DataLocation()

			localctx.(*ParameterDeclarationContext).location = _x
		}

	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserIdentifier {
		{
			p.SetState(375)

			var _x = p.Identifier()

			localctx.(*ParameterDeclarationContext).name = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorDefinitionContext is an interface to support dynamic dispatch.
type IConstructorDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetArguments returns the arguments rule contexts.
	GetArguments() IParameterListContext

	// GetBody returns the body rule contexts.
	GetBody() IBlockContext

	// SetArguments sets the arguments rule contexts.
	SetArguments(IParameterListContext)

	// SetBody sets the body rule contexts.
	SetBody(IBlockContext)

	// GetPayableSet returns the payableSet attribute.
	GetPayableSet() bool

	// GetVisibilitySet returns the visibilitySet attribute.
	GetVisibilitySet() bool

	// SetPayableSet sets the payableSet attribute.
	SetPayableSet(bool)

	// SetVisibilitySet sets the visibilitySet attribute.
	SetVisibilitySet(bool)

	// Getter signatures
	Constructor() antlr.TerminalNode
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	Block() IBlockContext
	AllModifierInvocation() []IModifierInvocationContext
	ModifierInvocation(i int) IModifierInvocationContext
	AllPayable() []antlr.TerminalNode
	Payable(i int) antlr.TerminalNode
	AllInternal() []antlr.TerminalNode
	Internal(i int) antlr.TerminalNode
	AllPublic() []antlr.TerminalNode
	Public(i int) antlr.TerminalNode
	ParameterList() IParameterListContext

	// IsConstructorDefinitionContext differentiates from other interfaces.
	IsConstructorDefinitionContext()
}

type ConstructorDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	payableSet    bool // TODO = false
	visibilitySet bool // TODO = false
	arguments     IParameterListContext
	body          IBlockContext
}

func NewEmptyConstructorDefinitionContext() *ConstructorDefinitionContext {
	var p = new(ConstructorDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_constructorDefinition
	return p
}

func InitEmptyConstructorDefinitionContext(p *ConstructorDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_constructorDefinition
}

func (*ConstructorDefinitionContext) IsConstructorDefinitionContext() {}

func NewConstructorDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDefinitionContext {
	var p = new(ConstructorDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_constructorDefinition

	return p
}

func (s *ConstructorDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDefinitionContext) GetArguments() IParameterListContext { return s.arguments }

func (s *ConstructorDefinitionContext) GetBody() IBlockContext { return s.body }

func (s *ConstructorDefinitionContext) SetArguments(v IParameterListContext) { s.arguments = v }

func (s *ConstructorDefinitionContext) SetBody(v IBlockContext) { s.body = v }

func (s *ConstructorDefinitionContext) GetPayableSet() bool { return s.payableSet }

func (s *ConstructorDefinitionContext) GetVisibilitySet() bool { return s.visibilitySet }

func (s *ConstructorDefinitionContext) SetPayableSet(v bool) { s.payableSet = v }

func (s *ConstructorDefinitionContext) SetVisibilitySet(v bool) { s.visibilitySet = v }

func (s *ConstructorDefinitionContext) Constructor() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstructor, 0)
}

func (s *ConstructorDefinitionContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *ConstructorDefinitionContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *ConstructorDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ConstructorDefinitionContext) AllModifierInvocation() []IModifierInvocationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			len++
		}
	}

	tst := make([]IModifierInvocationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierInvocationContext); ok {
			tst[i] = t.(IModifierInvocationContext)
			i++
		}
	}

	return tst
}

func (s *ConstructorDefinitionContext) ModifierInvocation(i int) IModifierInvocationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierInvocationContext)
}

func (s *ConstructorDefinitionContext) AllPayable() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPayable)
}

func (s *ConstructorDefinitionContext) Payable(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPayable, i)
}

func (s *ConstructorDefinitionContext) AllInternal() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternal)
}

func (s *ConstructorDefinitionContext) Internal(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternal, i)
}

func (s *ConstructorDefinitionContext) AllPublic() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPublic)
}

func (s *ConstructorDefinitionContext) Public(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPublic, i)
}

func (s *ConstructorDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ConstructorDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterConstructorDefinition(s)
	}
}

func (s *ConstructorDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitConstructorDefinition(s)
	}
}

func (p *SolidityParser) ConstructorDefinition() (localctx IConstructorDefinitionContext) {
	localctx = NewConstructorDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SolidityParserRULE_constructorDefinition)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(378)
		p.Match(SolidityParserConstructor)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(379)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(381)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(380)

			var _x = p.ParameterList()

			localctx.(*ConstructorDefinitionContext).arguments = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(383)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(394)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(384)
					p.ModifierInvocation()
				}

			case 2:
				p.SetState(385)

				if !(!localctx.(*ConstructorDefinitionContext).payableSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$payableSet", ""))
					goto errorExit
				}
				{
					p.SetState(386)
					p.Match(SolidityParserPayable)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ConstructorDefinitionContext).SetPayableSet(true)

			case 3:
				p.SetState(388)

				if !(!localctx.(*ConstructorDefinitionContext).visibilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$visibilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(389)
					p.Match(SolidityParserInternal)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ConstructorDefinitionContext).SetVisibilitySet(true)

			case 4:
				p.SetState(391)

				if !(!localctx.(*ConstructorDefinitionContext).visibilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$visibilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(392)
					p.Match(SolidityParserPublic)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ConstructorDefinitionContext).SetVisibilitySet(true)

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(399)

		var _x = p.Block()

		localctx.(*ConstructorDefinitionContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStateMutabilityContext is an interface to support dynamic dispatch.
type IStateMutabilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pure() antlr.TerminalNode
	View() antlr.TerminalNode
	Payable() antlr.TerminalNode

	// IsStateMutabilityContext differentiates from other interfaces.
	IsStateMutabilityContext()
}

type StateMutabilityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStateMutabilityContext() *StateMutabilityContext {
	var p = new(StateMutabilityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stateMutability
	return p
}

func InitEmptyStateMutabilityContext(p *StateMutabilityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stateMutability
}

func (*StateMutabilityContext) IsStateMutabilityContext() {}

func NewStateMutabilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StateMutabilityContext {
	var p = new(StateMutabilityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stateMutability

	return p
}

func (s *StateMutabilityContext) GetParser() antlr.Parser { return s.parser }

func (s *StateMutabilityContext) Pure() antlr.TerminalNode {
	return s.GetToken(SolidityParserPure, 0)
}

func (s *StateMutabilityContext) View() antlr.TerminalNode {
	return s.GetToken(SolidityParserView, 0)
}

func (s *StateMutabilityContext) Payable() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayable, 0)
}

func (s *StateMutabilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StateMutabilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StateMutabilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterStateMutability(s)
	}
}

func (s *StateMutabilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitStateMutability(s)
	}
}

func (p *SolidityParser) StateMutability() (localctx IStateMutabilityContext) {
	localctx = NewStateMutabilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SolidityParserRULE_stateMutability)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-47)) & ^0x3f) == 0 && ((int64(1)<<(_la-47))&2097169) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverrideSpecifierContext is an interface to support dynamic dispatch.
type IOverrideSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identifierPath returns the _identifierPath rule contexts.
	Get_identifierPath() IIdentifierPathContext

	// Set_identifierPath sets the _identifierPath rule contexts.
	Set_identifierPath(IIdentifierPathContext)

	// GetOverrides returns the overrides rule context list.
	GetOverrides() []IIdentifierPathContext

	// SetOverrides sets the overrides rule context list.
	SetOverrides([]IIdentifierPathContext)

	// Getter signatures
	Override() antlr.TerminalNode
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	AllIdentifierPath() []IIdentifierPathContext
	IdentifierPath(i int) IIdentifierPathContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsOverrideSpecifierContext differentiates from other interfaces.
	IsOverrideSpecifierContext()
}

type OverrideSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_identifierPath IIdentifierPathContext
	overrides       []IIdentifierPathContext
}

func NewEmptyOverrideSpecifierContext() *OverrideSpecifierContext {
	var p = new(OverrideSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_overrideSpecifier
	return p
}

func InitEmptyOverrideSpecifierContext(p *OverrideSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_overrideSpecifier
}

func (*OverrideSpecifierContext) IsOverrideSpecifierContext() {}

func NewOverrideSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverrideSpecifierContext {
	var p = new(OverrideSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_overrideSpecifier

	return p
}

func (s *OverrideSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *OverrideSpecifierContext) Get_identifierPath() IIdentifierPathContext {
	return s._identifierPath
}

func (s *OverrideSpecifierContext) Set_identifierPath(v IIdentifierPathContext) {
	s._identifierPath = v
}

func (s *OverrideSpecifierContext) GetOverrides() []IIdentifierPathContext { return s.overrides }

func (s *OverrideSpecifierContext) SetOverrides(v []IIdentifierPathContext) { s.overrides = v }

func (s *OverrideSpecifierContext) Override() antlr.TerminalNode {
	return s.GetToken(SolidityParserOverride, 0)
}

func (s *OverrideSpecifierContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *OverrideSpecifierContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *OverrideSpecifierContext) AllIdentifierPath() []IIdentifierPathContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierPathContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierPathContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierPathContext); ok {
			tst[i] = t.(IIdentifierPathContext)
			i++
		}
	}

	return tst
}

func (s *OverrideSpecifierContext) IdentifierPath(i int) IIdentifierPathContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPathContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPathContext)
}

func (s *OverrideSpecifierContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *OverrideSpecifierContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *OverrideSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverrideSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverrideSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterOverrideSpecifier(s)
	}
}

func (s *OverrideSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitOverrideSpecifier(s)
	}
}

func (p *SolidityParser) OverrideSpecifier() (localctx IOverrideSpecifierContext) {
	localctx = NewOverrideSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SolidityParserRULE_overrideSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.Match(SolidityParserOverride)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(415)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(404)
			p.Match(SolidityParserLParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(405)

			var _x = p.IdentifierPath()

			localctx.(*OverrideSpecifierContext)._identifierPath = _x
		}
		localctx.(*OverrideSpecifierContext).overrides = append(localctx.(*OverrideSpecifierContext).overrides, localctx.(*OverrideSpecifierContext)._identifierPath)
		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserComma {
			{
				p.SetState(406)
				p.Match(SolidityParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(407)

				var _x = p.IdentifierPath()

				localctx.(*OverrideSpecifierContext)._identifierPath = _x
			}
			localctx.(*OverrideSpecifierContext).overrides = append(localctx.(*OverrideSpecifierContext).overrides, localctx.(*OverrideSpecifierContext)._identifierPath)

			p.SetState(412)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(413)
			p.Match(SolidityParserRParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetArguments returns the arguments rule contexts.
	GetArguments() IParameterListContext

	// GetReturnParameters returns the returnParameters rule contexts.
	GetReturnParameters() IParameterListContext

	// GetBody returns the body rule contexts.
	GetBody() IBlockContext

	// SetArguments sets the arguments rule contexts.
	SetArguments(IParameterListContext)

	// SetReturnParameters sets the returnParameters rule contexts.
	SetReturnParameters(IParameterListContext)

	// SetBody sets the body rule contexts.
	SetBody(IBlockContext)

	// GetVisibilitySet returns the visibilitySet attribute.
	GetVisibilitySet() bool

	// GetMutabilitySet returns the mutabilitySet attribute.
	GetMutabilitySet() bool

	// GetVirtualSet returns the virtualSet attribute.
	GetVirtualSet() bool

	// GetOverrideSpecifierSet returns the overrideSpecifierSet attribute.
	GetOverrideSpecifierSet() bool

	// SetVisibilitySet sets the visibilitySet attribute.
	SetVisibilitySet(bool)

	// SetMutabilitySet sets the mutabilitySet attribute.
	SetMutabilitySet(bool)

	// SetVirtualSet sets the virtualSet attribute.
	SetVirtualSet(bool)

	// SetOverrideSpecifierSet sets the overrideSpecifierSet attribute.
	SetOverrideSpecifierSet(bool)

	// Getter signatures
	Function() antlr.TerminalNode
	AllLParen() []antlr.TerminalNode
	LParen(i int) antlr.TerminalNode
	AllRParen() []antlr.TerminalNode
	RParen(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	Fallback() antlr.TerminalNode
	Receive() antlr.TerminalNode
	Semicolon() antlr.TerminalNode
	AllVisibility() []IVisibilityContext
	Visibility(i int) IVisibilityContext
	AllStateMutability() []IStateMutabilityContext
	StateMutability(i int) IStateMutabilityContext
	AllModifierInvocation() []IModifierInvocationContext
	ModifierInvocation(i int) IModifierInvocationContext
	AllVirtual() []antlr.TerminalNode
	Virtual(i int) antlr.TerminalNode
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext
	Returns() antlr.TerminalNode
	Block() IBlockContext
	AllParameterList() []IParameterListContext
	ParameterList(i int) IParameterListContext

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	visibilitySet        bool // TODO = false
	mutabilitySet        bool // TODO = false
	virtualSet           bool // TODO = false
	overrideSpecifierSet bool // TODO = false
	arguments            IParameterListContext
	returnParameters     IParameterListContext
	body                 IBlockContext
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDefinition
	return p
}

func InitEmptyFunctionDefinitionContext(p *FunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDefinition
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) GetArguments() IParameterListContext { return s.arguments }

func (s *FunctionDefinitionContext) GetReturnParameters() IParameterListContext {
	return s.returnParameters
}

func (s *FunctionDefinitionContext) GetBody() IBlockContext { return s.body }

func (s *FunctionDefinitionContext) SetArguments(v IParameterListContext) { s.arguments = v }

func (s *FunctionDefinitionContext) SetReturnParameters(v IParameterListContext) {
	s.returnParameters = v
}

func (s *FunctionDefinitionContext) SetBody(v IBlockContext) { s.body = v }

func (s *FunctionDefinitionContext) GetVisibilitySet() bool { return s.visibilitySet }

func (s *FunctionDefinitionContext) GetMutabilitySet() bool { return s.mutabilitySet }

func (s *FunctionDefinitionContext) GetVirtualSet() bool { return s.virtualSet }

func (s *FunctionDefinitionContext) GetOverrideSpecifierSet() bool { return s.overrideSpecifierSet }

func (s *FunctionDefinitionContext) SetVisibilitySet(v bool) { s.visibilitySet = v }

func (s *FunctionDefinitionContext) SetMutabilitySet(v bool) { s.mutabilitySet = v }

func (s *FunctionDefinitionContext) SetVirtualSet(v bool) { s.virtualSet = v }

func (s *FunctionDefinitionContext) SetOverrideSpecifierSet(v bool) { s.overrideSpecifierSet = v }

func (s *FunctionDefinitionContext) Function() antlr.TerminalNode {
	return s.GetToken(SolidityParserFunction, 0)
}

func (s *FunctionDefinitionContext) AllLParen() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserLParen)
}

func (s *FunctionDefinitionContext) LParen(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, i)
}

func (s *FunctionDefinitionContext) AllRParen() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserRParen)
}

func (s *FunctionDefinitionContext) RParen(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, i)
}

func (s *FunctionDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDefinitionContext) Fallback() antlr.TerminalNode {
	return s.GetToken(SolidityParserFallback, 0)
}

func (s *FunctionDefinitionContext) Receive() antlr.TerminalNode {
	return s.GetToken(SolidityParserReceive, 0)
}

func (s *FunctionDefinitionContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *FunctionDefinitionContext) AllVisibility() []IVisibilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVisibilityContext); ok {
			len++
		}
	}

	tst := make([]IVisibilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVisibilityContext); ok {
			tst[i] = t.(IVisibilityContext)
			i++
		}
	}

	return tst
}

func (s *FunctionDefinitionContext) Visibility(i int) IVisibilityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *FunctionDefinitionContext) AllStateMutability() []IStateMutabilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			len++
		}
	}

	tst := make([]IStateMutabilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStateMutabilityContext); ok {
			tst[i] = t.(IStateMutabilityContext)
			i++
		}
	}

	return tst
}

func (s *FunctionDefinitionContext) StateMutability(i int) IStateMutabilityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateMutabilityContext)
}

func (s *FunctionDefinitionContext) AllModifierInvocation() []IModifierInvocationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			len++
		}
	}

	tst := make([]IModifierInvocationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierInvocationContext); ok {
			tst[i] = t.(IModifierInvocationContext)
			i++
		}
	}

	return tst
}

func (s *FunctionDefinitionContext) ModifierInvocation(i int) IModifierInvocationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierInvocationContext)
}

func (s *FunctionDefinitionContext) AllVirtual() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtual)
}

func (s *FunctionDefinitionContext) Virtual(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtual, i)
}

func (s *FunctionDefinitionContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *FunctionDefinitionContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *FunctionDefinitionContext) Returns() antlr.TerminalNode {
	return s.GetToken(SolidityParserReturns, 0)
}

func (s *FunctionDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionDefinitionContext) AllParameterList() []IParameterListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterListContext); ok {
			len++
		}
	}

	tst := make([]IParameterListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterListContext); ok {
			tst[i] = t.(IParameterListContext)
			i++
		}
	}

	return tst
}

func (s *FunctionDefinitionContext) ParameterList(i int) IParameterListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterFunctionDefinition(s)
	}
}

func (s *FunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitFunctionDefinition(s)
	}
}

func (p *SolidityParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SolidityParserRULE_functionDefinition)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(417)
		p.Match(SolidityParserFunction)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserError, SolidityParserFrom, SolidityParserGlobal, SolidityParserRevert, SolidityParserIdentifier:
		{
			p.SetState(418)
			p.Identifier()
		}

	case SolidityParserFallback:
		{
			p.SetState(419)
			p.Match(SolidityParserFallback)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserReceive:
		{
			p.SetState(420)
			p.Match(SolidityParserReceive)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(423)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(425)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(424)

			var _x = p.ParameterList()

			localctx.(*FunctionDefinitionContext).arguments = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(427)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(444)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
			case 1:
				p.SetState(428)

				if !(!localctx.(*FunctionDefinitionContext).visibilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$visibilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(429)
					p.Visibility()
				}
				localctx.(*FunctionDefinitionContext).SetVisibilitySet(true)

			case 2:
				p.SetState(432)

				if !(!localctx.(*FunctionDefinitionContext).mutabilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$mutabilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(433)
					p.StateMutability()
				}
				localctx.(*FunctionDefinitionContext).SetMutabilitySet(true)

			case 3:
				{
					p.SetState(436)
					p.ModifierInvocation()
				}

			case 4:
				p.SetState(437)

				if !(!localctx.(*FunctionDefinitionContext).virtualSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$virtualSet", ""))
					goto errorExit
				}
				{
					p.SetState(438)
					p.Match(SolidityParserVirtual)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*FunctionDefinitionContext).SetVirtualSet(true)

			case 5:
				p.SetState(440)

				if !(!localctx.(*FunctionDefinitionContext).overrideSpecifierSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$overrideSpecifierSet", ""))
					goto errorExit
				}
				{
					p.SetState(441)
					p.OverrideSpecifier()
				}
				localctx.(*FunctionDefinitionContext).SetOverrideSpecifierSet(true)

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserReturns {
		{
			p.SetState(449)
			p.Match(SolidityParserReturns)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(450)
			p.Match(SolidityParserLParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(451)

			var _x = p.ParameterList()

			localctx.(*FunctionDefinitionContext).returnParameters = _x
		}
		{
			p.SetState(452)
			p.Match(SolidityParserRParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserSemicolon:
		{
			p.SetState(456)
			p.Match(SolidityParserSemicolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserLBrace:
		{
			p.SetState(457)

			var _x = p.Block()

			localctx.(*FunctionDefinitionContext).body = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifierDefinitionContext is an interface to support dynamic dispatch.
type IModifierDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetArguments returns the arguments rule contexts.
	GetArguments() IParameterListContext

	// GetBody returns the body rule contexts.
	GetBody() IBlockContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetArguments sets the arguments rule contexts.
	SetArguments(IParameterListContext)

	// SetBody sets the body rule contexts.
	SetBody(IBlockContext)

	// GetVirtualSet returns the virtualSet attribute.
	GetVirtualSet() bool

	// GetOverrideSpecifierSet returns the overrideSpecifierSet attribute.
	GetOverrideSpecifierSet() bool

	// SetVirtualSet sets the virtualSet attribute.
	SetVirtualSet(bool)

	// SetOverrideSpecifierSet sets the overrideSpecifierSet attribute.
	SetOverrideSpecifierSet(bool)

	// Getter signatures
	Modifier() antlr.TerminalNode
	Identifier() IIdentifierContext
	Semicolon() antlr.TerminalNode
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	AllVirtual() []antlr.TerminalNode
	Virtual(i int) antlr.TerminalNode
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext
	Block() IBlockContext
	ParameterList() IParameterListContext

	// IsModifierDefinitionContext differentiates from other interfaces.
	IsModifierDefinitionContext()
}

type ModifierDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	virtualSet           bool // TODO = false
	overrideSpecifierSet bool // TODO = false
	name                 IIdentifierContext
	arguments            IParameterListContext
	body                 IBlockContext
}

func NewEmptyModifierDefinitionContext() *ModifierDefinitionContext {
	var p = new(ModifierDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierDefinition
	return p
}

func InitEmptyModifierDefinitionContext(p *ModifierDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierDefinition
}

func (*ModifierDefinitionContext) IsModifierDefinitionContext() {}

func NewModifierDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierDefinitionContext {
	var p = new(ModifierDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierDefinition

	return p
}

func (s *ModifierDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *ModifierDefinitionContext) GetArguments() IParameterListContext { return s.arguments }

func (s *ModifierDefinitionContext) GetBody() IBlockContext { return s.body }

func (s *ModifierDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ModifierDefinitionContext) SetArguments(v IParameterListContext) { s.arguments = v }

func (s *ModifierDefinitionContext) SetBody(v IBlockContext) { s.body = v }

func (s *ModifierDefinitionContext) GetVirtualSet() bool { return s.virtualSet }

func (s *ModifierDefinitionContext) GetOverrideSpecifierSet() bool { return s.overrideSpecifierSet }

func (s *ModifierDefinitionContext) SetVirtualSet(v bool) { s.virtualSet = v }

func (s *ModifierDefinitionContext) SetOverrideSpecifierSet(v bool) { s.overrideSpecifierSet = v }

func (s *ModifierDefinitionContext) Modifier() antlr.TerminalNode {
	return s.GetToken(SolidityParserModifier, 0)
}

func (s *ModifierDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifierDefinitionContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *ModifierDefinitionContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *ModifierDefinitionContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *ModifierDefinitionContext) AllVirtual() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtual)
}

func (s *ModifierDefinitionContext) Virtual(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtual, i)
}

func (s *ModifierDefinitionContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifierDefinitionContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *ModifierDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ModifierDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ModifierDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterModifierDefinition(s)
	}
}

func (s *ModifierDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitModifierDefinition(s)
	}
}

func (p *SolidityParser) ModifierDefinition() (localctx IModifierDefinitionContext) {
	localctx = NewModifierDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SolidityParserRULE_modifierDefinition)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(460)
		p.Match(SolidityParserModifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(461)

		var _x = p.Identifier()

		localctx.(*ModifierDefinitionContext).name = _x
	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(462)
			p.Match(SolidityParserLParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(463)

				var _x = p.ParameterList()

				localctx.(*ModifierDefinitionContext).arguments = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(466)
			p.Match(SolidityParserRParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(476)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
			case 1:
				p.SetState(469)

				if !(!localctx.(*ModifierDefinitionContext).virtualSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$virtualSet", ""))
					goto errorExit
				}
				{
					p.SetState(470)
					p.Match(SolidityParserVirtual)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ModifierDefinitionContext).SetVirtualSet(true)

			case 2:
				p.SetState(472)

				if !(!localctx.(*ModifierDefinitionContext).overrideSpecifierSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$overrideSpecifierSet", ""))
					goto errorExit
				}
				{
					p.SetState(473)
					p.OverrideSpecifier()
				}
				localctx.(*ModifierDefinitionContext).SetOverrideSpecifierSet(true)

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserSemicolon:
		{
			p.SetState(481)
			p.Match(SolidityParserSemicolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserLBrace:
		{
			p.SetState(482)

			var _x = p.Block()

			localctx.(*ModifierDefinitionContext).body = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFallbackFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFallbackFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// GetReturnParameters returns the returnParameters rule contexts.
	GetReturnParameters() IParameterListContext

	// GetBody returns the body rule contexts.
	GetBody() IBlockContext

	// SetReturnParameters sets the returnParameters rule contexts.
	SetReturnParameters(IParameterListContext)

	// SetBody sets the body rule contexts.
	SetBody(IBlockContext)

	// GetVisibilitySet returns the visibilitySet attribute.
	GetVisibilitySet() bool

	// GetMutabilitySet returns the mutabilitySet attribute.
	GetMutabilitySet() bool

	// GetVirtualSet returns the virtualSet attribute.
	GetVirtualSet() bool

	// GetOverrideSpecifierSet returns the overrideSpecifierSet attribute.
	GetOverrideSpecifierSet() bool

	// GetHasParameters returns the hasParameters attribute.
	GetHasParameters() bool

	// SetVisibilitySet sets the visibilitySet attribute.
	SetVisibilitySet(bool)

	// SetMutabilitySet sets the mutabilitySet attribute.
	SetMutabilitySet(bool)

	// SetVirtualSet sets the virtualSet attribute.
	SetVirtualSet(bool)

	// SetOverrideSpecifierSet sets the overrideSpecifierSet attribute.
	SetOverrideSpecifierSet(bool)

	// SetHasParameters sets the hasParameters attribute.
	SetHasParameters(bool)

	// Getter signatures
	AllLParen() []antlr.TerminalNode
	LParen(i int) antlr.TerminalNode
	AllRParen() []antlr.TerminalNode
	RParen(i int) antlr.TerminalNode
	Fallback() antlr.TerminalNode
	Returns() antlr.TerminalNode
	Semicolon() antlr.TerminalNode
	AllParameterList() []IParameterListContext
	ParameterList(i int) IParameterListContext
	AllExternal() []antlr.TerminalNode
	External(i int) antlr.TerminalNode
	AllStateMutability() []IStateMutabilityContext
	StateMutability(i int) IStateMutabilityContext
	AllModifierInvocation() []IModifierInvocationContext
	ModifierInvocation(i int) IModifierInvocationContext
	AllVirtual() []antlr.TerminalNode
	Virtual(i int) antlr.TerminalNode
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext
	Block() IBlockContext

	// IsFallbackFunctionDefinitionContext differentiates from other interfaces.
	IsFallbackFunctionDefinitionContext()
}

type FallbackFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	visibilitySet        bool // TODO = false
	mutabilitySet        bool // TODO = false
	virtualSet           bool // TODO = false
	overrideSpecifierSet bool // TODO = false
	hasParameters        bool // TODO = false
	kind                 antlr.Token
	returnParameters     IParameterListContext
	body                 IBlockContext
}

func NewEmptyFallbackFunctionDefinitionContext() *FallbackFunctionDefinitionContext {
	var p = new(FallbackFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_fallbackFunctionDefinition
	return p
}

func InitEmptyFallbackFunctionDefinitionContext(p *FallbackFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_fallbackFunctionDefinition
}

func (*FallbackFunctionDefinitionContext) IsFallbackFunctionDefinitionContext() {}

func NewFallbackFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FallbackFunctionDefinitionContext {
	var p = new(FallbackFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_fallbackFunctionDefinition

	return p
}

func (s *FallbackFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FallbackFunctionDefinitionContext) GetKind() antlr.Token { return s.kind }

func (s *FallbackFunctionDefinitionContext) SetKind(v antlr.Token) { s.kind = v }

func (s *FallbackFunctionDefinitionContext) GetReturnParameters() IParameterListContext {
	return s.returnParameters
}

func (s *FallbackFunctionDefinitionContext) GetBody() IBlockContext { return s.body }

func (s *FallbackFunctionDefinitionContext) SetReturnParameters(v IParameterListContext) {
	s.returnParameters = v
}

func (s *FallbackFunctionDefinitionContext) SetBody(v IBlockContext) { s.body = v }

func (s *FallbackFunctionDefinitionContext) GetVisibilitySet() bool { return s.visibilitySet }

func (s *FallbackFunctionDefinitionContext) GetMutabilitySet() bool { return s.mutabilitySet }

func (s *FallbackFunctionDefinitionContext) GetVirtualSet() bool { return s.virtualSet }

func (s *FallbackFunctionDefinitionContext) GetOverrideSpecifierSet() bool {
	return s.overrideSpecifierSet
}

func (s *FallbackFunctionDefinitionContext) GetHasParameters() bool { return s.hasParameters }

func (s *FallbackFunctionDefinitionContext) SetVisibilitySet(v bool) { s.visibilitySet = v }

func (s *FallbackFunctionDefinitionContext) SetMutabilitySet(v bool) { s.mutabilitySet = v }

func (s *FallbackFunctionDefinitionContext) SetVirtualSet(v bool) { s.virtualSet = v }

func (s *FallbackFunctionDefinitionContext) SetOverrideSpecifierSet(v bool) {
	s.overrideSpecifierSet = v
}

func (s *FallbackFunctionDefinitionContext) SetHasParameters(v bool) { s.hasParameters = v }

func (s *FallbackFunctionDefinitionContext) AllLParen() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserLParen)
}

func (s *FallbackFunctionDefinitionContext) LParen(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, i)
}

func (s *FallbackFunctionDefinitionContext) AllRParen() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserRParen)
}

func (s *FallbackFunctionDefinitionContext) RParen(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, i)
}

func (s *FallbackFunctionDefinitionContext) Fallback() antlr.TerminalNode {
	return s.GetToken(SolidityParserFallback, 0)
}

func (s *FallbackFunctionDefinitionContext) Returns() antlr.TerminalNode {
	return s.GetToken(SolidityParserReturns, 0)
}

func (s *FallbackFunctionDefinitionContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *FallbackFunctionDefinitionContext) AllParameterList() []IParameterListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterListContext); ok {
			len++
		}
	}

	tst := make([]IParameterListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterListContext); ok {
			tst[i] = t.(IParameterListContext)
			i++
		}
	}

	return tst
}

func (s *FallbackFunctionDefinitionContext) ParameterList(i int) IParameterListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FallbackFunctionDefinitionContext) AllExternal() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserExternal)
}

func (s *FallbackFunctionDefinitionContext) External(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserExternal, i)
}

func (s *FallbackFunctionDefinitionContext) AllStateMutability() []IStateMutabilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			len++
		}
	}

	tst := make([]IStateMutabilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStateMutabilityContext); ok {
			tst[i] = t.(IStateMutabilityContext)
			i++
		}
	}

	return tst
}

func (s *FallbackFunctionDefinitionContext) StateMutability(i int) IStateMutabilityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateMutabilityContext)
}

func (s *FallbackFunctionDefinitionContext) AllModifierInvocation() []IModifierInvocationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			len++
		}
	}

	tst := make([]IModifierInvocationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierInvocationContext); ok {
			tst[i] = t.(IModifierInvocationContext)
			i++
		}
	}

	return tst
}

func (s *FallbackFunctionDefinitionContext) ModifierInvocation(i int) IModifierInvocationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierInvocationContext)
}

func (s *FallbackFunctionDefinitionContext) AllVirtual() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtual)
}

func (s *FallbackFunctionDefinitionContext) Virtual(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtual, i)
}

func (s *FallbackFunctionDefinitionContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *FallbackFunctionDefinitionContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *FallbackFunctionDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FallbackFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FallbackFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FallbackFunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterFallbackFunctionDefinition(s)
	}
}

func (s *FallbackFunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitFallbackFunctionDefinition(s)
	}
}

func (p *SolidityParser) FallbackFunctionDefinition() (localctx IFallbackFunctionDefinitionContext) {
	localctx = NewFallbackFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SolidityParserRULE_fallbackFunctionDefinition)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)

		var _m = p.Match(SolidityParserFallback)

		localctx.(*FallbackFunctionDefinitionContext).kind = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(486)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(490)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(487)
			p.ParameterList()
		}
		localctx.(*FallbackFunctionDefinitionContext).SetHasParameters(true)

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(492)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(508)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) {
			case 1:
				p.SetState(493)

				if !(!localctx.(*FallbackFunctionDefinitionContext).visibilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$visibilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(494)
					p.Match(SolidityParserExternal)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*FallbackFunctionDefinitionContext).SetVisibilitySet(true)

			case 2:
				p.SetState(496)

				if !(!localctx.(*FallbackFunctionDefinitionContext).mutabilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$mutabilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(497)
					p.StateMutability()
				}
				localctx.(*FallbackFunctionDefinitionContext).SetMutabilitySet(true)

			case 3:
				{
					p.SetState(500)
					p.ModifierInvocation()
				}

			case 4:
				p.SetState(501)

				if !(!localctx.(*FallbackFunctionDefinitionContext).virtualSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$virtualSet", ""))
					goto errorExit
				}
				{
					p.SetState(502)
					p.Match(SolidityParserVirtual)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*FallbackFunctionDefinitionContext).SetVirtualSet(true)

			case 5:
				p.SetState(504)

				if !(!localctx.(*FallbackFunctionDefinitionContext).overrideSpecifierSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$overrideSpecifierSet", ""))
					goto errorExit
				}
				{
					p.SetState(505)
					p.OverrideSpecifier()
				}
				localctx.(*FallbackFunctionDefinitionContext).SetOverrideSpecifierSet(true)

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(512)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.SetState(513)

		if !(localctx.(*FallbackFunctionDefinitionContext).hasParameters) {
			p.SetError(antlr.NewFailedPredicateException(p, "$hasParameters", ""))
			goto errorExit
		}
		{
			p.SetState(514)
			p.Match(SolidityParserReturns)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(515)
			p.Match(SolidityParserLParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(516)

			var _x = p.ParameterList()

			localctx.(*FallbackFunctionDefinitionContext).returnParameters = _x
		}
		{
			p.SetState(517)
			p.Match(SolidityParserRParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.SetState(519)

		if !(!localctx.(*FallbackFunctionDefinitionContext).hasParameters) {
			p.SetError(antlr.NewFailedPredicateException(p, "!$hasParameters", ""))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserSemicolon:
		{
			p.SetState(522)
			p.Match(SolidityParserSemicolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserLBrace:
		{
			p.SetState(523)

			var _x = p.Block()

			localctx.(*FallbackFunctionDefinitionContext).body = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReceiveFunctionDefinitionContext is an interface to support dynamic dispatch.
type IReceiveFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// GetBody returns the body rule contexts.
	GetBody() IBlockContext

	// SetBody sets the body rule contexts.
	SetBody(IBlockContext)

	// GetVisibilitySet returns the visibilitySet attribute.
	GetVisibilitySet() bool

	// GetMutabilitySet returns the mutabilitySet attribute.
	GetMutabilitySet() bool

	// GetVirtualSet returns the virtualSet attribute.
	GetVirtualSet() bool

	// GetOverrideSpecifierSet returns the overrideSpecifierSet attribute.
	GetOverrideSpecifierSet() bool

	// SetVisibilitySet sets the visibilitySet attribute.
	SetVisibilitySet(bool)

	// SetMutabilitySet sets the mutabilitySet attribute.
	SetMutabilitySet(bool)

	// SetVirtualSet sets the virtualSet attribute.
	SetVirtualSet(bool)

	// SetOverrideSpecifierSet sets the overrideSpecifierSet attribute.
	SetOverrideSpecifierSet(bool)

	// Getter signatures
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	Receive() antlr.TerminalNode
	Semicolon() antlr.TerminalNode
	AllExternal() []antlr.TerminalNode
	External(i int) antlr.TerminalNode
	AllPayable() []antlr.TerminalNode
	Payable(i int) antlr.TerminalNode
	AllModifierInvocation() []IModifierInvocationContext
	ModifierInvocation(i int) IModifierInvocationContext
	AllVirtual() []antlr.TerminalNode
	Virtual(i int) antlr.TerminalNode
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext
	Block() IBlockContext

	// IsReceiveFunctionDefinitionContext differentiates from other interfaces.
	IsReceiveFunctionDefinitionContext()
}

type ReceiveFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	visibilitySet        bool // TODO = false
	mutabilitySet        bool // TODO = false
	virtualSet           bool // TODO = false
	overrideSpecifierSet bool // TODO = false
	kind                 antlr.Token
	body                 IBlockContext
}

func NewEmptyReceiveFunctionDefinitionContext() *ReceiveFunctionDefinitionContext {
	var p = new(ReceiveFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_receiveFunctionDefinition
	return p
}

func InitEmptyReceiveFunctionDefinitionContext(p *ReceiveFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_receiveFunctionDefinition
}

func (*ReceiveFunctionDefinitionContext) IsReceiveFunctionDefinitionContext() {}

func NewReceiveFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveFunctionDefinitionContext {
	var p = new(ReceiveFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_receiveFunctionDefinition

	return p
}

func (s *ReceiveFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveFunctionDefinitionContext) GetKind() antlr.Token { return s.kind }

func (s *ReceiveFunctionDefinitionContext) SetKind(v antlr.Token) { s.kind = v }

func (s *ReceiveFunctionDefinitionContext) GetBody() IBlockContext { return s.body }

func (s *ReceiveFunctionDefinitionContext) SetBody(v IBlockContext) { s.body = v }

func (s *ReceiveFunctionDefinitionContext) GetVisibilitySet() bool { return s.visibilitySet }

func (s *ReceiveFunctionDefinitionContext) GetMutabilitySet() bool { return s.mutabilitySet }

func (s *ReceiveFunctionDefinitionContext) GetVirtualSet() bool { return s.virtualSet }

func (s *ReceiveFunctionDefinitionContext) GetOverrideSpecifierSet() bool {
	return s.overrideSpecifierSet
}

func (s *ReceiveFunctionDefinitionContext) SetVisibilitySet(v bool) { s.visibilitySet = v }

func (s *ReceiveFunctionDefinitionContext) SetMutabilitySet(v bool) { s.mutabilitySet = v }

func (s *ReceiveFunctionDefinitionContext) SetVirtualSet(v bool) { s.virtualSet = v }

func (s *ReceiveFunctionDefinitionContext) SetOverrideSpecifierSet(v bool) {
	s.overrideSpecifierSet = v
}

func (s *ReceiveFunctionDefinitionContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *ReceiveFunctionDefinitionContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *ReceiveFunctionDefinitionContext) Receive() antlr.TerminalNode {
	return s.GetToken(SolidityParserReceive, 0)
}

func (s *ReceiveFunctionDefinitionContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *ReceiveFunctionDefinitionContext) AllExternal() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserExternal)
}

func (s *ReceiveFunctionDefinitionContext) External(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserExternal, i)
}

func (s *ReceiveFunctionDefinitionContext) AllPayable() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPayable)
}

func (s *ReceiveFunctionDefinitionContext) Payable(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPayable, i)
}

func (s *ReceiveFunctionDefinitionContext) AllModifierInvocation() []IModifierInvocationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			len++
		}
	}

	tst := make([]IModifierInvocationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierInvocationContext); ok {
			tst[i] = t.(IModifierInvocationContext)
			i++
		}
	}

	return tst
}

func (s *ReceiveFunctionDefinitionContext) ModifierInvocation(i int) IModifierInvocationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierInvocationContext)
}

func (s *ReceiveFunctionDefinitionContext) AllVirtual() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtual)
}

func (s *ReceiveFunctionDefinitionContext) Virtual(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtual, i)
}

func (s *ReceiveFunctionDefinitionContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ReceiveFunctionDefinitionContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *ReceiveFunctionDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ReceiveFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveFunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterReceiveFunctionDefinition(s)
	}
}

func (s *ReceiveFunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitReceiveFunctionDefinition(s)
	}
}

func (p *SolidityParser) ReceiveFunctionDefinition() (localctx IReceiveFunctionDefinitionContext) {
	localctx = NewReceiveFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SolidityParserRULE_receiveFunctionDefinition)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)

		var _m = p.Match(SolidityParserReceive)

		localctx.(*ReceiveFunctionDefinitionContext).kind = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(527)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(528)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(543)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
			case 1:
				p.SetState(529)

				if !(!localctx.(*ReceiveFunctionDefinitionContext).visibilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$visibilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(530)
					p.Match(SolidityParserExternal)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ReceiveFunctionDefinitionContext).SetVisibilitySet(true)

			case 2:
				p.SetState(532)

				if !(!localctx.(*ReceiveFunctionDefinitionContext).mutabilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$mutabilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(533)
					p.Match(SolidityParserPayable)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ReceiveFunctionDefinitionContext).SetMutabilitySet(true)

			case 3:
				{
					p.SetState(535)
					p.ModifierInvocation()
				}

			case 4:
				p.SetState(536)

				if !(!localctx.(*ReceiveFunctionDefinitionContext).virtualSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$virtualSet", ""))
					goto errorExit
				}
				{
					p.SetState(537)
					p.Match(SolidityParserVirtual)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ReceiveFunctionDefinitionContext).SetVirtualSet(true)

			case 5:
				p.SetState(539)

				if !(!localctx.(*ReceiveFunctionDefinitionContext).overrideSpecifierSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$overrideSpecifierSet", ""))
					goto errorExit
				}
				{
					p.SetState(540)
					p.OverrideSpecifier()
				}
				localctx.(*ReceiveFunctionDefinitionContext).SetOverrideSpecifierSet(true)

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserSemicolon:
		{
			p.SetState(548)
			p.Match(SolidityParserSemicolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserLBrace:
		{
			p.SetState(549)

			var _x = p.Block()

			localctx.(*ReceiveFunctionDefinitionContext).body = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructDefinitionContext is an interface to support dynamic dispatch.
type IStructDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetMembers returns the members rule contexts.
	GetMembers() IStructMemberContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetMembers sets the members rule contexts.
	SetMembers(IStructMemberContext)

	// Getter signatures
	Struct() antlr.TerminalNode
	LBrace() antlr.TerminalNode
	RBrace() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllStructMember() []IStructMemberContext
	StructMember(i int) IStructMemberContext

	// IsStructDefinitionContext differentiates from other interfaces.
	IsStructDefinitionContext()
}

type StructDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	name    IIdentifierContext
	members IStructMemberContext
}

func NewEmptyStructDefinitionContext() *StructDefinitionContext {
	var p = new(StructDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_structDefinition
	return p
}

func InitEmptyStructDefinitionContext(p *StructDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_structDefinition
}

func (*StructDefinitionContext) IsStructDefinitionContext() {}

func NewStructDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDefinitionContext {
	var p = new(StructDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_structDefinition

	return p
}

func (s *StructDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *StructDefinitionContext) GetMembers() IStructMemberContext { return s.members }

func (s *StructDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *StructDefinitionContext) SetMembers(v IStructMemberContext) { s.members = v }

func (s *StructDefinitionContext) Struct() antlr.TerminalNode {
	return s.GetToken(SolidityParserStruct, 0)
}

func (s *StructDefinitionContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *StructDefinitionContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *StructDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructDefinitionContext) AllStructMember() []IStructMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructMemberContext); ok {
			len++
		}
	}

	tst := make([]IStructMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructMemberContext); ok {
			tst[i] = t.(IStructMemberContext)
			i++
		}
	}

	return tst
}

func (s *StructDefinitionContext) StructMember(i int) IStructMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructMemberContext)
}

func (s *StructDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterStructDefinition(s)
	}
}

func (s *StructDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitStructDefinition(s)
	}
}

func (p *SolidityParser) StructDefinition() (localctx IStructDefinitionContext) {
	localctx = NewStructDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SolidityParserRULE_structDefinition)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Match(SolidityParserStruct)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(553)

		var _x = p.Identifier()

		localctx.(*StructDefinitionContext).name = _x
	}
	{
		p.SetState(554)
		p.Match(SolidityParserLBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(555)

				var _x = p.StructMember()

				localctx.(*StructDefinitionContext).members = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(560)
		p.Match(SolidityParserRBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructMemberContext is an interface to support dynamic dispatch.
type IStructMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	Semicolon() antlr.TerminalNode
	TypeName() ITypeNameContext
	Identifier() IIdentifierContext

	// IsStructMemberContext differentiates from other interfaces.
	IsStructMemberContext()
}

type StructMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  ITypeNameContext
	name   IIdentifierContext
}

func NewEmptyStructMemberContext() *StructMemberContext {
	var p = new(StructMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_structMember
	return p
}

func InitEmptyStructMemberContext(p *StructMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_structMember
}

func (*StructMemberContext) IsStructMemberContext() {}

func NewStructMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructMemberContext {
	var p = new(StructMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_structMember

	return p
}

func (s *StructMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *StructMemberContext) GetType_() ITypeNameContext { return s.type_ }

func (s *StructMemberContext) GetName() IIdentifierContext { return s.name }

func (s *StructMemberContext) SetType_(v ITypeNameContext) { s.type_ = v }

func (s *StructMemberContext) SetName(v IIdentifierContext) { s.name = v }

func (s *StructMemberContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *StructMemberContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StructMemberContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterStructMember(s)
	}
}

func (s *StructMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitStructMember(s)
	}
}

func (p *SolidityParser) StructMember() (localctx IStructMemberContext) {
	localctx = NewStructMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SolidityParserRULE_structMember)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)

		var _x = p.typeName(0)

		localctx.(*StructMemberContext).type_ = _x
	}
	{
		p.SetState(563)

		var _x = p.Identifier()

		localctx.(*StructMemberContext).name = _x
	}
	{
		p.SetState(564)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDefinitionContext is an interface to support dynamic dispatch.
type IEnumDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// GetEnumValues returns the enumValues rule context list.
	GetEnumValues() []IIdentifierContext

	// SetEnumValues sets the enumValues rule context list.
	SetEnumValues([]IIdentifierContext)

	// Getter signatures
	Enum() antlr.TerminalNode
	LBrace() antlr.TerminalNode
	RBrace() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsEnumDefinitionContext differentiates from other interfaces.
	IsEnumDefinitionContext()
}

type EnumDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	name        IIdentifierContext
	_identifier IIdentifierContext
	enumValues  []IIdentifierContext
}

func NewEmptyEnumDefinitionContext() *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_enumDefinition
	return p
}

func InitEmptyEnumDefinitionContext(p *EnumDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_enumDefinition
}

func (*EnumDefinitionContext) IsEnumDefinitionContext() {}

func NewEnumDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_enumDefinition

	return p
}

func (s *EnumDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *EnumDefinitionContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *EnumDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *EnumDefinitionContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *EnumDefinitionContext) GetEnumValues() []IIdentifierContext { return s.enumValues }

func (s *EnumDefinitionContext) SetEnumValues(v []IIdentifierContext) { s.enumValues = v }

func (s *EnumDefinitionContext) Enum() antlr.TerminalNode {
	return s.GetToken(SolidityParserEnum, 0)
}

func (s *EnumDefinitionContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *EnumDefinitionContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *EnumDefinitionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *EnumDefinitionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDefinitionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *EnumDefinitionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *EnumDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterEnumDefinition(s)
	}
}

func (s *EnumDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitEnumDefinition(s)
	}
}

func (p *SolidityParser) EnumDefinition() (localctx IEnumDefinitionContext) {
	localctx = NewEnumDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SolidityParserRULE_enumDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(SolidityParserEnum)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(567)

		var _x = p.Identifier()

		localctx.(*EnumDefinitionContext).name = _x
	}
	{
		p.SetState(568)
		p.Match(SolidityParserLBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(569)

		var _x = p.Identifier()

		localctx.(*EnumDefinitionContext)._identifier = _x
	}
	localctx.(*EnumDefinitionContext).enumValues = append(localctx.(*EnumDefinitionContext).enumValues, localctx.(*EnumDefinitionContext)._identifier)
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserComma {
		{
			p.SetState(570)
			p.Match(SolidityParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(571)

			var _x = p.Identifier()

			localctx.(*EnumDefinitionContext)._identifier = _x
		}
		localctx.(*EnumDefinitionContext).enumValues = append(localctx.(*EnumDefinitionContext).enumValues, localctx.(*EnumDefinitionContext)._identifier)

		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(577)
		p.Match(SolidityParserRBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserDefinedValueTypeDefinitionContext is an interface to support dynamic dispatch.
type IUserDefinedValueTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	Type() antlr.TerminalNode
	Is() antlr.TerminalNode
	ElementaryTypeName() IElementaryTypeNameContext
	Semicolon() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsUserDefinedValueTypeDefinitionContext differentiates from other interfaces.
	IsUserDefinedValueTypeDefinitionContext()
}

type UserDefinedValueTypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyUserDefinedValueTypeDefinitionContext() *UserDefinedValueTypeDefinitionContext {
	var p = new(UserDefinedValueTypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_userDefinedValueTypeDefinition
	return p
}

func InitEmptyUserDefinedValueTypeDefinitionContext(p *UserDefinedValueTypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_userDefinedValueTypeDefinition
}

func (*UserDefinedValueTypeDefinitionContext) IsUserDefinedValueTypeDefinitionContext() {}

func NewUserDefinedValueTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedValueTypeDefinitionContext {
	var p = new(UserDefinedValueTypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_userDefinedValueTypeDefinition

	return p
}

func (s *UserDefinedValueTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedValueTypeDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *UserDefinedValueTypeDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *UserDefinedValueTypeDefinitionContext) Type() antlr.TerminalNode {
	return s.GetToken(SolidityParserType, 0)
}

func (s *UserDefinedValueTypeDefinitionContext) Is() antlr.TerminalNode {
	return s.GetToken(SolidityParserIs, 0)
}

func (s *UserDefinedValueTypeDefinitionContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *UserDefinedValueTypeDefinitionContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *UserDefinedValueTypeDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UserDefinedValueTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedValueTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinedValueTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterUserDefinedValueTypeDefinition(s)
	}
}

func (s *UserDefinedValueTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitUserDefinedValueTypeDefinition(s)
	}
}

func (p *SolidityParser) UserDefinedValueTypeDefinition() (localctx IUserDefinedValueTypeDefinitionContext) {
	localctx = NewUserDefinedValueTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SolidityParserRULE_userDefinedValueTypeDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(SolidityParserType)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(580)

		var _x = p.Identifier()

		localctx.(*UserDefinedValueTypeDefinitionContext).name = _x
	}
	{
		p.SetState(581)
		p.Match(SolidityParserIs)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(582)
		p.ElementaryTypeName(true)
	}
	{
		p.SetState(583)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStateVariableDeclarationContext is an interface to support dynamic dispatch.
type IStateVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetInitialValue returns the initialValue rule contexts.
	GetInitialValue() IExpressionContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetInitialValue sets the initialValue rule contexts.
	SetInitialValue(IExpressionContext)

	// GetConstantnessSet returns the constantnessSet attribute.
	GetConstantnessSet() bool

	// GetVisibilitySet returns the visibilitySet attribute.
	GetVisibilitySet() bool

	// GetOverrideSpecifierSet returns the overrideSpecifierSet attribute.
	GetOverrideSpecifierSet() bool

	// SetConstantnessSet sets the constantnessSet attribute.
	SetConstantnessSet(bool)

	// SetVisibilitySet sets the visibilitySet attribute.
	SetVisibilitySet(bool)

	// SetOverrideSpecifierSet sets the overrideSpecifierSet attribute.
	SetOverrideSpecifierSet(bool)

	// Getter signatures
	Semicolon() antlr.TerminalNode
	TypeName() ITypeNameContext
	Identifier() IIdentifierContext
	AllPublic() []antlr.TerminalNode
	Public(i int) antlr.TerminalNode
	AllPrivate() []antlr.TerminalNode
	Private(i int) antlr.TerminalNode
	AllInternal() []antlr.TerminalNode
	Internal(i int) antlr.TerminalNode
	AllConstant() []antlr.TerminalNode
	Constant(i int) antlr.TerminalNode
	AllOverrideSpecifier() []IOverrideSpecifierContext
	OverrideSpecifier(i int) IOverrideSpecifierContext
	AllImmutable() []antlr.TerminalNode
	Immutable(i int) antlr.TerminalNode
	Assign() antlr.TerminalNode
	Expression() IExpressionContext

	// IsStateVariableDeclarationContext differentiates from other interfaces.
	IsStateVariableDeclarationContext()
}

type StateVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	constantnessSet      bool // TODO = false
	visibilitySet        bool // TODO = false
	overrideSpecifierSet bool // TODO = false
	type_                ITypeNameContext
	name                 IIdentifierContext
	initialValue         IExpressionContext
}

func NewEmptyStateVariableDeclarationContext() *StateVariableDeclarationContext {
	var p = new(StateVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration
	return p
}

func InitEmptyStateVariableDeclarationContext(p *StateVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration
}

func (*StateVariableDeclarationContext) IsStateVariableDeclarationContext() {}

func NewStateVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StateVariableDeclarationContext {
	var p = new(StateVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration

	return p
}

func (s *StateVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StateVariableDeclarationContext) GetType_() ITypeNameContext { return s.type_ }

func (s *StateVariableDeclarationContext) GetName() IIdentifierContext { return s.name }

func (s *StateVariableDeclarationContext) GetInitialValue() IExpressionContext { return s.initialValue }

func (s *StateVariableDeclarationContext) SetType_(v ITypeNameContext) { s.type_ = v }

func (s *StateVariableDeclarationContext) SetName(v IIdentifierContext) { s.name = v }

func (s *StateVariableDeclarationContext) SetInitialValue(v IExpressionContext) { s.initialValue = v }

func (s *StateVariableDeclarationContext) GetConstantnessSet() bool { return s.constantnessSet }

func (s *StateVariableDeclarationContext) GetVisibilitySet() bool { return s.visibilitySet }

func (s *StateVariableDeclarationContext) GetOverrideSpecifierSet() bool {
	return s.overrideSpecifierSet
}

func (s *StateVariableDeclarationContext) SetConstantnessSet(v bool) { s.constantnessSet = v }

func (s *StateVariableDeclarationContext) SetVisibilitySet(v bool) { s.visibilitySet = v }

func (s *StateVariableDeclarationContext) SetOverrideSpecifierSet(v bool) {
	s.overrideSpecifierSet = v
}

func (s *StateVariableDeclarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *StateVariableDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StateVariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StateVariableDeclarationContext) AllPublic() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPublic)
}

func (s *StateVariableDeclarationContext) Public(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPublic, i)
}

func (s *StateVariableDeclarationContext) AllPrivate() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPrivate)
}

func (s *StateVariableDeclarationContext) Private(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPrivate, i)
}

func (s *StateVariableDeclarationContext) AllInternal() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternal)
}

func (s *StateVariableDeclarationContext) Internal(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternal, i)
}

func (s *StateVariableDeclarationContext) AllConstant() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserConstant)
}

func (s *StateVariableDeclarationContext) Constant(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserConstant, i)
}

func (s *StateVariableDeclarationContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *StateVariableDeclarationContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *StateVariableDeclarationContext) AllImmutable() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserImmutable)
}

func (s *StateVariableDeclarationContext) Immutable(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserImmutable, i)
}

func (s *StateVariableDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssign, 0)
}

func (s *StateVariableDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StateVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StateVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StateVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterStateVariableDeclaration(s)
	}
}

func (s *StateVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitStateVariableDeclaration(s)
	}
}

func (p *SolidityParser) StateVariableDeclaration() (localctx IStateVariableDeclarationContext) {
	localctx = NewStateVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SolidityParserRULE_stateVariableDeclaration)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)

		var _x = p.typeName(0)

		localctx.(*StateVariableDeclarationContext).type_ = _x
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(605)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
			case 1:
				p.SetState(586)

				if !(!localctx.(*StateVariableDeclarationContext).visibilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$visibilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(587)
					p.Match(SolidityParserPublic)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*StateVariableDeclarationContext).SetVisibilitySet(true)

			case 2:
				p.SetState(589)

				if !(!localctx.(*StateVariableDeclarationContext).visibilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$visibilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(590)
					p.Match(SolidityParserPrivate)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*StateVariableDeclarationContext).SetVisibilitySet(true)

			case 3:
				p.SetState(592)

				if !(!localctx.(*StateVariableDeclarationContext).visibilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$visibilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(593)
					p.Match(SolidityParserInternal)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*StateVariableDeclarationContext).SetVisibilitySet(true)

			case 4:
				p.SetState(595)

				if !(!localctx.(*StateVariableDeclarationContext).constantnessSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$constantnessSet", ""))
					goto errorExit
				}
				{
					p.SetState(596)
					p.Match(SolidityParserConstant)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*StateVariableDeclarationContext).SetConstantnessSet(true)

			case 5:
				p.SetState(598)

				if !(!localctx.(*StateVariableDeclarationContext).overrideSpecifierSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$overrideSpecifierSet", ""))
					goto errorExit
				}
				{
					p.SetState(599)
					p.OverrideSpecifier()
				}
				localctx.(*StateVariableDeclarationContext).SetOverrideSpecifierSet(true)

			case 6:
				p.SetState(602)

				if !(!localctx.(*StateVariableDeclarationContext).constantnessSet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$constantnessSet", ""))
					goto errorExit
				}
				{
					p.SetState(603)
					p.Match(SolidityParserImmutable)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*StateVariableDeclarationContext).SetConstantnessSet(true)

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(610)

		var _x = p.Identifier()

		localctx.(*StateVariableDeclarationContext).name = _x
	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserAssign {
		{
			p.SetState(611)
			p.Match(SolidityParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)

			var _x = p.expression(0)

			localctx.(*StateVariableDeclarationContext).initialValue = _x
		}

	}
	{
		p.SetState(615)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantVariableDeclarationContext is an interface to support dynamic dispatch.
type IConstantVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetInitialValue returns the initialValue rule contexts.
	GetInitialValue() IExpressionContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetInitialValue sets the initialValue rule contexts.
	SetInitialValue(IExpressionContext)

	// Getter signatures
	Constant() antlr.TerminalNode
	Assign() antlr.TerminalNode
	Semicolon() antlr.TerminalNode
	TypeName() ITypeNameContext
	Identifier() IIdentifierContext
	Expression() IExpressionContext

	// IsConstantVariableDeclarationContext differentiates from other interfaces.
	IsConstantVariableDeclarationContext()
}

type ConstantVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	type_        ITypeNameContext
	name         IIdentifierContext
	initialValue IExpressionContext
}

func NewEmptyConstantVariableDeclarationContext() *ConstantVariableDeclarationContext {
	var p = new(ConstantVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_constantVariableDeclaration
	return p
}

func InitEmptyConstantVariableDeclarationContext(p *ConstantVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_constantVariableDeclaration
}

func (*ConstantVariableDeclarationContext) IsConstantVariableDeclarationContext() {}

func NewConstantVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantVariableDeclarationContext {
	var p = new(ConstantVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_constantVariableDeclaration

	return p
}

func (s *ConstantVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantVariableDeclarationContext) GetType_() ITypeNameContext { return s.type_ }

func (s *ConstantVariableDeclarationContext) GetName() IIdentifierContext { return s.name }

func (s *ConstantVariableDeclarationContext) GetInitialValue() IExpressionContext {
	return s.initialValue
}

func (s *ConstantVariableDeclarationContext) SetType_(v ITypeNameContext) { s.type_ = v }

func (s *ConstantVariableDeclarationContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ConstantVariableDeclarationContext) SetInitialValue(v IExpressionContext) {
	s.initialValue = v
}

func (s *ConstantVariableDeclarationContext) Constant() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstant, 0)
}

func (s *ConstantVariableDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssign, 0)
}

func (s *ConstantVariableDeclarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *ConstantVariableDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ConstantVariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantVariableDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstantVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterConstantVariableDeclaration(s)
	}
}

func (s *ConstantVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitConstantVariableDeclaration(s)
	}
}

func (p *SolidityParser) ConstantVariableDeclaration() (localctx IConstantVariableDeclarationContext) {
	localctx = NewConstantVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SolidityParserRULE_constantVariableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)

		var _x = p.typeName(0)

		localctx.(*ConstantVariableDeclarationContext).type_ = _x
	}
	{
		p.SetState(618)
		p.Match(SolidityParserConstant)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(619)

		var _x = p.Identifier()

		localctx.(*ConstantVariableDeclarationContext).name = _x
	}
	{
		p.SetState(620)
		p.Match(SolidityParserAssign)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(621)

		var _x = p.expression(0)

		localctx.(*ConstantVariableDeclarationContext).initialValue = _x
	}
	{
		p.SetState(622)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventParameterContext is an interface to support dynamic dispatch.
type IEventParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	TypeName() ITypeNameContext
	Indexed() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsEventParameterContext differentiates from other interfaces.
	IsEventParameterContext()
}

type EventParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  ITypeNameContext
	name   IIdentifierContext
}

func NewEmptyEventParameterContext() *EventParameterContext {
	var p = new(EventParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameter
	return p
}

func InitEmptyEventParameterContext(p *EventParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameter
}

func (*EventParameterContext) IsEventParameterContext() {}

func NewEventParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventParameterContext {
	var p = new(EventParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventParameter

	return p
}

func (s *EventParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *EventParameterContext) GetType_() ITypeNameContext { return s.type_ }

func (s *EventParameterContext) GetName() IIdentifierContext { return s.name }

func (s *EventParameterContext) SetType_(v ITypeNameContext) { s.type_ = v }

func (s *EventParameterContext) SetName(v IIdentifierContext) { s.name = v }

func (s *EventParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EventParameterContext) Indexed() antlr.TerminalNode {
	return s.GetToken(SolidityParserIndexed, 0)
}

func (s *EventParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EventParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterEventParameter(s)
	}
}

func (s *EventParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitEventParameter(s)
	}
}

func (p *SolidityParser) EventParameter() (localctx IEventParameterContext) {
	localctx = NewEventParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SolidityParserRULE_eventParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(624)

		var _x = p.typeName(0)

		localctx.(*EventParameterContext).type_ = _x
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserIndexed {
		{
			p.SetState(625)
			p.Match(SolidityParserIndexed)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserIdentifier {
		{
			p.SetState(628)

			var _x = p.Identifier()

			localctx.(*EventParameterContext).name = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventDefinitionContext is an interface to support dynamic dispatch.
type IEventDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// Get_eventParameter returns the _eventParameter rule contexts.
	Get_eventParameter() IEventParameterContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Set_eventParameter sets the _eventParameter rule contexts.
	Set_eventParameter(IEventParameterContext)

	// GetParameters returns the parameters rule context list.
	GetParameters() []IEventParameterContext

	// SetParameters sets the parameters rule context list.
	SetParameters([]IEventParameterContext)

	// Getter signatures
	Event() antlr.TerminalNode
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	Semicolon() antlr.TerminalNode
	Identifier() IIdentifierContext
	Anonymous() antlr.TerminalNode
	AllEventParameter() []IEventParameterContext
	EventParameter(i int) IEventParameterContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsEventDefinitionContext differentiates from other interfaces.
	IsEventDefinitionContext()
}

type EventDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	name            IIdentifierContext
	_eventParameter IEventParameterContext
	parameters      []IEventParameterContext
}

func NewEmptyEventDefinitionContext() *EventDefinitionContext {
	var p = new(EventDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventDefinition
	return p
}

func InitEmptyEventDefinitionContext(p *EventDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_eventDefinition
}

func (*EventDefinitionContext) IsEventDefinitionContext() {}

func NewEventDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventDefinitionContext {
	var p = new(EventDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventDefinition

	return p
}

func (s *EventDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EventDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *EventDefinitionContext) Get_eventParameter() IEventParameterContext {
	return s._eventParameter
}

func (s *EventDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *EventDefinitionContext) Set_eventParameter(v IEventParameterContext) { s._eventParameter = v }

func (s *EventDefinitionContext) GetParameters() []IEventParameterContext { return s.parameters }

func (s *EventDefinitionContext) SetParameters(v []IEventParameterContext) { s.parameters = v }

func (s *EventDefinitionContext) Event() antlr.TerminalNode {
	return s.GetToken(SolidityParserEvent, 0)
}

func (s *EventDefinitionContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *EventDefinitionContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *EventDefinitionContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *EventDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EventDefinitionContext) Anonymous() antlr.TerminalNode {
	return s.GetToken(SolidityParserAnonymous, 0)
}

func (s *EventDefinitionContext) AllEventParameter() []IEventParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEventParameterContext); ok {
			len++
		}
	}

	tst := make([]IEventParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEventParameterContext); ok {
			tst[i] = t.(IEventParameterContext)
			i++
		}
	}

	return tst
}

func (s *EventDefinitionContext) EventParameter(i int) IEventParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventParameterContext)
}

func (s *EventDefinitionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *EventDefinitionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *EventDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterEventDefinition(s)
	}
}

func (s *EventDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitEventDefinition(s)
	}
}

func (p *SolidityParser) EventDefinition() (localctx IEventDefinitionContext) {
	localctx = NewEventDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SolidityParserRULE_eventDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(SolidityParserEvent)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(632)

		var _x = p.Identifier()

		localctx.(*EventDefinitionContext).name = _x
	}
	{
		p.SetState(633)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(634)

			var _x = p.EventParameter()

			localctx.(*EventDefinitionContext)._eventParameter = _x
		}
		localctx.(*EventDefinitionContext).parameters = append(localctx.(*EventDefinitionContext).parameters, localctx.(*EventDefinitionContext)._eventParameter)
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserComma {
			{
				p.SetState(635)
				p.Match(SolidityParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(636)

				var _x = p.EventParameter()

				localctx.(*EventDefinitionContext)._eventParameter = _x
			}
			localctx.(*EventDefinitionContext).parameters = append(localctx.(*EventDefinitionContext).parameters, localctx.(*EventDefinitionContext)._eventParameter)

			p.SetState(641)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(644)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserAnonymous {
		{
			p.SetState(645)
			p.Match(SolidityParserAnonymous)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(648)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorParameterContext is an interface to support dynamic dispatch.
type IErrorParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	TypeName() ITypeNameContext
	Identifier() IIdentifierContext

	// IsErrorParameterContext differentiates from other interfaces.
	IsErrorParameterContext()
}

type ErrorParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  ITypeNameContext
	name   IIdentifierContext
}

func NewEmptyErrorParameterContext() *ErrorParameterContext {
	var p = new(ErrorParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_errorParameter
	return p
}

func InitEmptyErrorParameterContext(p *ErrorParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_errorParameter
}

func (*ErrorParameterContext) IsErrorParameterContext() {}

func NewErrorParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorParameterContext {
	var p = new(ErrorParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_errorParameter

	return p
}

func (s *ErrorParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorParameterContext) GetType_() ITypeNameContext { return s.type_ }

func (s *ErrorParameterContext) GetName() IIdentifierContext { return s.name }

func (s *ErrorParameterContext) SetType_(v ITypeNameContext) { s.type_ = v }

func (s *ErrorParameterContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ErrorParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ErrorParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterErrorParameter(s)
	}
}

func (s *ErrorParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitErrorParameter(s)
	}
}

func (p *SolidityParser) ErrorParameter() (localctx IErrorParameterContext) {
	localctx = NewErrorParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SolidityParserRULE_errorParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)

		var _x = p.typeName(0)

		localctx.(*ErrorParameterContext).type_ = _x
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserIdentifier {
		{
			p.SetState(651)

			var _x = p.Identifier()

			localctx.(*ErrorParameterContext).name = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorDefinitionContext is an interface to support dynamic dispatch.
type IErrorDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// Get_errorParameter returns the _errorParameter rule contexts.
	Get_errorParameter() IErrorParameterContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Set_errorParameter sets the _errorParameter rule contexts.
	Set_errorParameter(IErrorParameterContext)

	// GetParameters returns the parameters rule context list.
	GetParameters() []IErrorParameterContext

	// SetParameters sets the parameters rule context list.
	SetParameters([]IErrorParameterContext)

	// Getter signatures
	Error() antlr.TerminalNode
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	Semicolon() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllErrorParameter() []IErrorParameterContext
	ErrorParameter(i int) IErrorParameterContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsErrorDefinitionContext differentiates from other interfaces.
	IsErrorDefinitionContext()
}

type ErrorDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	name            IIdentifierContext
	_errorParameter IErrorParameterContext
	parameters      []IErrorParameterContext
}

func NewEmptyErrorDefinitionContext() *ErrorDefinitionContext {
	var p = new(ErrorDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_errorDefinition
	return p
}

func InitEmptyErrorDefinitionContext(p *ErrorDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_errorDefinition
}

func (*ErrorDefinitionContext) IsErrorDefinitionContext() {}

func NewErrorDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorDefinitionContext {
	var p = new(ErrorDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_errorDefinition

	return p
}

func (s *ErrorDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorDefinitionContext) GetName() IIdentifierContext { return s.name }

func (s *ErrorDefinitionContext) Get_errorParameter() IErrorParameterContext {
	return s._errorParameter
}

func (s *ErrorDefinitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ErrorDefinitionContext) Set_errorParameter(v IErrorParameterContext) { s._errorParameter = v }

func (s *ErrorDefinitionContext) GetParameters() []IErrorParameterContext { return s.parameters }

func (s *ErrorDefinitionContext) SetParameters(v []IErrorParameterContext) { s.parameters = v }

func (s *ErrorDefinitionContext) Error() antlr.TerminalNode {
	return s.GetToken(SolidityParserError, 0)
}

func (s *ErrorDefinitionContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *ErrorDefinitionContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *ErrorDefinitionContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *ErrorDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorDefinitionContext) AllErrorParameter() []IErrorParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorParameterContext); ok {
			len++
		}
	}

	tst := make([]IErrorParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorParameterContext); ok {
			tst[i] = t.(IErrorParameterContext)
			i++
		}
	}

	return tst
}

func (s *ErrorDefinitionContext) ErrorParameter(i int) IErrorParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorParameterContext)
}

func (s *ErrorDefinitionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *ErrorDefinitionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *ErrorDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterErrorDefinition(s)
	}
}

func (s *ErrorDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitErrorDefinition(s)
	}
}

func (p *SolidityParser) ErrorDefinition() (localctx IErrorDefinitionContext) {
	localctx = NewErrorDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SolidityParserRULE_errorDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)
		p.Match(SolidityParserError)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(655)

		var _x = p.Identifier()

		localctx.(*ErrorDefinitionContext).name = _x
	}
	{
		p.SetState(656)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(665)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(657)

			var _x = p.ErrorParameter()

			localctx.(*ErrorDefinitionContext)._errorParameter = _x
		}
		localctx.(*ErrorDefinitionContext).parameters = append(localctx.(*ErrorDefinitionContext).parameters, localctx.(*ErrorDefinitionContext)._errorParameter)
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserComma {
			{
				p.SetState(658)
				p.Match(SolidityParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(659)

				var _x = p.ErrorParameter()

				localctx.(*ErrorDefinitionContext)._errorParameter = _x
			}
			localctx.(*ErrorDefinitionContext).parameters = append(localctx.(*ErrorDefinitionContext).parameters, localctx.(*ErrorDefinitionContext)._errorParameter)

			p.SetState(664)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(667)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(668)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserDefinableOperatorContext is an interface to support dynamic dispatch.
type IUserDefinableOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BitAnd() antlr.TerminalNode
	BitNot() antlr.TerminalNode
	BitOr() antlr.TerminalNode
	BitXor() antlr.TerminalNode
	Add() antlr.TerminalNode
	Div() antlr.TerminalNode
	Mod() antlr.TerminalNode
	Mul() antlr.TerminalNode
	Sub() antlr.TerminalNode
	Equal() antlr.TerminalNode
	GreaterThan() antlr.TerminalNode
	GreaterThanOrEqual() antlr.TerminalNode
	LessThan() antlr.TerminalNode
	LessThanOrEqual() antlr.TerminalNode
	NotEqual() antlr.TerminalNode

	// IsUserDefinableOperatorContext differentiates from other interfaces.
	IsUserDefinableOperatorContext()
}

type UserDefinableOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinableOperatorContext() *UserDefinableOperatorContext {
	var p = new(UserDefinableOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_userDefinableOperator
	return p
}

func InitEmptyUserDefinableOperatorContext(p *UserDefinableOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_userDefinableOperator
}

func (*UserDefinableOperatorContext) IsUserDefinableOperatorContext() {}

func NewUserDefinableOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinableOperatorContext {
	var p = new(UserDefinableOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_userDefinableOperator

	return p
}

func (s *UserDefinableOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinableOperatorContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(SolidityParserBitAnd, 0)
}

func (s *UserDefinableOperatorContext) BitNot() antlr.TerminalNode {
	return s.GetToken(SolidityParserBitNot, 0)
}

func (s *UserDefinableOperatorContext) BitOr() antlr.TerminalNode {
	return s.GetToken(SolidityParserBitOr, 0)
}

func (s *UserDefinableOperatorContext) BitXor() antlr.TerminalNode {
	return s.GetToken(SolidityParserBitXor, 0)
}

func (s *UserDefinableOperatorContext) Add() antlr.TerminalNode {
	return s.GetToken(SolidityParserAdd, 0)
}

func (s *UserDefinableOperatorContext) Div() antlr.TerminalNode {
	return s.GetToken(SolidityParserDiv, 0)
}

func (s *UserDefinableOperatorContext) Mod() antlr.TerminalNode {
	return s.GetToken(SolidityParserMod, 0)
}

func (s *UserDefinableOperatorContext) Mul() antlr.TerminalNode {
	return s.GetToken(SolidityParserMul, 0)
}

func (s *UserDefinableOperatorContext) Sub() antlr.TerminalNode {
	return s.GetToken(SolidityParserSub, 0)
}

func (s *UserDefinableOperatorContext) Equal() antlr.TerminalNode {
	return s.GetToken(SolidityParserEqual, 0)
}

func (s *UserDefinableOperatorContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(SolidityParserGreaterThan, 0)
}

func (s *UserDefinableOperatorContext) GreaterThanOrEqual() antlr.TerminalNode {
	return s.GetToken(SolidityParserGreaterThanOrEqual, 0)
}

func (s *UserDefinableOperatorContext) LessThan() antlr.TerminalNode {
	return s.GetToken(SolidityParserLessThan, 0)
}

func (s *UserDefinableOperatorContext) LessThanOrEqual() antlr.TerminalNode {
	return s.GetToken(SolidityParserLessThanOrEqual, 0)
}

func (s *UserDefinableOperatorContext) NotEqual() antlr.TerminalNode {
	return s.GetToken(SolidityParserNotEqual, 0)
}

func (s *UserDefinableOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinableOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinableOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterUserDefinableOperator(s)
	}
}

func (s *UserDefinableOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitUserDefinableOperator(s)
	}
}

func (p *SolidityParser) UserDefinableOperator() (localctx IUserDefinableOperatorContext) {
	localctx = NewUserDefinableOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SolidityParserRULE_userDefinableOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&784327) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingDirectiveContext is an interface to support dynamic dispatch.
type IUsingDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Using() antlr.TerminalNode
	For() antlr.TerminalNode
	Semicolon() antlr.TerminalNode
	AllIdentifierPath() []IIdentifierPathContext
	IdentifierPath(i int) IIdentifierPathContext
	Mul() antlr.TerminalNode
	TypeName() ITypeNameContext
	Global() antlr.TerminalNode
	LBrace() antlr.TerminalNode
	RBrace() antlr.TerminalNode
	AllAs() []antlr.TerminalNode
	As(i int) antlr.TerminalNode
	AllUserDefinableOperator() []IUserDefinableOperatorContext
	UserDefinableOperator(i int) IUserDefinableOperatorContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsUsingDirectiveContext differentiates from other interfaces.
	IsUsingDirectiveContext()
}

type UsingDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingDirectiveContext() *UsingDirectiveContext {
	var p = new(UsingDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_usingDirective
	return p
}

func InitEmptyUsingDirectiveContext(p *UsingDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_usingDirective
}

func (*UsingDirectiveContext) IsUsingDirectiveContext() {}

func NewUsingDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingDirectiveContext {
	var p = new(UsingDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_usingDirective

	return p
}

func (s *UsingDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingDirectiveContext) Using() antlr.TerminalNode {
	return s.GetToken(SolidityParserUsing, 0)
}

func (s *UsingDirectiveContext) For() antlr.TerminalNode {
	return s.GetToken(SolidityParserFor, 0)
}

func (s *UsingDirectiveContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *UsingDirectiveContext) AllIdentifierPath() []IIdentifierPathContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierPathContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierPathContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierPathContext); ok {
			tst[i] = t.(IIdentifierPathContext)
			i++
		}
	}

	return tst
}

func (s *UsingDirectiveContext) IdentifierPath(i int) IIdentifierPathContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPathContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPathContext)
}

func (s *UsingDirectiveContext) Mul() antlr.TerminalNode {
	return s.GetToken(SolidityParserMul, 0)
}

func (s *UsingDirectiveContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *UsingDirectiveContext) Global() antlr.TerminalNode {
	return s.GetToken(SolidityParserGlobal, 0)
}

func (s *UsingDirectiveContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *UsingDirectiveContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *UsingDirectiveContext) AllAs() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserAs)
}

func (s *UsingDirectiveContext) As(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserAs, i)
}

func (s *UsingDirectiveContext) AllUserDefinableOperator() []IUserDefinableOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserDefinableOperatorContext); ok {
			len++
		}
	}

	tst := make([]IUserDefinableOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserDefinableOperatorContext); ok {
			tst[i] = t.(IUserDefinableOperatorContext)
			i++
		}
	}

	return tst
}

func (s *UsingDirectiveContext) UserDefinableOperator(i int) IUserDefinableOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinableOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinableOperatorContext)
}

func (s *UsingDirectiveContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *UsingDirectiveContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *UsingDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterUsingDirective(s)
	}
}

func (s *UsingDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitUsingDirective(s)
	}
}

func (p *SolidityParser) UsingDirective() (localctx IUsingDirectiveContext) {
	localctx = NewUsingDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SolidityParserRULE_usingDirective)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Match(SolidityParserUsing)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(693)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserError, SolidityParserFrom, SolidityParserGlobal, SolidityParserRevert, SolidityParserIdentifier:
		{
			p.SetState(673)
			p.IdentifierPath()
		}

	case SolidityParserLBrace:
		{
			p.SetState(674)
			p.Match(SolidityParserLBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(675)
			p.IdentifierPath()
		}
		p.SetState(678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserAs {
			{
				p.SetState(676)
				p.Match(SolidityParserAs)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(677)
				p.UserDefinableOperator()
			}

		}
		p.SetState(688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserComma {
			{
				p.SetState(680)
				p.Match(SolidityParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(681)
				p.IdentifierPath()
			}
			p.SetState(684)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SolidityParserAs {
				{
					p.SetState(682)
					p.Match(SolidityParserAs)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(683)
					p.UserDefinableOperator()
				}

			}

			p.SetState(690)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(691)
			p.Match(SolidityParserRBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(695)
		p.Match(SolidityParserFor)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(696)
			p.Match(SolidityParserMul)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(697)
			p.typeName(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserGlobal {
		{
			p.SetState(700)
			p.Match(SolidityParserGlobal)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(703)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementaryTypeName() IElementaryTypeNameContext
	FunctionTypeName() IFunctionTypeNameContext
	MappingType() IMappingTypeContext
	IdentifierPath() IIdentifierPathContext
	TypeName() ITypeNameContext
	LBrack() antlr.TerminalNode
	RBrack() antlr.TerminalNode
	Expression() IExpressionContext

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *TypeNameContext) FunctionTypeName() IFunctionTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeNameContext)
}

func (s *TypeNameContext) MappingType() IMappingTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingTypeContext)
}

func (s *TypeNameContext) IdentifierPath() IIdentifierPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPathContext)
}

func (s *TypeNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeNameContext) LBrack() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrack, 0)
}

func (s *TypeNameContext) RBrack() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrack, 0)
}

func (s *TypeNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *SolidityParser) TypeName() (localctx ITypeNameContext) {
	return p.typeName(0)
}

func (p *SolidityParser) typeName(_p int) (localctx ITypeNameContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 76
	p.EnterRecursionRule(localctx, 76, SolidityParserRULE_typeName, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(706)
			p.ElementaryTypeName(true)
		}

	case 2:
		{
			p.SetState(707)
			p.FunctionTypeName()
		}

	case 3:
		{
			p.SetState(708)
			p.MappingType()
		}

	case 4:
		{
			p.SetState(709)
			p.IdentifierPath()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_typeName)
			p.SetState(712)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(713)
				p.Match(SolidityParserLBrack)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(715)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(714)
					p.expression(0)
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(717)
				p.Match(SolidityParserRBrack)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementaryTypeNameContext is an interface to support dynamic dispatch.
type IElementaryTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAllowAddressPayable returns the allowAddressPayable attribute.
	GetAllowAddressPayable() bool

	// SetAllowAddressPayable sets the allowAddressPayable attribute.
	SetAllowAddressPayable(bool)

	// Getter signatures
	Address() antlr.TerminalNode
	Payable() antlr.TerminalNode
	Bool() antlr.TerminalNode
	String_() antlr.TerminalNode
	Bytes() antlr.TerminalNode
	SignedIntegerType() antlr.TerminalNode
	UnsignedIntegerType() antlr.TerminalNode
	FixedBytes() antlr.TerminalNode
	Fixed() antlr.TerminalNode
	Ufixed() antlr.TerminalNode

	// IsElementaryTypeNameContext differentiates from other interfaces.
	IsElementaryTypeNameContext()
}

type ElementaryTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	allowAddressPayable bool
}

func NewEmptyElementaryTypeNameContext() *ElementaryTypeNameContext {
	var p = new(ElementaryTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_elementaryTypeName
	return p
}

func InitEmptyElementaryTypeNameContext(p *ElementaryTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_elementaryTypeName
}

func (*ElementaryTypeNameContext) IsElementaryTypeNameContext() {}

func NewElementaryTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, allowAddressPayable bool) *ElementaryTypeNameContext {
	var p = new(ElementaryTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_elementaryTypeName

	p.allowAddressPayable = allowAddressPayable

	return p
}

func (s *ElementaryTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementaryTypeNameContext) GetAllowAddressPayable() bool { return s.allowAddressPayable }

func (s *ElementaryTypeNameContext) SetAllowAddressPayable(v bool) { s.allowAddressPayable = v }

func (s *ElementaryTypeNameContext) Address() antlr.TerminalNode {
	return s.GetToken(SolidityParserAddress, 0)
}

func (s *ElementaryTypeNameContext) Payable() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayable, 0)
}

func (s *ElementaryTypeNameContext) Bool() antlr.TerminalNode {
	return s.GetToken(SolidityParserBool, 0)
}

func (s *ElementaryTypeNameContext) String_() antlr.TerminalNode {
	return s.GetToken(SolidityParserString_, 0)
}

func (s *ElementaryTypeNameContext) Bytes() antlr.TerminalNode {
	return s.GetToken(SolidityParserBytes, 0)
}

func (s *ElementaryTypeNameContext) SignedIntegerType() antlr.TerminalNode {
	return s.GetToken(SolidityParserSignedIntegerType, 0)
}

func (s *ElementaryTypeNameContext) UnsignedIntegerType() antlr.TerminalNode {
	return s.GetToken(SolidityParserUnsignedIntegerType, 0)
}

func (s *ElementaryTypeNameContext) FixedBytes() antlr.TerminalNode {
	return s.GetToken(SolidityParserFixedBytes, 0)
}

func (s *ElementaryTypeNameContext) Fixed() antlr.TerminalNode {
	return s.GetToken(SolidityParserFixed, 0)
}

func (s *ElementaryTypeNameContext) Ufixed() antlr.TerminalNode {
	return s.GetToken(SolidityParserUfixed, 0)
}

func (s *ElementaryTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementaryTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementaryTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterElementaryTypeName(s)
	}
}

func (s *ElementaryTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitElementaryTypeName(s)
	}
}

func (p *SolidityParser) ElementaryTypeName(allowAddressPayable bool) (localctx IElementaryTypeNameContext) {
	localctx = NewElementaryTypeNameContext(p, p.GetParserRuleContext(), p.GetState(), allowAddressPayable)
	p.EnterRule(localctx, 78, SolidityParserRULE_elementaryTypeName)
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(723)
			p.Match(SolidityParserAddress)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(724)

		if !(localctx.(*ElementaryTypeNameContext).allowAddressPayable) {
			p.SetError(antlr.NewFailedPredicateException(p, "$allowAddressPayable", ""))
			goto errorExit
		}
		{
			p.SetState(725)
			p.Match(SolidityParserAddress)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)
			p.Match(SolidityParserPayable)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(727)
			p.Match(SolidityParserBool)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(728)
			p.Match(SolidityParserString_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(729)
			p.Match(SolidityParserBytes)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(730)
			p.Match(SolidityParserSignedIntegerType)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(731)
			p.Match(SolidityParserUnsignedIntegerType)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(732)
			p.Match(SolidityParserFixedBytes)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(733)
			p.Match(SolidityParserFixed)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(734)
			p.Match(SolidityParserUfixed)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeNameContext is an interface to support dynamic dispatch.
type IFunctionTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetArguments returns the arguments rule contexts.
	GetArguments() IParameterListContext

	// GetReturnParameters returns the returnParameters rule contexts.
	GetReturnParameters() IParameterListContext

	// SetArguments sets the arguments rule contexts.
	SetArguments(IParameterListContext)

	// SetReturnParameters sets the returnParameters rule contexts.
	SetReturnParameters(IParameterListContext)

	// GetVisibilitySet returns the visibilitySet attribute.
	GetVisibilitySet() bool

	// GetMutabilitySet returns the mutabilitySet attribute.
	GetMutabilitySet() bool

	// SetVisibilitySet sets the visibilitySet attribute.
	SetVisibilitySet(bool)

	// SetMutabilitySet sets the mutabilitySet attribute.
	SetMutabilitySet(bool)

	// Getter signatures
	Function() antlr.TerminalNode
	AllLParen() []antlr.TerminalNode
	LParen(i int) antlr.TerminalNode
	AllRParen() []antlr.TerminalNode
	RParen(i int) antlr.TerminalNode
	AllVisibility() []IVisibilityContext
	Visibility(i int) IVisibilityContext
	AllStateMutability() []IStateMutabilityContext
	StateMutability(i int) IStateMutabilityContext
	Returns() antlr.TerminalNode
	AllParameterList() []IParameterListContext
	ParameterList(i int) IParameterListContext

	// IsFunctionTypeNameContext differentiates from other interfaces.
	IsFunctionTypeNameContext()
}

type FunctionTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	visibilitySet    bool // TODO = false
	mutabilitySet    bool // TODO = false
	arguments        IParameterListContext
	returnParameters IParameterListContext
}

func NewEmptyFunctionTypeNameContext() *FunctionTypeNameContext {
	var p = new(FunctionTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeName
	return p
}

func InitEmptyFunctionTypeNameContext(p *FunctionTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeName
}

func (*FunctionTypeNameContext) IsFunctionTypeNameContext() {}

func NewFunctionTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeNameContext {
	var p = new(FunctionTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionTypeName

	return p
}

func (s *FunctionTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeNameContext) GetArguments() IParameterListContext { return s.arguments }

func (s *FunctionTypeNameContext) GetReturnParameters() IParameterListContext {
	return s.returnParameters
}

func (s *FunctionTypeNameContext) SetArguments(v IParameterListContext) { s.arguments = v }

func (s *FunctionTypeNameContext) SetReturnParameters(v IParameterListContext) {
	s.returnParameters = v
}

func (s *FunctionTypeNameContext) GetVisibilitySet() bool { return s.visibilitySet }

func (s *FunctionTypeNameContext) GetMutabilitySet() bool { return s.mutabilitySet }

func (s *FunctionTypeNameContext) SetVisibilitySet(v bool) { s.visibilitySet = v }

func (s *FunctionTypeNameContext) SetMutabilitySet(v bool) { s.mutabilitySet = v }

func (s *FunctionTypeNameContext) Function() antlr.TerminalNode {
	return s.GetToken(SolidityParserFunction, 0)
}

func (s *FunctionTypeNameContext) AllLParen() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserLParen)
}

func (s *FunctionTypeNameContext) LParen(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, i)
}

func (s *FunctionTypeNameContext) AllRParen() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserRParen)
}

func (s *FunctionTypeNameContext) RParen(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, i)
}

func (s *FunctionTypeNameContext) AllVisibility() []IVisibilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVisibilityContext); ok {
			len++
		}
	}

	tst := make([]IVisibilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVisibilityContext); ok {
			tst[i] = t.(IVisibilityContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeNameContext) Visibility(i int) IVisibilityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *FunctionTypeNameContext) AllStateMutability() []IStateMutabilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			len++
		}
	}

	tst := make([]IStateMutabilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStateMutabilityContext); ok {
			tst[i] = t.(IStateMutabilityContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeNameContext) StateMutability(i int) IStateMutabilityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateMutabilityContext)
}

func (s *FunctionTypeNameContext) Returns() antlr.TerminalNode {
	return s.GetToken(SolidityParserReturns, 0)
}

func (s *FunctionTypeNameContext) AllParameterList() []IParameterListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterListContext); ok {
			len++
		}
	}

	tst := make([]IParameterListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterListContext); ok {
			tst[i] = t.(IParameterListContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeNameContext) ParameterList(i int) IParameterListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterFunctionTypeName(s)
	}
}

func (s *FunctionTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitFunctionTypeName(s)
	}
}

func (p *SolidityParser) FunctionTypeName() (localctx IFunctionTypeNameContext) {
	localctx = NewFunctionTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SolidityParserRULE_functionTypeName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		p.Match(SolidityParserFunction)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(738)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(740)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(739)

			var _x = p.ParameterList()

			localctx.(*FunctionTypeNameContext).arguments = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(742)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) {
			case 1:
				p.SetState(743)

				if !(!localctx.(*FunctionTypeNameContext).visibilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$visibilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(744)
					p.Visibility()
				}
				localctx.(*FunctionTypeNameContext).SetVisibilitySet(true)

			case 2:
				p.SetState(747)

				if !(!localctx.(*FunctionTypeNameContext).mutabilitySet) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$mutabilitySet", ""))
					goto errorExit
				}
				{
					p.SetState(748)
					p.StateMutability()
				}
				localctx.(*FunctionTypeNameContext).SetMutabilitySet(true)

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(761)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(756)
			p.Match(SolidityParserReturns)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(757)
			p.Match(SolidityParserLParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(758)

			var _x = p.ParameterList()

			localctx.(*FunctionTypeNameContext).returnParameters = _x
		}
		{
			p.SetState(759)
			p.Match(SolidityParserRParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeNameContext

	// GetLocation returns the location rule contexts.
	GetLocation() IDataLocationContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeNameContext)

	// SetLocation sets the location rule contexts.
	SetLocation(IDataLocationContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	TypeName() ITypeNameContext
	Identifier() IIdentifierContext
	DataLocation() IDataLocationContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	type_    ITypeNameContext
	location IDataLocationContext
	name     IIdentifierContext
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) GetType_() ITypeNameContext { return s.type_ }

func (s *VariableDeclarationContext) GetLocation() IDataLocationContext { return s.location }

func (s *VariableDeclarationContext) GetName() IIdentifierContext { return s.name }

func (s *VariableDeclarationContext) SetType_(v ITypeNameContext) { s.type_ = v }

func (s *VariableDeclarationContext) SetLocation(v IDataLocationContext) { s.location = v }

func (s *VariableDeclarationContext) SetName(v IIdentifierContext) { s.name = v }

func (s *VariableDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *VariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclarationContext) DataLocation() IDataLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataLocationContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *SolidityParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SolidityParserRULE_variableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)

		var _x = p.typeName(0)

		localctx.(*VariableDeclarationContext).type_ = _x
	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&144119586122368000) != 0 {
		{
			p.SetState(764)

			var _x = p.DataLocation()

			localctx.(*VariableDeclarationContext).location = _x
		}

	}
	{
		p.SetState(767)

		var _x = p.Identifier()

		localctx.(*VariableDeclarationContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataLocationContext is an interface to support dynamic dispatch.
type IDataLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Memory() antlr.TerminalNode
	Storage() antlr.TerminalNode
	Calldata() antlr.TerminalNode

	// IsDataLocationContext differentiates from other interfaces.
	IsDataLocationContext()
}

type DataLocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataLocationContext() *DataLocationContext {
	var p = new(DataLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_dataLocation
	return p
}

func InitEmptyDataLocationContext(p *DataLocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_dataLocation
}

func (*DataLocationContext) IsDataLocationContext() {}

func NewDataLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataLocationContext {
	var p = new(DataLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_dataLocation

	return p
}

func (s *DataLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *DataLocationContext) Memory() antlr.TerminalNode {
	return s.GetToken(SolidityParserMemory, 0)
}

func (s *DataLocationContext) Storage() antlr.TerminalNode {
	return s.GetToken(SolidityParserStorage, 0)
}

func (s *DataLocationContext) Calldata() antlr.TerminalNode {
	return s.GetToken(SolidityParserCalldata, 0)
}

func (s *DataLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterDataLocation(s)
	}
}

func (s *DataLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitDataLocation(s)
	}
}

func (p *SolidityParser) DataLocation() (localctx IDataLocationContext) {
	localctx = NewDataLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SolidityParserRULE_dataLocation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&144119586122368000) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnaryPrefixOperationContext struct {
	ExpressionContext
}

func NewUnaryPrefixOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryPrefixOperationContext {
	var p = new(UnaryPrefixOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryPrefixOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPrefixOperationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryPrefixOperationContext) Inc() antlr.TerminalNode {
	return s.GetToken(SolidityParserInc, 0)
}

func (s *UnaryPrefixOperationContext) Dec() antlr.TerminalNode {
	return s.GetToken(SolidityParserDec, 0)
}

func (s *UnaryPrefixOperationContext) Not() antlr.TerminalNode {
	return s.GetToken(SolidityParserNot, 0)
}

func (s *UnaryPrefixOperationContext) BitNot() antlr.TerminalNode {
	return s.GetToken(SolidityParserBitNot, 0)
}

func (s *UnaryPrefixOperationContext) Delete() antlr.TerminalNode {
	return s.GetToken(SolidityParserDelete, 0)
}

func (s *UnaryPrefixOperationContext) Sub() antlr.TerminalNode {
	return s.GetToken(SolidityParserSub, 0)
}

func (s *UnaryPrefixOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterUnaryPrefixOperation(s)
	}
}

func (s *UnaryPrefixOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitUnaryPrefixOperation(s)
	}
}

type PrimaryExpressionContext struct {
	ExpressionContext
}

func NewPrimaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))
	return p
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExpressionContext) LiteralWithSubDenomination() ILiteralWithSubDenominationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralWithSubDenominationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralWithSubDenominationContext)
}

func (s *PrimaryExpressionContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

type OrderComparisonContext struct {
	ExpressionContext
}

func NewOrderComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OrderComparisonContext {
	var p = new(OrderComparisonContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *OrderComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderComparisonContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrderComparisonContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrderComparisonContext) LessThan() antlr.TerminalNode {
	return s.GetToken(SolidityParserLessThan, 0)
}

func (s *OrderComparisonContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(SolidityParserGreaterThan, 0)
}

func (s *OrderComparisonContext) LessThanOrEqual() antlr.TerminalNode {
	return s.GetToken(SolidityParserLessThanOrEqual, 0)
}

func (s *OrderComparisonContext) GreaterThanOrEqual() antlr.TerminalNode {
	return s.GetToken(SolidityParserGreaterThanOrEqual, 0)
}

func (s *OrderComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterOrderComparison(s)
	}
}

func (s *OrderComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitOrderComparison(s)
	}
}

type ConditionalContext struct {
	ExpressionContext
}

func NewConditionalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalContext {
	var p = new(ConditionalContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ConditionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalContext) Conditional() antlr.TerminalNode {
	return s.GetToken(SolidityParserConditional, 0)
}

func (s *ConditionalContext) Colon() antlr.TerminalNode {
	return s.GetToken(SolidityParserColon, 0)
}

func (s *ConditionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterConditional(s)
	}
}

func (s *ConditionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitConditional(s)
	}
}

type PayableConversionContext struct {
	ExpressionContext
}

func NewPayableConversionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PayableConversionContext {
	var p = new(PayableConversionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PayableConversionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PayableConversionContext) Payable() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayable, 0)
}

func (s *PayableConversionContext) CallArgumentList() ICallArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentListContext)
}

func (s *PayableConversionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterPayableConversion(s)
	}
}

func (s *PayableConversionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitPayableConversion(s)
	}
}

type AssignmentContext struct {
	ExpressionContext
}

func NewAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentContext {
	var p = new(AssignmentContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentContext) AssignOp() IAssignOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignOpContext)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

type UnarySuffixOperationContext struct {
	ExpressionContext
}

func NewUnarySuffixOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnarySuffixOperationContext {
	var p = new(UnarySuffixOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *UnarySuffixOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnarySuffixOperationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnarySuffixOperationContext) Inc() antlr.TerminalNode {
	return s.GetToken(SolidityParserInc, 0)
}

func (s *UnarySuffixOperationContext) Dec() antlr.TerminalNode {
	return s.GetToken(SolidityParserDec, 0)
}

func (s *UnarySuffixOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterUnarySuffixOperation(s)
	}
}

func (s *UnarySuffixOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitUnarySuffixOperation(s)
	}
}

type ShiftOperationContext struct {
	ExpressionContext
}

func NewShiftOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShiftOperationContext {
	var p = new(ShiftOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ShiftOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ShiftOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShiftOperationContext) Shl() antlr.TerminalNode {
	return s.GetToken(SolidityParserShl, 0)
}

func (s *ShiftOperationContext) Sar() antlr.TerminalNode {
	return s.GetToken(SolidityParserSar, 0)
}

func (s *ShiftOperationContext) Shr() antlr.TerminalNode {
	return s.GetToken(SolidityParserShr, 0)
}

func (s *ShiftOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterShiftOperation(s)
	}
}

func (s *ShiftOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitShiftOperation(s)
	}
}

type BitAndOperationContext struct {
	ExpressionContext
}

func NewBitAndOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitAndOperationContext {
	var p = new(BitAndOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitAndOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitAndOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitAndOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitAndOperationContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(SolidityParserBitAnd, 0)
}

func (s *BitAndOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterBitAndOperation(s)
	}
}

func (s *BitAndOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitBitAndOperation(s)
	}
}

type FunctionCallContext struct {
	ExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) CallArgumentList() ICallArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentListContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type IndexRangeAccessContext struct {
	ExpressionContext
	startIndex IExpressionContext
	endIndex   IExpressionContext
}

func NewIndexRangeAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexRangeAccessContext {
	var p = new(IndexRangeAccessContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IndexRangeAccessContext) GetStartIndex() IExpressionContext { return s.startIndex }

func (s *IndexRangeAccessContext) GetEndIndex() IExpressionContext { return s.endIndex }

func (s *IndexRangeAccessContext) SetStartIndex(v IExpressionContext) { s.startIndex = v }

func (s *IndexRangeAccessContext) SetEndIndex(v IExpressionContext) { s.endIndex = v }

func (s *IndexRangeAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexRangeAccessContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IndexRangeAccessContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexRangeAccessContext) LBrack() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrack, 0)
}

func (s *IndexRangeAccessContext) Colon() antlr.TerminalNode {
	return s.GetToken(SolidityParserColon, 0)
}

func (s *IndexRangeAccessContext) RBrack() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrack, 0)
}

func (s *IndexRangeAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterIndexRangeAccess(s)
	}
}

func (s *IndexRangeAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitIndexRangeAccess(s)
	}
}

type IndexAccessContext struct {
	ExpressionContext
	index IExpressionContext
}

func NewIndexAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexAccessContext {
	var p = new(IndexAccessContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IndexAccessContext) GetIndex() IExpressionContext { return s.index }

func (s *IndexAccessContext) SetIndex(v IExpressionContext) { s.index = v }

func (s *IndexAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexAccessContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IndexAccessContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexAccessContext) LBrack() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrack, 0)
}

func (s *IndexAccessContext) RBrack() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrack, 0)
}

func (s *IndexAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterIndexAccess(s)
	}
}

func (s *IndexAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitIndexAccess(s)
	}
}

type AddSubOperationContext struct {
	ExpressionContext
}

func NewAddSubOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddSubOperationContext {
	var p = new(AddSubOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AddSubOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSubOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AddSubOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AddSubOperationContext) Add() antlr.TerminalNode {
	return s.GetToken(SolidityParserAdd, 0)
}

func (s *AddSubOperationContext) Sub() antlr.TerminalNode {
	return s.GetToken(SolidityParserSub, 0)
}

func (s *AddSubOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterAddSubOperation(s)
	}
}

func (s *AddSubOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitAddSubOperation(s)
	}
}

type BitOrOperationContext struct {
	ExpressionContext
}

func NewBitOrOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOrOperationContext {
	var p = new(BitOrOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitOrOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOrOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitOrOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitOrOperationContext) BitOr() antlr.TerminalNode {
	return s.GetToken(SolidityParserBitOr, 0)
}

func (s *BitOrOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterBitOrOperation(s)
	}
}

func (s *BitOrOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitBitOrOperation(s)
	}
}

type ExpOperationContext struct {
	ExpressionContext
}

func NewExpOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpOperationContext {
	var p = new(ExpOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ExpOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpOperationContext) Exp() antlr.TerminalNode {
	return s.GetToken(SolidityParserExp, 0)
}

func (s *ExpOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterExpOperation(s)
	}
}

func (s *ExpOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitExpOperation(s)
	}
}

type AndOperationContext struct {
	ExpressionContext
}

func NewAndOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AndOperationContext {
	var p = new(AndOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AndOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AndOperationContext) And() antlr.TerminalNode {
	return s.GetToken(SolidityParserAnd, 0)
}

func (s *AndOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterAndOperation(s)
	}
}

func (s *AndOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitAndOperation(s)
	}
}

type InlineArrayContext struct {
	ExpressionContext
}

func NewInlineArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineArrayContext {
	var p = new(InlineArrayContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *InlineArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineArrayContext) InlineArrayExpression() IInlineArrayExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineArrayExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineArrayExpressionContext)
}

func (s *InlineArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterInlineArray(s)
	}
}

func (s *InlineArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitInlineArray(s)
	}
}

type OrOperationContext struct {
	ExpressionContext
}

func NewOrOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OrOperationContext {
	var p = new(OrOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *OrOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrOperationContext) Or() antlr.TerminalNode {
	return s.GetToken(SolidityParserOr, 0)
}

func (s *OrOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterOrOperation(s)
	}
}

func (s *OrOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitOrOperation(s)
	}
}

type MemberAccessContext struct {
	ExpressionContext
}

func NewMemberAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberAccessContext {
	var p = new(MemberAccessContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MemberAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MemberAccessContext) Period() antlr.TerminalNode {
	return s.GetToken(SolidityParserPeriod, 0)
}

func (s *MemberAccessContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MemberAccessContext) Address() antlr.TerminalNode {
	return s.GetToken(SolidityParserAddress, 0)
}

func (s *MemberAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterMemberAccess(s)
	}
}

func (s *MemberAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitMemberAccess(s)
	}
}

type MulDivModOperationContext struct {
	ExpressionContext
}

func NewMulDivModOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MulDivModOperationContext {
	var p = new(MulDivModOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MulDivModOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MulDivModOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MulDivModOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MulDivModOperationContext) Mul() antlr.TerminalNode {
	return s.GetToken(SolidityParserMul, 0)
}

func (s *MulDivModOperationContext) Div() antlr.TerminalNode {
	return s.GetToken(SolidityParserDiv, 0)
}

func (s *MulDivModOperationContext) Mod() antlr.TerminalNode {
	return s.GetToken(SolidityParserMod, 0)
}

func (s *MulDivModOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterMulDivModOperation(s)
	}
}

func (s *MulDivModOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitMulDivModOperation(s)
	}
}

type FunctionCallOptionsContext struct {
	ExpressionContext
}

func NewFunctionCallOptionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallOptionsContext {
	var p = new(FunctionCallOptionsContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *FunctionCallOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallOptionsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallOptionsContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *FunctionCallOptionsContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *FunctionCallOptionsContext) AllNamedArgument() []INamedArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedArgumentContext); ok {
			len++
		}
	}

	tst := make([]INamedArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedArgumentContext); ok {
			tst[i] = t.(INamedArgumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallOptionsContext) NamedArgument(i int) INamedArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentContext)
}

func (s *FunctionCallOptionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *FunctionCallOptionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *FunctionCallOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterFunctionCallOptions(s)
	}
}

func (s *FunctionCallOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitFunctionCallOptions(s)
	}
}

type NewExprContext struct {
	ExpressionContext
}

func NewNewExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewExprContext {
	var p = new(NewExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *NewExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExprContext) New() antlr.TerminalNode {
	return s.GetToken(SolidityParserNew, 0)
}

func (s *NewExprContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *NewExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterNewExpr(s)
	}
}

func (s *NewExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitNewExpr(s)
	}
}

type BitXorOperationContext struct {
	ExpressionContext
}

func NewBitXorOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitXorOperationContext {
	var p = new(BitXorOperationContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitXorOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitXorOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitXorOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitXorOperationContext) BitXor() antlr.TerminalNode {
	return s.GetToken(SolidityParserBitXor, 0)
}

func (s *BitXorOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterBitXorOperation(s)
	}
}

func (s *BitXorOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitBitXorOperation(s)
	}
}

type TupleContext struct {
	ExpressionContext
}

func NewTupleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TupleContext {
	var p = new(TupleContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *TupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleContext) TupleExpression() ITupleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleExpressionContext)
}

func (s *TupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterTuple(s)
	}
}

func (s *TupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitTuple(s)
	}
}

type EqualityComparisonContext struct {
	ExpressionContext
}

func NewEqualityComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityComparisonContext {
	var p = new(EqualityComparisonContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityComparisonContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityComparisonContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityComparisonContext) Equal() antlr.TerminalNode {
	return s.GetToken(SolidityParserEqual, 0)
}

func (s *EqualityComparisonContext) NotEqual() antlr.TerminalNode {
	return s.GetToken(SolidityParserNotEqual, 0)
}

func (s *EqualityComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterEqualityComparison(s)
	}
}

func (s *EqualityComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitEqualityComparison(s)
	}
}

type MetaTypeContext struct {
	ExpressionContext
}

func NewMetaTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MetaTypeContext {
	var p = new(MetaTypeContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MetaTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetaTypeContext) Type() antlr.TerminalNode {
	return s.GetToken(SolidityParserType, 0)
}

func (s *MetaTypeContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *MetaTypeContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MetaTypeContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *MetaTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterMetaType(s)
	}
}

func (s *MetaTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitMetaType(s)
	}
}

func (p *SolidityParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *SolidityParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, SolidityParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPayableConversionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(772)
			p.Match(SolidityParserPayable)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(773)
			p.CallArgumentList()
		}

	case 2:
		localctx = NewMetaTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(774)
			p.Match(SolidityParserType)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(775)
			p.Match(SolidityParserLParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(776)
			p.typeName(0)
		}
		{
			p.SetState(777)
			p.Match(SolidityParserRParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewUnaryPrefixOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(779)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserDelete || ((int64((_la-105)) & ^0x3f) == 0 && ((int64(1)<<(_la-105))&30721) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(780)
			p.expression(19)
		}

	case 4:
		localctx = NewNewExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(781)
			p.Match(SolidityParserNew)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(782)
			p.typeName(0)
		}

	case 5:
		localctx = NewTupleContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(783)
			p.TupleExpression()
		}

	case 6:
		localctx = NewInlineArrayContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(784)
			p.InlineArrayExpression()
		}

	case 7:
		localctx = NewPrimaryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(785)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(786)
				p.Literal()
			}

		case 3:
			{
				p.SetState(787)
				p.LiteralWithSubDenomination()
			}

		case 4:
			{
				p.SetState(788)
				p.ElementaryTypeName(false)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(875)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(793)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(794)
					p.Match(SolidityParserExp)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(795)
					p.expression(17)
				}

			case 2:
				localctx = NewMulDivModOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(796)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(797)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&7) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(798)
					p.expression(17)
				}

			case 3:
				localctx = NewAddSubOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(799)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(800)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserAdd || _la == SolidityParserSub) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(801)
					p.expression(16)
				}

			case 4:
				localctx = NewShiftOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(802)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(803)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&7) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(804)
					p.expression(15)
				}

			case 5:
				localctx = NewBitAndOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(805)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(806)
					p.Match(SolidityParserBitAnd)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(807)
					p.expression(14)
				}

			case 6:
				localctx = NewBitXorOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(808)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(809)
					p.Match(SolidityParserBitXor)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(810)
					p.expression(13)
				}

			case 7:
				localctx = NewBitOrOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(811)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(812)
					p.Match(SolidityParserBitOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(813)
					p.expression(12)
				}

			case 8:
				localctx = NewOrderComparisonContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(814)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(815)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&15) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(816)
					p.expression(11)
				}

			case 9:
				localctx = NewEqualityComparisonContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(817)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(818)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserEqual || _la == SolidityParserNotEqual) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(819)
					p.expression(10)
				}

			case 10:
				localctx = NewAndOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(820)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(821)
					p.Match(SolidityParserAnd)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(822)
					p.expression(9)
				}

			case 11:
				localctx = NewOrOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(823)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(824)
					p.Match(SolidityParserOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(825)
					p.expression(8)
				}

			case 12:
				localctx = NewConditionalContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(826)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(827)
					p.Match(SolidityParserConditional)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(828)
					p.expression(0)
				}
				{
					p.SetState(829)
					p.Match(SolidityParserColon)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(830)
					p.expression(6)
				}

			case 13:
				localctx = NewAssignmentContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(832)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(833)
					p.AssignOp()
				}
				{
					p.SetState(834)
					p.expression(5)
				}

			case 14:
				localctx = NewIndexAccessContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(836)

				if !(p.Precpred(p.GetParserRuleContext(), 26)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 26)", ""))
					goto errorExit
				}
				{
					p.SetState(837)
					p.Match(SolidityParserLBrack)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(839)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(838)

						var _x = p.expression(0)

						localctx.(*IndexAccessContext).index = _x
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				{
					p.SetState(841)
					p.Match(SolidityParserRBrack)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 15:
				localctx = NewIndexRangeAccessContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(842)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
					goto errorExit
				}
				{
					p.SetState(843)
					p.Match(SolidityParserLBrack)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(845)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(844)

						var _x = p.expression(0)

						localctx.(*IndexRangeAccessContext).startIndex = _x
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				{
					p.SetState(847)
					p.Match(SolidityParserColon)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(849)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(848)

						var _x = p.expression(0)

						localctx.(*IndexRangeAccessContext).endIndex = _x
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				{
					p.SetState(851)
					p.Match(SolidityParserRBrack)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 16:
				localctx = NewMemberAccessContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(852)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
					goto errorExit
				}
				{
					p.SetState(853)
					p.Match(SolidityParserPeriod)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(856)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case SolidityParserError, SolidityParserFrom, SolidityParserGlobal, SolidityParserRevert, SolidityParserIdentifier:
					{
						p.SetState(854)
						p.Identifier()
					}

				case SolidityParserAddress:
					{
						p.SetState(855)
						p.Match(SolidityParserAddress)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 17:
				localctx = NewFunctionCallOptionsContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(858)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(859)
					p.Match(SolidityParserLBrace)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(868)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserIdentifier {
					{
						p.SetState(860)
						p.NamedArgument()
					}
					p.SetState(865)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					for _la == SolidityParserComma {
						{
							p.SetState(861)
							p.Match(SolidityParserComma)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(862)
							p.NamedArgument()
						}

						p.SetState(867)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)
					}

				}
				{
					p.SetState(870)
					p.Match(SolidityParserRBrace)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 18:
				localctx = NewFunctionCallContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(871)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(872)
					p.CallArgumentList()
				}

			case 19:
				localctx = NewUnarySuffixOperationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(873)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(874)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserInc || _la == SolidityParserDec) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(879)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignOpContext is an interface to support dynamic dispatch.
type IAssignOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assign() antlr.TerminalNode
	AssignBitOr() antlr.TerminalNode
	AssignBitXor() antlr.TerminalNode
	AssignBitAnd() antlr.TerminalNode
	AssignShl() antlr.TerminalNode
	AssignSar() antlr.TerminalNode
	AssignShr() antlr.TerminalNode
	AssignAdd() antlr.TerminalNode
	AssignSub() antlr.TerminalNode
	AssignMul() antlr.TerminalNode
	AssignDiv() antlr.TerminalNode
	AssignMod() antlr.TerminalNode

	// IsAssignOpContext differentiates from other interfaces.
	IsAssignOpContext()
}

type AssignOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignOpContext() *AssignOpContext {
	var p = new(AssignOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assignOp
	return p
}

func InitEmptyAssignOpContext(p *AssignOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assignOp
}

func (*AssignOpContext) IsAssignOpContext() {}

func NewAssignOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignOpContext {
	var p = new(AssignOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assignOp

	return p
}

func (s *AssignOpContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignOpContext) Assign() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssign, 0)
}

func (s *AssignOpContext) AssignBitOr() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignBitOr, 0)
}

func (s *AssignOpContext) AssignBitXor() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignBitXor, 0)
}

func (s *AssignOpContext) AssignBitAnd() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignBitAnd, 0)
}

func (s *AssignOpContext) AssignShl() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignShl, 0)
}

func (s *AssignOpContext) AssignSar() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignSar, 0)
}

func (s *AssignOpContext) AssignShr() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignShr, 0)
}

func (s *AssignOpContext) AssignAdd() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignAdd, 0)
}

func (s *AssignOpContext) AssignSub() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignSub, 0)
}

func (s *AssignOpContext) AssignMul() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignMul, 0)
}

func (s *AssignOpContext) AssignDiv() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignDiv, 0)
}

func (s *AssignOpContext) AssignMod() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssignMod, 0)
}

func (s *AssignOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterAssignOp(s)
	}
}

func (s *AssignOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitAssignOp(s)
	}
}

func (p *SolidityParser) AssignOp() (localctx IAssignOpContext) {
	localctx = NewAssignOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SolidityParserRULE_assignOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(880)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&4095) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleExpressionContext is an interface to support dynamic dispatch.
type ITupleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTupleExpressionContext differentiates from other interfaces.
	IsTupleExpressionContext()
}

type TupleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleExpressionContext() *TupleExpressionContext {
	var p = new(TupleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_tupleExpression
	return p
}

func InitEmptyTupleExpressionContext(p *TupleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_tupleExpression
}

func (*TupleExpressionContext) IsTupleExpressionContext() {}

func NewTupleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleExpressionContext {
	var p = new(TupleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_tupleExpression

	return p
}

func (s *TupleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleExpressionContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *TupleExpressionContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *TupleExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TupleExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleExpressionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *TupleExpressionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *TupleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterTupleExpression(s)
	}
}

func (s *TupleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitTupleExpression(s)
	}
}

func (p *SolidityParser) TupleExpression() (localctx ITupleExpressionContext) {
	localctx = NewTupleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SolidityParserRULE_tupleExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(882)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.SetState(884)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(883)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserComma {
		{
			p.SetState(886)
			p.Match(SolidityParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(888)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(887)
				p.expression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	{
		p.SetState(895)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineArrayExpressionContext is an interface to support dynamic dispatch.
type IInlineArrayExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBrack() antlr.TerminalNode
	RBrack() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsInlineArrayExpressionContext differentiates from other interfaces.
	IsInlineArrayExpressionContext()
}

type InlineArrayExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineArrayExpressionContext() *InlineArrayExpressionContext {
	var p = new(InlineArrayExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inlineArrayExpression
	return p
}

func InitEmptyInlineArrayExpressionContext(p *InlineArrayExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_inlineArrayExpression
}

func (*InlineArrayExpressionContext) IsInlineArrayExpressionContext() {}

func NewInlineArrayExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineArrayExpressionContext {
	var p = new(InlineArrayExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inlineArrayExpression

	return p
}

func (s *InlineArrayExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineArrayExpressionContext) LBrack() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrack, 0)
}

func (s *InlineArrayExpressionContext) RBrack() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrack, 0)
}

func (s *InlineArrayExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InlineArrayExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InlineArrayExpressionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *InlineArrayExpressionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *InlineArrayExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineArrayExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineArrayExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterInlineArrayExpression(s)
	}
}

func (s *InlineArrayExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitInlineArrayExpression(s)
	}
}

func (p *SolidityParser) InlineArrayExpression() (localctx IInlineArrayExpressionContext) {
	localctx = NewInlineArrayExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SolidityParserRULE_inlineArrayExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.Match(SolidityParserLBrack)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(898)
		p.expression(0)
	}
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserComma {
		{
			p.SetState(899)
			p.Match(SolidityParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(900)
			p.expression(0)
		}

		p.SetState(905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	{
		p.SetState(906)
		p.Match(SolidityParserRBrack)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	From() antlr.TerminalNode
	Error() antlr.TerminalNode
	Revert() antlr.TerminalNode
	Global() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(SolidityParserIdentifier, 0)
}

func (s *IdentifierContext) From() antlr.TerminalNode {
	return s.GetToken(SolidityParserFrom, 0)
}

func (s *IdentifierContext) Error() antlr.TerminalNode {
	return s.GetToken(SolidityParserError, 0)
}

func (s *IdentifierContext) Revert() antlr.TerminalNode {
	return s.GetToken(SolidityParserRevert, 0)
}

func (s *IdentifierContext) Global() antlr.TerminalNode {
	return s.GetToken(SolidityParserGlobal, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *SolidityParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SolidityParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(908)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	NumberLiteral() INumberLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	HexStringLiteral() IHexStringLiteralContext
	UnicodeStringLiteral() IUnicodeStringLiteralContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) HexStringLiteral() IHexStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexStringLiteralContext)
}

func (s *LiteralContext) UnicodeStringLiteral() IUnicodeStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnicodeStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnicodeStringLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *SolidityParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SolidityParserRULE_literal)
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserNonEmptyStringLiteral, SolidityParserEmptyStringLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(910)
			p.StringLiteral()
		}

	case SolidityParserHexNumber, SolidityParserDecimalNumber:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(911)
			p.NumberLiteral()
		}

	case SolidityParserFalse, SolidityParserTrue:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(912)
			p.BooleanLiteral()
		}

	case SolidityParserHexString:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(913)
			p.HexStringLiteral()
		}

	case SolidityParserUnicodeStringLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(914)
			p.UnicodeStringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralWithSubDenominationContext is an interface to support dynamic dispatch.
type ILiteralWithSubDenominationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumberLiteral() INumberLiteralContext
	SubDenomination() antlr.TerminalNode

	// IsLiteralWithSubDenominationContext differentiates from other interfaces.
	IsLiteralWithSubDenominationContext()
}

type LiteralWithSubDenominationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralWithSubDenominationContext() *LiteralWithSubDenominationContext {
	var p = new(LiteralWithSubDenominationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_literalWithSubDenomination
	return p
}

func InitEmptyLiteralWithSubDenominationContext(p *LiteralWithSubDenominationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_literalWithSubDenomination
}

func (*LiteralWithSubDenominationContext) IsLiteralWithSubDenominationContext() {}

func NewLiteralWithSubDenominationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralWithSubDenominationContext {
	var p = new(LiteralWithSubDenominationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_literalWithSubDenomination

	return p
}

func (s *LiteralWithSubDenominationContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralWithSubDenominationContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralWithSubDenominationContext) SubDenomination() antlr.TerminalNode {
	return s.GetToken(SolidityParserSubDenomination, 0)
}

func (s *LiteralWithSubDenominationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralWithSubDenominationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralWithSubDenominationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterLiteralWithSubDenomination(s)
	}
}

func (s *LiteralWithSubDenominationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitLiteralWithSubDenomination(s)
	}
}

func (p *SolidityParser) LiteralWithSubDenomination() (localctx ILiteralWithSubDenominationContext) {
	localctx = NewLiteralWithSubDenominationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SolidityParserRULE_literalWithSubDenomination)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		p.NumberLiteral()
	}
	{
		p.SetState(918)
		p.Match(SolidityParserSubDenomination)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	True() antlr.TerminalNode
	False() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) True() antlr.TerminalNode {
	return s.GetToken(SolidityParserTrue, 0)
}

func (s *BooleanLiteralContext) False() antlr.TerminalNode {
	return s.GetToken(SolidityParserFalse, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *SolidityParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SolidityParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(920)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SolidityParserFalse || _la == SolidityParserTrue) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNonEmptyStringLiteral() []antlr.TerminalNode
	NonEmptyStringLiteral(i int) antlr.TerminalNode
	AllEmptyStringLiteral() []antlr.TerminalNode
	EmptyStringLiteral(i int) antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllNonEmptyStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserNonEmptyStringLiteral)
}

func (s *StringLiteralContext) NonEmptyStringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserNonEmptyStringLiteral, i)
}

func (s *StringLiteralContext) AllEmptyStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserEmptyStringLiteral)
}

func (s *StringLiteralContext) EmptyStringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserEmptyStringLiteral, i)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *SolidityParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SolidityParserRULE_stringLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(922)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SolidityParserNonEmptyStringLiteral || _la == SolidityParserEmptyStringLiteral) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexStringLiteralContext is an interface to support dynamic dispatch.
type IHexStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHexString() []antlr.TerminalNode
	HexString(i int) antlr.TerminalNode

	// IsHexStringLiteralContext differentiates from other interfaces.
	IsHexStringLiteralContext()
}

type HexStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexStringLiteralContext() *HexStringLiteralContext {
	var p = new(HexStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_hexStringLiteral
	return p
}

func InitEmptyHexStringLiteralContext(p *HexStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_hexStringLiteral
}

func (*HexStringLiteralContext) IsHexStringLiteralContext() {}

func NewHexStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexStringLiteralContext {
	var p = new(HexStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_hexStringLiteral

	return p
}

func (s *HexStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexStringLiteralContext) AllHexString() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserHexString)
}

func (s *HexStringLiteralContext) HexString(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserHexString, i)
}

func (s *HexStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterHexStringLiteral(s)
	}
}

func (s *HexStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitHexStringLiteral(s)
	}
}

func (p *SolidityParser) HexStringLiteral() (localctx IHexStringLiteralContext) {
	localctx = NewHexStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SolidityParserRULE_hexStringLiteral)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(927)
				p.Match(SolidityParserHexString)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnicodeStringLiteralContext is an interface to support dynamic dispatch.
type IUnicodeStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUnicodeStringLiteral() []antlr.TerminalNode
	UnicodeStringLiteral(i int) antlr.TerminalNode

	// IsUnicodeStringLiteralContext differentiates from other interfaces.
	IsUnicodeStringLiteralContext()
}

type UnicodeStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnicodeStringLiteralContext() *UnicodeStringLiteralContext {
	var p = new(UnicodeStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_unicodeStringLiteral
	return p
}

func InitEmptyUnicodeStringLiteralContext(p *UnicodeStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_unicodeStringLiteral
}

func (*UnicodeStringLiteralContext) IsUnicodeStringLiteralContext() {}

func NewUnicodeStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnicodeStringLiteralContext {
	var p = new(UnicodeStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_unicodeStringLiteral

	return p
}

func (s *UnicodeStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *UnicodeStringLiteralContext) AllUnicodeStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserUnicodeStringLiteral)
}

func (s *UnicodeStringLiteralContext) UnicodeStringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserUnicodeStringLiteral, i)
}

func (s *UnicodeStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnicodeStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnicodeStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitUnicodeStringLiteral(s)
	}
}

func (p *SolidityParser) UnicodeStringLiteral() (localctx IUnicodeStringLiteralContext) {
	localctx = NewUnicodeStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SolidityParserRULE_unicodeStringLiteral)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(932)
				p.Match(SolidityParserUnicodeStringLiteral)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalNumber() antlr.TerminalNode
	HexNumber() antlr.TerminalNode

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) DecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserDecimalNumber, 0)
}

func (s *NumberLiteralContext) HexNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserHexNumber, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (p *SolidityParser) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SolidityParserRULE_numberLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SolidityParserHexNumber || _la == SolidityParserDecimalNumber) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBrace() antlr.TerminalNode
	RBrace() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllUncheckedBlock() []IUncheckedBlockContext
	UncheckedBlock(i int) IUncheckedBlockContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserLBrace, 0)
}

func (s *BlockContext) RBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserRBrace, 0)
}

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) AllUncheckedBlock() []IUncheckedBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUncheckedBlockContext); ok {
			len++
		}
	}

	tst := make([]IUncheckedBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUncheckedBlockContext); ok {
			tst[i] = t.(IUncheckedBlockContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) UncheckedBlock(i int) IUncheckedBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUncheckedBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUncheckedBlockContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *SolidityParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SolidityParserRULE_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		p.Match(SolidityParserLBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(942)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(940)
					p.Statement()
				}

			case 2:
				{
					p.SetState(941)
					p.UncheckedBlock()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(947)
		p.Match(SolidityParserRBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUncheckedBlockContext is an interface to support dynamic dispatch.
type IUncheckedBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unchecked() antlr.TerminalNode
	Block() IBlockContext

	// IsUncheckedBlockContext differentiates from other interfaces.
	IsUncheckedBlockContext()
}

type UncheckedBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUncheckedBlockContext() *UncheckedBlockContext {
	var p = new(UncheckedBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_uncheckedBlock
	return p
}

func InitEmptyUncheckedBlockContext(p *UncheckedBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_uncheckedBlock
}

func (*UncheckedBlockContext) IsUncheckedBlockContext() {}

func NewUncheckedBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UncheckedBlockContext {
	var p = new(UncheckedBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_uncheckedBlock

	return p
}

func (s *UncheckedBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *UncheckedBlockContext) Unchecked() antlr.TerminalNode {
	return s.GetToken(SolidityParserUnchecked, 0)
}

func (s *UncheckedBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *UncheckedBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UncheckedBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UncheckedBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterUncheckedBlock(s)
	}
}

func (s *UncheckedBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitUncheckedBlock(s)
	}
}

func (p *SolidityParser) UncheckedBlock() (localctx IUncheckedBlockContext) {
	localctx = NewUncheckedBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SolidityParserRULE_uncheckedBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(949)
		p.Match(SolidityParserUnchecked)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(950)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	SimpleStatement() ISimpleStatementContext
	IfStatement() IIfStatementContext
	ForStatement() IForStatementContext
	WhileStatement() IWhileStatementContext
	DoWhileStatement() IDoWhileStatementContext
	ContinueStatement() IContinueStatementContext
	BreakStatement() IBreakStatementContext
	TryStatement() ITryStatementContext
	ReturnStatement() IReturnStatementContext
	EmitStatement() IEmitStatementContext
	RevertStatement() IRevertStatementContext
	AssemblyStatement() IAssemblyStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) EmitStatement() IEmitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmitStatementContext)
}

func (s *StatementContext) RevertStatement() IRevertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevertStatementContext)
}

func (s *StatementContext) AssemblyStatement() IAssemblyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *SolidityParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SolidityParserRULE_statement)
	p.SetState(965)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(952)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(953)
			p.SimpleStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(954)
			p.IfStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(955)
			p.ForStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(956)
			p.WhileStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(957)
			p.DoWhileStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(958)
			p.ContinueStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(959)
			p.BreakStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(960)
			p.TryStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(961)
			p.ReturnStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(962)
			p.EmitStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(963)
			p.RevertStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(964)
			p.AssemblyStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclarationStatement() IVariableDeclarationStatementContext
	ExpressionStatement() IExpressionStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) VariableDeclarationStatement() IVariableDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationStatementContext)
}

func (s *SimpleStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (p *SolidityParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SolidityParserRULE_simpleStatement)
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(967)
			p.VariableDeclarationStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(968)
			p.ExpressionStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If() antlr.TerminalNode
	LParen() antlr.TerminalNode
	Expression() IExpressionContext
	RParen() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	Else() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(SolidityParserIf, 0)
}

func (s *IfStatementContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(SolidityParserElse, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *SolidityParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SolidityParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(971)
		p.Match(SolidityParserIf)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(972)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(973)
		p.expression(0)
	}
	{
		p.SetState(974)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(975)
		p.Statement()
	}
	p.SetState(978)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(976)
			p.Match(SolidityParserElse)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(977)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	For() antlr.TerminalNode
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	Statement() IStatementContext
	SimpleStatement() ISimpleStatementContext
	AllSemicolon() []antlr.TerminalNode
	Semicolon(i int) antlr.TerminalNode
	ExpressionStatement() IExpressionStatementContext
	Expression() IExpressionContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(SolidityParserFor, 0)
}

func (s *ForStatementContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *ForStatementContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *ForStatementContext) AllSemicolon() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserSemicolon)
}

func (s *ForStatementContext) Semicolon(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, i)
}

func (s *ForStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *SolidityParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SolidityParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		p.Match(SolidityParserFor)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(981)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(982)
			p.SimpleStatement()
		}

	case 2:
		{
			p.SetState(983)
			p.Match(SolidityParserSemicolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(986)
			p.ExpressionStatement()
		}

	case 2:
		{
			p.SetState(987)
			p.Match(SolidityParserSemicolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(991)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(990)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(993)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(994)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	While() antlr.TerminalNode
	LParen() antlr.TerminalNode
	Expression() IExpressionContext
	RParen() antlr.TerminalNode
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(SolidityParserWhile, 0)
}

func (s *WhileStatementContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *SolidityParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SolidityParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(996)
		p.Match(SolidityParserWhile)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(997)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(998)
		p.expression(0)
	}
	{
		p.SetState(999)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1000)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Do() antlr.TerminalNode
	Statement() IStatementContext
	While() antlr.TerminalNode
	LParen() antlr.TerminalNode
	Expression() IExpressionContext
	RParen() antlr.TerminalNode
	Semicolon() antlr.TerminalNode

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_doWhileStatement
	return p
}

func InitEmptyDoWhileStatementContext(p *DoWhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_doWhileStatement
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(SolidityParserDo, 0)
}

func (s *DoWhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(SolidityParserWhile, 0)
}

func (s *DoWhileStatementContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *DoWhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileStatementContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *DoWhileStatementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}

func (p *SolidityParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SolidityParserRULE_doWhileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Match(SolidityParserDo)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1003)
		p.Statement()
	}
	{
		p.SetState(1004)
		p.Match(SolidityParserWhile)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1005)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1006)
		p.expression(0)
	}
	{
		p.SetState(1007)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1008)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Continue() antlr.TerminalNode
	Semicolon() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(SolidityParserContinue, 0)
}

func (s *ContinueStatementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *SolidityParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SolidityParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1010)
		p.Match(SolidityParserContinue)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1011)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Break() antlr.TerminalNode
	Semicolon() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(SolidityParserBreak, 0)
}

func (s *BreakStatementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *SolidityParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SolidityParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Match(SolidityParserBreak)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1014)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturnParameters returns the returnParameters rule contexts.
	GetReturnParameters() IParameterListContext

	// SetReturnParameters sets the returnParameters rule contexts.
	SetReturnParameters(IParameterListContext)

	// Getter signatures
	Try() antlr.TerminalNode
	Expression() IExpressionContext
	Block() IBlockContext
	Returns() antlr.TerminalNode
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	AllCatchClause() []ICatchClauseContext
	CatchClause(i int) ICatchClauseContext
	ParameterList() IParameterListContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	returnParameters IParameterListContext
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) GetReturnParameters() IParameterListContext { return s.returnParameters }

func (s *TryStatementContext) SetReturnParameters(v IParameterListContext) { s.returnParameters = v }

func (s *TryStatementContext) Try() antlr.TerminalNode {
	return s.GetToken(SolidityParserTry, 0)
}

func (s *TryStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) Returns() antlr.TerminalNode {
	return s.GetToken(SolidityParserReturns, 0)
}

func (s *TryStatementContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *TryStatementContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *TryStatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryStatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *SolidityParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SolidityParserRULE_tryStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1016)
		p.Match(SolidityParserTry)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1017)
		p.expression(0)
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserReturns {
		{
			p.SetState(1018)
			p.Match(SolidityParserReturns)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1019)
			p.Match(SolidityParserLParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1020)

			var _x = p.ParameterList()

			localctx.(*TryStatementContext).returnParameters = _x
		}
		{
			p.SetState(1021)
			p.Match(SolidityParserRParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1025)
		p.Block()
	}
	p.SetState(1027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1026)
				p.CatchClause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetArguments returns the arguments rule contexts.
	GetArguments() IParameterListContext

	// SetArguments sets the arguments rule contexts.
	SetArguments(IParameterListContext)

	// Getter signatures
	Catch() antlr.TerminalNode
	Block() IBlockContext
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	Identifier() IIdentifierContext
	ParameterList() IParameterListContext

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	arguments IParameterListContext
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_catchClause
	return p
}

func InitEmptyCatchClauseContext(p *CatchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_catchClause
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) GetArguments() IParameterListContext { return s.arguments }

func (s *CatchClauseContext) SetArguments(v IParameterListContext) { s.arguments = v }

func (s *CatchClauseContext) Catch() antlr.TerminalNode {
	return s.GetToken(SolidityParserCatch, 0)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *CatchClauseContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *CatchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchClauseContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (p *SolidityParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SolidityParserRULE_catchClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.Match(SolidityParserCatch)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserLParen || _la == SolidityParserIdentifier {
		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserIdentifier {
			{
				p.SetState(1032)
				p.Identifier()
			}

		}
		{
			p.SetState(1035)
			p.Match(SolidityParserLParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(1036)

			var _x = p.ParameterList()

			localctx.(*CatchClauseContext).arguments = _x
		}

		{
			p.SetState(1037)
			p.Match(SolidityParserRParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1041)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Return() antlr.TerminalNode
	Semicolon() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(SolidityParserReturn, 0)
}

func (s *ReturnStatementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *SolidityParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SolidityParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1043)
		p.Match(SolidityParserReturn)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1044)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1047)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmitStatementContext is an interface to support dynamic dispatch.
type IEmitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Emit() antlr.TerminalNode
	Expression() IExpressionContext
	CallArgumentList() ICallArgumentListContext
	Semicolon() antlr.TerminalNode

	// IsEmitStatementContext differentiates from other interfaces.
	IsEmitStatementContext()
}

type EmitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmitStatementContext() *EmitStatementContext {
	var p = new(EmitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_emitStatement
	return p
}

func InitEmptyEmitStatementContext(p *EmitStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_emitStatement
}

func (*EmitStatementContext) IsEmitStatementContext() {}

func NewEmitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmitStatementContext {
	var p = new(EmitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_emitStatement

	return p
}

func (s *EmitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmitStatementContext) Emit() antlr.TerminalNode {
	return s.GetToken(SolidityParserEmit, 0)
}

func (s *EmitStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EmitStatementContext) CallArgumentList() ICallArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentListContext)
}

func (s *EmitStatementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *EmitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterEmitStatement(s)
	}
}

func (s *EmitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitEmitStatement(s)
	}
}

func (p *SolidityParser) EmitStatement() (localctx IEmitStatementContext) {
	localctx = NewEmitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SolidityParserRULE_emitStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1049)
		p.Match(SolidityParserEmit)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1050)
		p.expression(0)
	}
	{
		p.SetState(1051)
		p.CallArgumentList()
	}
	{
		p.SetState(1052)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevertStatementContext is an interface to support dynamic dispatch.
type IRevertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Revert() antlr.TerminalNode
	Expression() IExpressionContext
	CallArgumentList() ICallArgumentListContext
	Semicolon() antlr.TerminalNode

	// IsRevertStatementContext differentiates from other interfaces.
	IsRevertStatementContext()
}

type RevertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevertStatementContext() *RevertStatementContext {
	var p = new(RevertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_revertStatement
	return p
}

func InitEmptyRevertStatementContext(p *RevertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_revertStatement
}

func (*RevertStatementContext) IsRevertStatementContext() {}

func NewRevertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevertStatementContext {
	var p = new(RevertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_revertStatement

	return p
}

func (s *RevertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevertStatementContext) Revert() antlr.TerminalNode {
	return s.GetToken(SolidityParserRevert, 0)
}

func (s *RevertStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RevertStatementContext) CallArgumentList() ICallArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentListContext)
}

func (s *RevertStatementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *RevertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterRevertStatement(s)
	}
}

func (s *RevertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitRevertStatement(s)
	}
}

func (p *SolidityParser) RevertStatement() (localctx IRevertStatementContext) {
	localctx = NewRevertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SolidityParserRULE_revertStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		p.Match(SolidityParserRevert)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1055)
		p.expression(0)
	}
	{
		p.SetState(1056)
		p.CallArgumentList()
	}
	{
		p.SetState(1057)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyStatementContext is an interface to support dynamic dispatch.
type IAssemblyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assembly() antlr.TerminalNode
	AssemblyLBrace() antlr.TerminalNode
	YulRBrace() antlr.TerminalNode
	AssemblyDialect() antlr.TerminalNode
	AssemblyFlags() IAssemblyFlagsContext
	AllYulStatement() []IYulStatementContext
	YulStatement(i int) IYulStatementContext

	// IsAssemblyStatementContext differentiates from other interfaces.
	IsAssemblyStatementContext()
}

type AssemblyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyStatementContext() *AssemblyStatementContext {
	var p = new(AssemblyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyStatement
	return p
}

func InitEmptyAssemblyStatementContext(p *AssemblyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyStatement
}

func (*AssemblyStatementContext) IsAssemblyStatementContext() {}

func NewAssemblyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyStatementContext {
	var p = new(AssemblyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyStatement

	return p
}

func (s *AssemblyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyStatementContext) Assembly() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssembly, 0)
}

func (s *AssemblyStatementContext) AssemblyLBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssemblyLBrace, 0)
}

func (s *AssemblyStatementContext) YulRBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulRBrace, 0)
}

func (s *AssemblyStatementContext) AssemblyDialect() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssemblyDialect, 0)
}

func (s *AssemblyStatementContext) AssemblyFlags() IAssemblyFlagsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyFlagsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyFlagsContext)
}

func (s *AssemblyStatementContext) AllYulStatement() []IYulStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYulStatementContext); ok {
			len++
		}
	}

	tst := make([]IYulStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYulStatementContext); ok {
			tst[i] = t.(IYulStatementContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyStatementContext) YulStatement(i int) IYulStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulStatementContext)
}

func (s *AssemblyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterAssemblyStatement(s)
	}
}

func (s *AssemblyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitAssemblyStatement(s)
	}
}

func (p *SolidityParser) AssemblyStatement() (localctx IAssemblyStatementContext) {
	localctx = NewAssemblyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SolidityParserRULE_assemblyStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1059)
		p.Match(SolidityParserAssembly)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserAssemblyDialect {
		{
			p.SetState(1060)
			p.Match(SolidityParserAssemblyDialect)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserAssemblyBlockLParen {
		{
			p.SetState(1063)
			p.AssemblyFlags()
		}

	}
	{
		p.SetState(1066)
		p.Match(SolidityParserAssemblyLBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-143)) & ^0x3f) == 0 && ((int64(1)<<(_la-143))&4220901) != 0 {
		{
			p.SetState(1067)
			p.YulStatement()
		}

		p.SetState(1072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1073)
		p.Match(SolidityParserYulRBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblyFlagsContext is an interface to support dynamic dispatch.
type IAssemblyFlagsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssemblyBlockLParen() antlr.TerminalNode
	AllAssemblyFlagString() []antlr.TerminalNode
	AssemblyFlagString(i int) antlr.TerminalNode
	AssemblyBlockRParen() antlr.TerminalNode
	AllAssemblyBlockComma() []antlr.TerminalNode
	AssemblyBlockComma(i int) antlr.TerminalNode

	// IsAssemblyFlagsContext differentiates from other interfaces.
	IsAssemblyFlagsContext()
}

type AssemblyFlagsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyFlagsContext() *AssemblyFlagsContext {
	var p = new(AssemblyFlagsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFlags
	return p
}

func InitEmptyAssemblyFlagsContext(p *AssemblyFlagsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFlags
}

func (*AssemblyFlagsContext) IsAssemblyFlagsContext() {}

func NewAssemblyFlagsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyFlagsContext {
	var p = new(AssemblyFlagsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFlags

	return p
}

func (s *AssemblyFlagsContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyFlagsContext) AssemblyBlockLParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssemblyBlockLParen, 0)
}

func (s *AssemblyFlagsContext) AllAssemblyFlagString() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserAssemblyFlagString)
}

func (s *AssemblyFlagsContext) AssemblyFlagString(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserAssemblyFlagString, i)
}

func (s *AssemblyFlagsContext) AssemblyBlockRParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssemblyBlockRParen, 0)
}

func (s *AssemblyFlagsContext) AllAssemblyBlockComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserAssemblyBlockComma)
}

func (s *AssemblyFlagsContext) AssemblyBlockComma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserAssemblyBlockComma, i)
}

func (s *AssemblyFlagsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyFlagsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyFlagsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterAssemblyFlags(s)
	}
}

func (s *AssemblyFlagsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitAssemblyFlags(s)
	}
}

func (p *SolidityParser) AssemblyFlags() (localctx IAssemblyFlagsContext) {
	localctx = NewAssemblyFlagsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SolidityParserRULE_assemblyFlags)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1075)
		p.Match(SolidityParserAssemblyBlockLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1076)
		p.Match(SolidityParserAssemblyFlagString)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserAssemblyBlockComma {
		{
			p.SetState(1077)
			p.Match(SolidityParserAssemblyBlockComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1078)
			p.Match(SolidityParserAssemblyFlagString)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1084)
		p.Match(SolidityParserAssemblyBlockRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_variableDeclaration returns the _variableDeclaration rule contexts.
	Get_variableDeclaration() IVariableDeclarationContext

	// Set_variableDeclaration sets the _variableDeclaration rule contexts.
	Set_variableDeclaration(IVariableDeclarationContext)

	// GetVariableDeclarations returns the variableDeclarations rule context list.
	GetVariableDeclarations() []IVariableDeclarationContext

	// SetVariableDeclarations sets the variableDeclarations rule context list.
	SetVariableDeclarations([]IVariableDeclarationContext)

	// Getter signatures
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	_variableDeclaration IVariableDeclarationContext
	variableDeclarations []IVariableDeclarationContext
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationList
	return p
}

func InitEmptyVariableDeclarationListContext(p *VariableDeclarationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationList
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) Get_variableDeclaration() IVariableDeclarationContext {
	return s._variableDeclaration
}

func (s *VariableDeclarationListContext) Set_variableDeclaration(v IVariableDeclarationContext) {
	s._variableDeclaration = v
}

func (s *VariableDeclarationListContext) GetVariableDeclarations() []IVariableDeclarationContext {
	return s.variableDeclarations
}

func (s *VariableDeclarationListContext) SetVariableDeclarations(v []IVariableDeclarationContext) {
	s.variableDeclarations = v
}

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *VariableDeclarationListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}

func (p *SolidityParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SolidityParserRULE_variableDeclarationList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1086)

		var _x = p.VariableDeclaration()

		localctx.(*VariableDeclarationListContext)._variableDeclaration = _x
	}
	localctx.(*VariableDeclarationListContext).variableDeclarations = append(localctx.(*VariableDeclarationListContext).variableDeclarations, localctx.(*VariableDeclarationListContext)._variableDeclaration)
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserComma {
		{
			p.SetState(1087)
			p.Match(SolidityParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1088)

			var _x = p.VariableDeclaration()

			localctx.(*VariableDeclarationListContext)._variableDeclaration = _x
		}
		localctx.(*VariableDeclarationListContext).variableDeclarations = append(localctx.(*VariableDeclarationListContext).variableDeclarations, localctx.(*VariableDeclarationListContext)._variableDeclaration)

		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationTupleContext is an interface to support dynamic dispatch.
type IVariableDeclarationTupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_variableDeclaration returns the _variableDeclaration rule contexts.
	Get_variableDeclaration() IVariableDeclarationContext

	// Set_variableDeclaration sets the _variableDeclaration rule contexts.
	Set_variableDeclaration(IVariableDeclarationContext)

	// GetVariableDeclarations returns the variableDeclarations rule context list.
	GetVariableDeclarations() []IVariableDeclarationContext

	// SetVariableDeclarations sets the variableDeclarations rule context list.
	SetVariableDeclarations([]IVariableDeclarationContext)

	// Getter signatures
	LParen() antlr.TerminalNode
	RParen() antlr.TerminalNode
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsVariableDeclarationTupleContext differentiates from other interfaces.
	IsVariableDeclarationTupleContext()
}

type VariableDeclarationTupleContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	_variableDeclaration IVariableDeclarationContext
	variableDeclarations []IVariableDeclarationContext
}

func NewEmptyVariableDeclarationTupleContext() *VariableDeclarationTupleContext {
	var p = new(VariableDeclarationTupleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationTuple
	return p
}

func InitEmptyVariableDeclarationTupleContext(p *VariableDeclarationTupleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationTuple
}

func (*VariableDeclarationTupleContext) IsVariableDeclarationTupleContext() {}

func NewVariableDeclarationTupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationTupleContext {
	var p = new(VariableDeclarationTupleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclarationTuple

	return p
}

func (s *VariableDeclarationTupleContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationTupleContext) Get_variableDeclaration() IVariableDeclarationContext {
	return s._variableDeclaration
}

func (s *VariableDeclarationTupleContext) Set_variableDeclaration(v IVariableDeclarationContext) {
	s._variableDeclaration = v
}

func (s *VariableDeclarationTupleContext) GetVariableDeclarations() []IVariableDeclarationContext {
	return s.variableDeclarations
}

func (s *VariableDeclarationTupleContext) SetVariableDeclarations(v []IVariableDeclarationContext) {
	s.variableDeclarations = v
}

func (s *VariableDeclarationTupleContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *VariableDeclarationTupleContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *VariableDeclarationTupleContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationTupleContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationTupleContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserComma)
}

func (s *VariableDeclarationTupleContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserComma, i)
}

func (s *VariableDeclarationTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationTupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterVariableDeclarationTuple(s)
	}
}

func (s *VariableDeclarationTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitVariableDeclarationTuple(s)
	}
}

func (p *SolidityParser) VariableDeclarationTuple() (localctx IVariableDeclarationTupleContext) {
	localctx = NewVariableDeclarationTupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SolidityParserRULE_variableDeclarationTuple)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1095)
				p.Match(SolidityParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1101)

		var _x = p.VariableDeclaration()

		localctx.(*VariableDeclarationTupleContext)._variableDeclaration = _x
	}
	localctx.(*VariableDeclarationTupleContext).variableDeclarations = append(localctx.(*VariableDeclarationTupleContext).variableDeclarations, localctx.(*VariableDeclarationTupleContext)._variableDeclaration)

	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserComma {
		{
			p.SetState(1103)
			p.Match(SolidityParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1105)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1104)

				var _x = p.VariableDeclaration()

				localctx.(*VariableDeclarationTupleContext)._variableDeclaration = _x
			}
			localctx.(*VariableDeclarationTupleContext).variableDeclarations = append(localctx.(*VariableDeclarationTupleContext).variableDeclarations, localctx.(*VariableDeclarationTupleContext)._variableDeclaration)

		} else if p.HasError() { // JIM
			goto errorExit
		}

		p.SetState(1111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1112)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type IVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Semicolon() antlr.TerminalNode
	VariableDeclaration() IVariableDeclarationContext
	VariableDeclarationTuple() IVariableDeclarationTupleContext
	Assign() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariableDeclarationStatementContext differentiates from other interfaces.
	IsVariableDeclarationStatementContext()
}

type VariableDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationStatementContext() *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement
	return p
}

func InitEmptyVariableDeclarationStatementContext(p *VariableDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement
}

func (*VariableDeclarationStatementContext) IsVariableDeclarationStatementContext() {}

func NewVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement

	return p
}

func (s *VariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationStatementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *VariableDeclarationStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationStatementContext) VariableDeclarationTuple() IVariableDeclarationTupleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationTupleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationTupleContext)
}

func (s *VariableDeclarationStatementContext) Assign() antlr.TerminalNode {
	return s.GetToken(SolidityParserAssign, 0)
}

func (s *VariableDeclarationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitVariableDeclarationStatement(s)
	}
}

func (p *SolidityParser) VariableDeclarationStatement() (localctx IVariableDeclarationStatementContext) {
	localctx = NewVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SolidityParserRULE_variableDeclarationStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1114)
			p.VariableDeclaration()
		}
		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserAssign {
			{
				p.SetState(1115)
				p.Match(SolidityParserAssign)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1116)
				p.expression(0)
			}

		}

	case 2:
		{
			p.SetState(1119)
			p.VariableDeclarationTuple()
		}
		{
			p.SetState(1120)
			p.Match(SolidityParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1121)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1125)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Semicolon() antlr.TerminalNode

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(SolidityParserSemicolon, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *SolidityParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SolidityParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1127)
		p.expression(0)
	}
	{
		p.SetState(1128)
		p.Match(SolidityParserSemicolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingTypeContext is an interface to support dynamic dispatch.
type IMappingTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IMappingKeyTypeContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetValue returns the value rule contexts.
	GetValue() ITypeNameContext

	// SetKey sets the key rule contexts.
	SetKey(IMappingKeyTypeContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetValue sets the value rule contexts.
	SetValue(ITypeNameContext)

	// Getter signatures
	Mapping() antlr.TerminalNode
	LParen() antlr.TerminalNode
	DoubleArrow() antlr.TerminalNode
	RParen() antlr.TerminalNode
	MappingKeyType() IMappingKeyTypeContext
	TypeName() ITypeNameContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsMappingTypeContext differentiates from other interfaces.
	IsMappingTypeContext()
}

type MappingTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IMappingKeyTypeContext
	name   IIdentifierContext
	value  ITypeNameContext
}

func NewEmptyMappingTypeContext() *MappingTypeContext {
	var p = new(MappingTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_mappingType
	return p
}

func InitEmptyMappingTypeContext(p *MappingTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_mappingType
}

func (*MappingTypeContext) IsMappingTypeContext() {}

func NewMappingTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingTypeContext {
	var p = new(MappingTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_mappingType

	return p
}

func (s *MappingTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingTypeContext) GetKey() IMappingKeyTypeContext { return s.key }

func (s *MappingTypeContext) GetName() IIdentifierContext { return s.name }

func (s *MappingTypeContext) GetValue() ITypeNameContext { return s.value }

func (s *MappingTypeContext) SetKey(v IMappingKeyTypeContext) { s.key = v }

func (s *MappingTypeContext) SetName(v IIdentifierContext) { s.name = v }

func (s *MappingTypeContext) SetValue(v ITypeNameContext) { s.value = v }

func (s *MappingTypeContext) Mapping() antlr.TerminalNode {
	return s.GetToken(SolidityParserMapping, 0)
}

func (s *MappingTypeContext) LParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserLParen, 0)
}

func (s *MappingTypeContext) DoubleArrow() antlr.TerminalNode {
	return s.GetToken(SolidityParserDoubleArrow, 0)
}

func (s *MappingTypeContext) RParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserRParen, 0)
}

func (s *MappingTypeContext) MappingKeyType() IMappingKeyTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingKeyTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingKeyTypeContext)
}

func (s *MappingTypeContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MappingTypeContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MappingTypeContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MappingTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterMappingType(s)
	}
}

func (s *MappingTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitMappingType(s)
	}
}

func (p *SolidityParser) MappingType() (localctx IMappingTypeContext) {
	localctx = NewMappingTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SolidityParserRULE_mappingType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1130)
		p.Match(SolidityParserMapping)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1131)
		p.Match(SolidityParserLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1132)

		var _x = p.MappingKeyType()

		localctx.(*MappingTypeContext).key = _x
	}
	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserIdentifier {
		{
			p.SetState(1133)

			var _x = p.Identifier()

			localctx.(*MappingTypeContext).name = _x
		}

	}
	{
		p.SetState(1136)
		p.Match(SolidityParserDoubleArrow)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1137)

		var _x = p.typeName(0)

		localctx.(*MappingTypeContext).value = _x
	}
	p.SetState(1139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36028799705415680) != 0) || _la == SolidityParserIdentifier {
		{
			p.SetState(1138)

			var _x = p.Identifier()

			localctx.(*MappingTypeContext).name = _x
		}

	}
	{
		p.SetState(1141)
		p.Match(SolidityParserRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingKeyTypeContext is an interface to support dynamic dispatch.
type IMappingKeyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementaryTypeName() IElementaryTypeNameContext
	IdentifierPath() IIdentifierPathContext

	// IsMappingKeyTypeContext differentiates from other interfaces.
	IsMappingKeyTypeContext()
}

type MappingKeyTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingKeyTypeContext() *MappingKeyTypeContext {
	var p = new(MappingKeyTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_mappingKeyType
	return p
}

func InitEmptyMappingKeyTypeContext(p *MappingKeyTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_mappingKeyType
}

func (*MappingKeyTypeContext) IsMappingKeyTypeContext() {}

func NewMappingKeyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingKeyTypeContext {
	var p = new(MappingKeyTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_mappingKeyType

	return p
}

func (s *MappingKeyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingKeyTypeContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *MappingKeyTypeContext) IdentifierPath() IIdentifierPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPathContext)
}

func (s *MappingKeyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingKeyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingKeyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterMappingKeyType(s)
	}
}

func (s *MappingKeyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitMappingKeyType(s)
	}
}

func (p *SolidityParser) MappingKeyType() (localctx IMappingKeyTypeContext) {
	localctx = NewMappingKeyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SolidityParserRULE_mappingKeyType)
	p.SetState(1145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1143)
			p.ElementaryTypeName(false)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1144)
			p.IdentifierPath()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulStatementContext is an interface to support dynamic dispatch.
type IYulStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YulBlock() IYulBlockContext
	YulVariableDeclaration() IYulVariableDeclarationContext
	YulAssignment() IYulAssignmentContext
	YulFunctionCall() IYulFunctionCallContext
	YulIfStatement() IYulIfStatementContext
	YulForStatement() IYulForStatementContext
	YulSwitchStatement() IYulSwitchStatementContext
	YulLeave() antlr.TerminalNode
	YulBreak() antlr.TerminalNode
	YulContinue() antlr.TerminalNode
	YulFunctionDefinition() IYulFunctionDefinitionContext

	// IsYulStatementContext differentiates from other interfaces.
	IsYulStatementContext()
}

type YulStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulStatementContext() *YulStatementContext {
	var p = new(YulStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulStatement
	return p
}

func InitEmptyYulStatementContext(p *YulStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulStatement
}

func (*YulStatementContext) IsYulStatementContext() {}

func NewYulStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulStatementContext {
	var p = new(YulStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulStatement

	return p
}

func (s *YulStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YulStatementContext) YulBlock() IYulBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulBlockContext)
}

func (s *YulStatementContext) YulVariableDeclaration() IYulVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulVariableDeclarationContext)
}

func (s *YulStatementContext) YulAssignment() IYulAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulAssignmentContext)
}

func (s *YulStatementContext) YulFunctionCall() IYulFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulFunctionCallContext)
}

func (s *YulStatementContext) YulIfStatement() IYulIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulIfStatementContext)
}

func (s *YulStatementContext) YulForStatement() IYulForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulForStatementContext)
}

func (s *YulStatementContext) YulSwitchStatement() IYulSwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulSwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulSwitchStatementContext)
}

func (s *YulStatementContext) YulLeave() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulLeave, 0)
}

func (s *YulStatementContext) YulBreak() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulBreak, 0)
}

func (s *YulStatementContext) YulContinue() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulContinue, 0)
}

func (s *YulStatementContext) YulFunctionDefinition() IYulFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulFunctionDefinitionContext)
}

func (s *YulStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulStatement(s)
	}
}

func (s *YulStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulStatement(s)
	}
}

func (p *SolidityParser) YulStatement() (localctx IYulStatementContext) {
	localctx = NewYulStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SolidityParserRULE_yulStatement)
	p.SetState(1158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1147)
			p.YulBlock()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1148)
			p.YulVariableDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1149)
			p.YulAssignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1150)
			p.YulFunctionCall()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1151)
			p.YulIfStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1152)
			p.YulForStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1153)
			p.YulSwitchStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1154)
			p.Match(SolidityParserYulLeave)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1155)
			p.Match(SolidityParserYulBreak)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1156)
			p.Match(SolidityParserYulContinue)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1157)
			p.YulFunctionDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulBlockContext is an interface to support dynamic dispatch.
type IYulBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YulLBrace() antlr.TerminalNode
	YulRBrace() antlr.TerminalNode
	AllYulStatement() []IYulStatementContext
	YulStatement(i int) IYulStatementContext

	// IsYulBlockContext differentiates from other interfaces.
	IsYulBlockContext()
}

type YulBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulBlockContext() *YulBlockContext {
	var p = new(YulBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulBlock
	return p
}

func InitEmptyYulBlockContext(p *YulBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulBlock
}

func (*YulBlockContext) IsYulBlockContext() {}

func NewYulBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulBlockContext {
	var p = new(YulBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulBlock

	return p
}

func (s *YulBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *YulBlockContext) YulLBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulLBrace, 0)
}

func (s *YulBlockContext) YulRBrace() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulRBrace, 0)
}

func (s *YulBlockContext) AllYulStatement() []IYulStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYulStatementContext); ok {
			len++
		}
	}

	tst := make([]IYulStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYulStatementContext); ok {
			tst[i] = t.(IYulStatementContext)
			i++
		}
	}

	return tst
}

func (s *YulBlockContext) YulStatement(i int) IYulStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulStatementContext)
}

func (s *YulBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulBlock(s)
	}
}

func (s *YulBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulBlock(s)
	}
}

func (p *SolidityParser) YulBlock() (localctx IYulBlockContext) {
	localctx = NewYulBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SolidityParserRULE_yulBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		p.Match(SolidityParserYulLBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-143)) & ^0x3f) == 0 && ((int64(1)<<(_la-143))&4220901) != 0 {
		{
			p.SetState(1161)
			p.YulStatement()
		}

		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1167)
		p.Match(SolidityParserYulRBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulVariableDeclarationContext is an interface to support dynamic dispatch.
type IYulVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_YulIdentifier returns the _YulIdentifier token.
	Get_YulIdentifier() antlr.Token

	// Set_YulIdentifier sets the _YulIdentifier token.
	Set_YulIdentifier(antlr.Token)

	// GetVariables returns the variables token list.
	GetVariables() []antlr.Token

	// SetVariables sets the variables token list.
	SetVariables([]antlr.Token)

	// Getter signatures
	YulLet() antlr.TerminalNode
	AllYulIdentifier() []antlr.TerminalNode
	YulIdentifier(i int) antlr.TerminalNode
	YulAssign() antlr.TerminalNode
	YulExpression() IYulExpressionContext
	AllYulComma() []antlr.TerminalNode
	YulComma(i int) antlr.TerminalNode
	YulFunctionCall() IYulFunctionCallContext

	// IsYulVariableDeclarationContext differentiates from other interfaces.
	IsYulVariableDeclarationContext()
}

type YulVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_YulIdentifier antlr.Token
	variables      []antlr.Token
}

func NewEmptyYulVariableDeclarationContext() *YulVariableDeclarationContext {
	var p = new(YulVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulVariableDeclaration
	return p
}

func InitEmptyYulVariableDeclarationContext(p *YulVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulVariableDeclaration
}

func (*YulVariableDeclarationContext) IsYulVariableDeclarationContext() {}

func NewYulVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulVariableDeclarationContext {
	var p = new(YulVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulVariableDeclaration

	return p
}

func (s *YulVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *YulVariableDeclarationContext) Get_YulIdentifier() antlr.Token { return s._YulIdentifier }

func (s *YulVariableDeclarationContext) Set_YulIdentifier(v antlr.Token) { s._YulIdentifier = v }

func (s *YulVariableDeclarationContext) GetVariables() []antlr.Token { return s.variables }

func (s *YulVariableDeclarationContext) SetVariables(v []antlr.Token) { s.variables = v }

func (s *YulVariableDeclarationContext) YulLet() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulLet, 0)
}

func (s *YulVariableDeclarationContext) AllYulIdentifier() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserYulIdentifier)
}

func (s *YulVariableDeclarationContext) YulIdentifier(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserYulIdentifier, i)
}

func (s *YulVariableDeclarationContext) YulAssign() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulAssign, 0)
}

func (s *YulVariableDeclarationContext) YulExpression() IYulExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulExpressionContext)
}

func (s *YulVariableDeclarationContext) AllYulComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserYulComma)
}

func (s *YulVariableDeclarationContext) YulComma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserYulComma, i)
}

func (s *YulVariableDeclarationContext) YulFunctionCall() IYulFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulFunctionCallContext)
}

func (s *YulVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulVariableDeclaration(s)
	}
}

func (s *YulVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulVariableDeclaration(s)
	}
}

func (p *SolidityParser) YulVariableDeclaration() (localctx IYulVariableDeclarationContext) {
	localctx = NewYulVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SolidityParserRULE_yulVariableDeclaration)
	var _la int

	p.SetState(1188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1169)
			p.Match(SolidityParserYulLet)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1170)

			var _m = p.Match(SolidityParserYulIdentifier)

			localctx.(*YulVariableDeclarationContext)._YulIdentifier = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*YulVariableDeclarationContext).variables = append(localctx.(*YulVariableDeclarationContext).variables, localctx.(*YulVariableDeclarationContext)._YulIdentifier)
		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserYulAssign {
			{
				p.SetState(1171)
				p.Match(SolidityParserYulAssign)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1172)
				p.YulExpression()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1175)
			p.Match(SolidityParserYulLet)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1176)

			var _m = p.Match(SolidityParserYulIdentifier)

			localctx.(*YulVariableDeclarationContext)._YulIdentifier = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*YulVariableDeclarationContext).variables = append(localctx.(*YulVariableDeclarationContext).variables, localctx.(*YulVariableDeclarationContext)._YulIdentifier)
		p.SetState(1181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserYulComma {
			{
				p.SetState(1177)
				p.Match(SolidityParserYulComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1178)

				var _m = p.Match(SolidityParserYulIdentifier)

				localctx.(*YulVariableDeclarationContext)._YulIdentifier = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*YulVariableDeclarationContext).variables = append(localctx.(*YulVariableDeclarationContext).variables, localctx.(*YulVariableDeclarationContext)._YulIdentifier)

			p.SetState(1183)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserYulAssign {
			{
				p.SetState(1184)
				p.Match(SolidityParserYulAssign)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1185)
				p.YulFunctionCall()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulAssignmentContext is an interface to support dynamic dispatch.
type IYulAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllYulPath() []IYulPathContext
	YulPath(i int) IYulPathContext
	YulAssign() antlr.TerminalNode
	YulExpression() IYulExpressionContext
	YulFunctionCall() IYulFunctionCallContext
	AllYulComma() []antlr.TerminalNode
	YulComma(i int) antlr.TerminalNode

	// IsYulAssignmentContext differentiates from other interfaces.
	IsYulAssignmentContext()
}

type YulAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulAssignmentContext() *YulAssignmentContext {
	var p = new(YulAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulAssignment
	return p
}

func InitEmptyYulAssignmentContext(p *YulAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulAssignment
}

func (*YulAssignmentContext) IsYulAssignmentContext() {}

func NewYulAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulAssignmentContext {
	var p = new(YulAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulAssignment

	return p
}

func (s *YulAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *YulAssignmentContext) AllYulPath() []IYulPathContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYulPathContext); ok {
			len++
		}
	}

	tst := make([]IYulPathContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYulPathContext); ok {
			tst[i] = t.(IYulPathContext)
			i++
		}
	}

	return tst
}

func (s *YulAssignmentContext) YulPath(i int) IYulPathContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulPathContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulPathContext)
}

func (s *YulAssignmentContext) YulAssign() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulAssign, 0)
}

func (s *YulAssignmentContext) YulExpression() IYulExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulExpressionContext)
}

func (s *YulAssignmentContext) YulFunctionCall() IYulFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulFunctionCallContext)
}

func (s *YulAssignmentContext) AllYulComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserYulComma)
}

func (s *YulAssignmentContext) YulComma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserYulComma, i)
}

func (s *YulAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulAssignment(s)
	}
}

func (s *YulAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulAssignment(s)
	}
}

func (p *SolidityParser) YulAssignment() (localctx IYulAssignmentContext) {
	localctx = NewYulAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SolidityParserRULE_yulAssignment)
	var _la int

	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1190)
			p.YulPath()
		}
		{
			p.SetState(1191)
			p.Match(SolidityParserYulAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1192)
			p.YulExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1194)
			p.YulPath()
		}
		p.SetState(1197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SolidityParserYulComma {
			{
				p.SetState(1195)
				p.Match(SolidityParserYulComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1196)
				p.YulPath()
			}

			p.SetState(1199)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(1201)
			p.Match(SolidityParserYulAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1202)
			p.YulFunctionCall()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulIfStatementContext is an interface to support dynamic dispatch.
type IYulIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCond returns the cond rule contexts.
	GetCond() IYulExpressionContext

	// GetBody returns the body rule contexts.
	GetBody() IYulBlockContext

	// SetCond sets the cond rule contexts.
	SetCond(IYulExpressionContext)

	// SetBody sets the body rule contexts.
	SetBody(IYulBlockContext)

	// Getter signatures
	YulIf() antlr.TerminalNode
	YulExpression() IYulExpressionContext
	YulBlock() IYulBlockContext

	// IsYulIfStatementContext differentiates from other interfaces.
	IsYulIfStatementContext()
}

type YulIfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	cond   IYulExpressionContext
	body   IYulBlockContext
}

func NewEmptyYulIfStatementContext() *YulIfStatementContext {
	var p = new(YulIfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulIfStatement
	return p
}

func InitEmptyYulIfStatementContext(p *YulIfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulIfStatement
}

func (*YulIfStatementContext) IsYulIfStatementContext() {}

func NewYulIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulIfStatementContext {
	var p = new(YulIfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulIfStatement

	return p
}

func (s *YulIfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YulIfStatementContext) GetCond() IYulExpressionContext { return s.cond }

func (s *YulIfStatementContext) GetBody() IYulBlockContext { return s.body }

func (s *YulIfStatementContext) SetCond(v IYulExpressionContext) { s.cond = v }

func (s *YulIfStatementContext) SetBody(v IYulBlockContext) { s.body = v }

func (s *YulIfStatementContext) YulIf() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulIf, 0)
}

func (s *YulIfStatementContext) YulExpression() IYulExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulExpressionContext)
}

func (s *YulIfStatementContext) YulBlock() IYulBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulBlockContext)
}

func (s *YulIfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulIfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulIfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulIfStatement(s)
	}
}

func (s *YulIfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulIfStatement(s)
	}
}

func (p *SolidityParser) YulIfStatement() (localctx IYulIfStatementContext) {
	localctx = NewYulIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SolidityParserRULE_yulIfStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.Match(SolidityParserYulIf)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1207)

		var _x = p.YulExpression()

		localctx.(*YulIfStatementContext).cond = _x
	}
	{
		p.SetState(1208)

		var _x = p.YulBlock()

		localctx.(*YulIfStatementContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulForStatementContext is an interface to support dynamic dispatch.
type IYulForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInit returns the init rule contexts.
	GetInit() IYulBlockContext

	// GetCond returns the cond rule contexts.
	GetCond() IYulExpressionContext

	// GetPost returns the post rule contexts.
	GetPost() IYulBlockContext

	// GetBody returns the body rule contexts.
	GetBody() IYulBlockContext

	// SetInit sets the init rule contexts.
	SetInit(IYulBlockContext)

	// SetCond sets the cond rule contexts.
	SetCond(IYulExpressionContext)

	// SetPost sets the post rule contexts.
	SetPost(IYulBlockContext)

	// SetBody sets the body rule contexts.
	SetBody(IYulBlockContext)

	// Getter signatures
	YulFor() antlr.TerminalNode
	AllYulBlock() []IYulBlockContext
	YulBlock(i int) IYulBlockContext
	YulExpression() IYulExpressionContext

	// IsYulForStatementContext differentiates from other interfaces.
	IsYulForStatementContext()
}

type YulForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	init   IYulBlockContext
	cond   IYulExpressionContext
	post   IYulBlockContext
	body   IYulBlockContext
}

func NewEmptyYulForStatementContext() *YulForStatementContext {
	var p = new(YulForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulForStatement
	return p
}

func InitEmptyYulForStatementContext(p *YulForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulForStatement
}

func (*YulForStatementContext) IsYulForStatementContext() {}

func NewYulForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulForStatementContext {
	var p = new(YulForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulForStatement

	return p
}

func (s *YulForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YulForStatementContext) GetInit() IYulBlockContext { return s.init }

func (s *YulForStatementContext) GetCond() IYulExpressionContext { return s.cond }

func (s *YulForStatementContext) GetPost() IYulBlockContext { return s.post }

func (s *YulForStatementContext) GetBody() IYulBlockContext { return s.body }

func (s *YulForStatementContext) SetInit(v IYulBlockContext) { s.init = v }

func (s *YulForStatementContext) SetCond(v IYulExpressionContext) { s.cond = v }

func (s *YulForStatementContext) SetPost(v IYulBlockContext) { s.post = v }

func (s *YulForStatementContext) SetBody(v IYulBlockContext) { s.body = v }

func (s *YulForStatementContext) YulFor() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulFor, 0)
}

func (s *YulForStatementContext) AllYulBlock() []IYulBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYulBlockContext); ok {
			len++
		}
	}

	tst := make([]IYulBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYulBlockContext); ok {
			tst[i] = t.(IYulBlockContext)
			i++
		}
	}

	return tst
}

func (s *YulForStatementContext) YulBlock(i int) IYulBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulBlockContext)
}

func (s *YulForStatementContext) YulExpression() IYulExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulExpressionContext)
}

func (s *YulForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulForStatement(s)
	}
}

func (s *YulForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulForStatement(s)
	}
}

func (p *SolidityParser) YulForStatement() (localctx IYulForStatementContext) {
	localctx = NewYulForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SolidityParserRULE_yulForStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1210)
		p.Match(SolidityParserYulFor)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1211)

		var _x = p.YulBlock()

		localctx.(*YulForStatementContext).init = _x
	}
	{
		p.SetState(1212)

		var _x = p.YulExpression()

		localctx.(*YulForStatementContext).cond = _x
	}
	{
		p.SetState(1213)

		var _x = p.YulBlock()

		localctx.(*YulForStatementContext).post = _x
	}
	{
		p.SetState(1214)

		var _x = p.YulBlock()

		localctx.(*YulForStatementContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulSwitchCaseContext is an interface to support dynamic dispatch.
type IYulSwitchCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YulCase() antlr.TerminalNode
	YulLiteral() IYulLiteralContext
	YulBlock() IYulBlockContext

	// IsYulSwitchCaseContext differentiates from other interfaces.
	IsYulSwitchCaseContext()
}

type YulSwitchCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulSwitchCaseContext() *YulSwitchCaseContext {
	var p = new(YulSwitchCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulSwitchCase
	return p
}

func InitEmptyYulSwitchCaseContext(p *YulSwitchCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulSwitchCase
}

func (*YulSwitchCaseContext) IsYulSwitchCaseContext() {}

func NewYulSwitchCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulSwitchCaseContext {
	var p = new(YulSwitchCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulSwitchCase

	return p
}

func (s *YulSwitchCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *YulSwitchCaseContext) YulCase() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulCase, 0)
}

func (s *YulSwitchCaseContext) YulLiteral() IYulLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulLiteralContext)
}

func (s *YulSwitchCaseContext) YulBlock() IYulBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulBlockContext)
}

func (s *YulSwitchCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulSwitchCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulSwitchCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulSwitchCase(s)
	}
}

func (s *YulSwitchCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulSwitchCase(s)
	}
}

func (p *SolidityParser) YulSwitchCase() (localctx IYulSwitchCaseContext) {
	localctx = NewYulSwitchCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SolidityParserRULE_yulSwitchCase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1216)
		p.Match(SolidityParserYulCase)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1217)
		p.YulLiteral()
	}
	{
		p.SetState(1218)
		p.YulBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulSwitchStatementContext is an interface to support dynamic dispatch.
type IYulSwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YulSwitch() antlr.TerminalNode
	YulExpression() IYulExpressionContext
	YulDefault() antlr.TerminalNode
	YulBlock() IYulBlockContext
	AllYulSwitchCase() []IYulSwitchCaseContext
	YulSwitchCase(i int) IYulSwitchCaseContext

	// IsYulSwitchStatementContext differentiates from other interfaces.
	IsYulSwitchStatementContext()
}

type YulSwitchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulSwitchStatementContext() *YulSwitchStatementContext {
	var p = new(YulSwitchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulSwitchStatement
	return p
}

func InitEmptyYulSwitchStatementContext(p *YulSwitchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulSwitchStatement
}

func (*YulSwitchStatementContext) IsYulSwitchStatementContext() {}

func NewYulSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulSwitchStatementContext {
	var p = new(YulSwitchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulSwitchStatement

	return p
}

func (s *YulSwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YulSwitchStatementContext) YulSwitch() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulSwitch, 0)
}

func (s *YulSwitchStatementContext) YulExpression() IYulExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulExpressionContext)
}

func (s *YulSwitchStatementContext) YulDefault() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulDefault, 0)
}

func (s *YulSwitchStatementContext) YulBlock() IYulBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulBlockContext)
}

func (s *YulSwitchStatementContext) AllYulSwitchCase() []IYulSwitchCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYulSwitchCaseContext); ok {
			len++
		}
	}

	tst := make([]IYulSwitchCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYulSwitchCaseContext); ok {
			tst[i] = t.(IYulSwitchCaseContext)
			i++
		}
	}

	return tst
}

func (s *YulSwitchStatementContext) YulSwitchCase(i int) IYulSwitchCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulSwitchCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulSwitchCaseContext)
}

func (s *YulSwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulSwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulSwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulSwitchStatement(s)
	}
}

func (s *YulSwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulSwitchStatement(s)
	}
}

func (p *SolidityParser) YulSwitchStatement() (localctx IYulSwitchStatementContext) {
	localctx = NewYulSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SolidityParserRULE_yulSwitchStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.Match(SolidityParserYulSwitch)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1221)
		p.YulExpression()
	}
	p.SetState(1233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserYulCase:
		p.SetState(1223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SolidityParserYulCase {
			{
				p.SetState(1222)
				p.YulSwitchCase()
			}

			p.SetState(1225)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SolidityParserYulDefault {
			{
				p.SetState(1227)
				p.Match(SolidityParserYulDefault)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1228)
				p.YulBlock()
			}

		}

	case SolidityParserYulDefault:
		{
			p.SetState(1231)
			p.Match(SolidityParserYulDefault)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1232)
			p.YulBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulFunctionDefinitionContext is an interface to support dynamic dispatch.
type IYulFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_YulIdentifier returns the _YulIdentifier token.
	Get_YulIdentifier() antlr.Token

	// Set_YulIdentifier sets the _YulIdentifier token.
	Set_YulIdentifier(antlr.Token)

	// GetArguments returns the arguments token list.
	GetArguments() []antlr.Token

	// GetReturnParameters returns the returnParameters token list.
	GetReturnParameters() []antlr.Token

	// SetArguments sets the arguments token list.
	SetArguments([]antlr.Token)

	// SetReturnParameters sets the returnParameters token list.
	SetReturnParameters([]antlr.Token)

	// GetBody returns the body rule contexts.
	GetBody() IYulBlockContext

	// SetBody sets the body rule contexts.
	SetBody(IYulBlockContext)

	// Getter signatures
	YulFunction() antlr.TerminalNode
	AllYulIdentifier() []antlr.TerminalNode
	YulIdentifier(i int) antlr.TerminalNode
	YulLParen() antlr.TerminalNode
	YulRParen() antlr.TerminalNode
	YulBlock() IYulBlockContext
	YulArrow() antlr.TerminalNode
	AllYulComma() []antlr.TerminalNode
	YulComma(i int) antlr.TerminalNode

	// IsYulFunctionDefinitionContext differentiates from other interfaces.
	IsYulFunctionDefinitionContext()
}

type YulFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_YulIdentifier   antlr.Token
	arguments        []antlr.Token
	returnParameters []antlr.Token
	body             IYulBlockContext
}

func NewEmptyYulFunctionDefinitionContext() *YulFunctionDefinitionContext {
	var p = new(YulFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulFunctionDefinition
	return p
}

func InitEmptyYulFunctionDefinitionContext(p *YulFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulFunctionDefinition
}

func (*YulFunctionDefinitionContext) IsYulFunctionDefinitionContext() {}

func NewYulFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulFunctionDefinitionContext {
	var p = new(YulFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulFunctionDefinition

	return p
}

func (s *YulFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *YulFunctionDefinitionContext) Get_YulIdentifier() antlr.Token { return s._YulIdentifier }

func (s *YulFunctionDefinitionContext) Set_YulIdentifier(v antlr.Token) { s._YulIdentifier = v }

func (s *YulFunctionDefinitionContext) GetArguments() []antlr.Token { return s.arguments }

func (s *YulFunctionDefinitionContext) GetReturnParameters() []antlr.Token { return s.returnParameters }

func (s *YulFunctionDefinitionContext) SetArguments(v []antlr.Token) { s.arguments = v }

func (s *YulFunctionDefinitionContext) SetReturnParameters(v []antlr.Token) { s.returnParameters = v }

func (s *YulFunctionDefinitionContext) GetBody() IYulBlockContext { return s.body }

func (s *YulFunctionDefinitionContext) SetBody(v IYulBlockContext) { s.body = v }

func (s *YulFunctionDefinitionContext) YulFunction() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulFunction, 0)
}

func (s *YulFunctionDefinitionContext) AllYulIdentifier() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserYulIdentifier)
}

func (s *YulFunctionDefinitionContext) YulIdentifier(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserYulIdentifier, i)
}

func (s *YulFunctionDefinitionContext) YulLParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulLParen, 0)
}

func (s *YulFunctionDefinitionContext) YulRParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulRParen, 0)
}

func (s *YulFunctionDefinitionContext) YulBlock() IYulBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulBlockContext)
}

func (s *YulFunctionDefinitionContext) YulArrow() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulArrow, 0)
}

func (s *YulFunctionDefinitionContext) AllYulComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserYulComma)
}

func (s *YulFunctionDefinitionContext) YulComma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserYulComma, i)
}

func (s *YulFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulFunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulFunctionDefinition(s)
	}
}

func (s *YulFunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulFunctionDefinition(s)
	}
}

func (p *SolidityParser) YulFunctionDefinition() (localctx IYulFunctionDefinitionContext) {
	localctx = NewYulFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SolidityParserRULE_yulFunctionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.Match(SolidityParserYulFunction)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1236)
		p.Match(SolidityParserYulIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1237)
		p.Match(SolidityParserYulLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserYulIdentifier {
		{
			p.SetState(1238)

			var _m = p.Match(SolidityParserYulIdentifier)

			localctx.(*YulFunctionDefinitionContext)._YulIdentifier = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*YulFunctionDefinitionContext).arguments = append(localctx.(*YulFunctionDefinitionContext).arguments, localctx.(*YulFunctionDefinitionContext)._YulIdentifier)
		p.SetState(1243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserYulComma {
			{
				p.SetState(1239)
				p.Match(SolidityParserYulComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1240)

				var _m = p.Match(SolidityParserYulIdentifier)

				localctx.(*YulFunctionDefinitionContext)._YulIdentifier = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*YulFunctionDefinitionContext).arguments = append(localctx.(*YulFunctionDefinitionContext).arguments, localctx.(*YulFunctionDefinitionContext)._YulIdentifier)

			p.SetState(1245)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1248)
		p.Match(SolidityParserYulRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SolidityParserYulArrow {
		{
			p.SetState(1249)
			p.Match(SolidityParserYulArrow)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1250)

			var _m = p.Match(SolidityParserYulIdentifier)

			localctx.(*YulFunctionDefinitionContext)._YulIdentifier = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*YulFunctionDefinitionContext).returnParameters = append(localctx.(*YulFunctionDefinitionContext).returnParameters, localctx.(*YulFunctionDefinitionContext)._YulIdentifier)
		p.SetState(1255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserYulComma {
			{
				p.SetState(1251)
				p.Match(SolidityParserYulComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1252)

				var _m = p.Match(SolidityParserYulIdentifier)

				localctx.(*YulFunctionDefinitionContext)._YulIdentifier = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*YulFunctionDefinitionContext).returnParameters = append(localctx.(*YulFunctionDefinitionContext).returnParameters, localctx.(*YulFunctionDefinitionContext)._YulIdentifier)

			p.SetState(1257)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1260)

		var _x = p.YulBlock()

		localctx.(*YulFunctionDefinitionContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulPathContext is an interface to support dynamic dispatch.
type IYulPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllYulIdentifier() []antlr.TerminalNode
	YulIdentifier(i int) antlr.TerminalNode
	AllYulPeriod() []antlr.TerminalNode
	YulPeriod(i int) antlr.TerminalNode
	AllYulEVMBuiltin() []antlr.TerminalNode
	YulEVMBuiltin(i int) antlr.TerminalNode

	// IsYulPathContext differentiates from other interfaces.
	IsYulPathContext()
}

type YulPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulPathContext() *YulPathContext {
	var p = new(YulPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulPath
	return p
}

func InitEmptyYulPathContext(p *YulPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulPath
}

func (*YulPathContext) IsYulPathContext() {}

func NewYulPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulPathContext {
	var p = new(YulPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulPath

	return p
}

func (s *YulPathContext) GetParser() antlr.Parser { return s.parser }

func (s *YulPathContext) AllYulIdentifier() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserYulIdentifier)
}

func (s *YulPathContext) YulIdentifier(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserYulIdentifier, i)
}

func (s *YulPathContext) AllYulPeriod() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserYulPeriod)
}

func (s *YulPathContext) YulPeriod(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserYulPeriod, i)
}

func (s *YulPathContext) AllYulEVMBuiltin() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserYulEVMBuiltin)
}

func (s *YulPathContext) YulEVMBuiltin(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserYulEVMBuiltin, i)
}

func (s *YulPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulPath(s)
	}
}

func (s *YulPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulPath(s)
	}
}

func (p *SolidityParser) YulPath() (localctx IYulPathContext) {
	localctx = NewYulPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SolidityParserRULE_yulPath)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1262)
		p.Match(SolidityParserYulIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SolidityParserYulPeriod {
		{
			p.SetState(1263)
			p.Match(SolidityParserYulPeriod)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1264)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserYulEVMBuiltin || _la == SolidityParserYulIdentifier) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(1269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulFunctionCallContext is an interface to support dynamic dispatch.
type IYulFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YulLParen() antlr.TerminalNode
	YulRParen() antlr.TerminalNode
	YulIdentifier() antlr.TerminalNode
	YulEVMBuiltin() antlr.TerminalNode
	AllYulExpression() []IYulExpressionContext
	YulExpression(i int) IYulExpressionContext
	AllYulComma() []antlr.TerminalNode
	YulComma(i int) antlr.TerminalNode

	// IsYulFunctionCallContext differentiates from other interfaces.
	IsYulFunctionCallContext()
}

type YulFunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulFunctionCallContext() *YulFunctionCallContext {
	var p = new(YulFunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulFunctionCall
	return p
}

func InitEmptyYulFunctionCallContext(p *YulFunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulFunctionCall
}

func (*YulFunctionCallContext) IsYulFunctionCallContext() {}

func NewYulFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulFunctionCallContext {
	var p = new(YulFunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulFunctionCall

	return p
}

func (s *YulFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *YulFunctionCallContext) YulLParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulLParen, 0)
}

func (s *YulFunctionCallContext) YulRParen() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulRParen, 0)
}

func (s *YulFunctionCallContext) YulIdentifier() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulIdentifier, 0)
}

func (s *YulFunctionCallContext) YulEVMBuiltin() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulEVMBuiltin, 0)
}

func (s *YulFunctionCallContext) AllYulExpression() []IYulExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYulExpressionContext); ok {
			len++
		}
	}

	tst := make([]IYulExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYulExpressionContext); ok {
			tst[i] = t.(IYulExpressionContext)
			i++
		}
	}

	return tst
}

func (s *YulFunctionCallContext) YulExpression(i int) IYulExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulExpressionContext)
}

func (s *YulFunctionCallContext) AllYulComma() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserYulComma)
}

func (s *YulFunctionCallContext) YulComma(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserYulComma, i)
}

func (s *YulFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulFunctionCall(s)
	}
}

func (s *YulFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulFunctionCall(s)
	}
}

func (p *SolidityParser) YulFunctionCall() (localctx IYulFunctionCallContext) {
	localctx = NewYulFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SolidityParserRULE_yulFunctionCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1270)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SolidityParserYulEVMBuiltin || _la == SolidityParserYulIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1271)
		p.Match(SolidityParserYulLParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-147)) & ^0x3f) == 0 && ((int64(1)<<(_la-147))&8127105) != 0 {
		{
			p.SetState(1272)
			p.YulExpression()
		}
		p.SetState(1277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SolidityParserYulComma {
			{
				p.SetState(1273)
				p.Match(SolidityParserYulComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1274)
				p.YulExpression()
			}

			p.SetState(1279)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1282)
		p.Match(SolidityParserYulRParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulBooleanContext is an interface to support dynamic dispatch.
type IYulBooleanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YulTrue() antlr.TerminalNode
	YulFalse() antlr.TerminalNode

	// IsYulBooleanContext differentiates from other interfaces.
	IsYulBooleanContext()
}

type YulBooleanContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulBooleanContext() *YulBooleanContext {
	var p = new(YulBooleanContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulBoolean
	return p
}

func InitEmptyYulBooleanContext(p *YulBooleanContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulBoolean
}

func (*YulBooleanContext) IsYulBooleanContext() {}

func NewYulBooleanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulBooleanContext {
	var p = new(YulBooleanContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulBoolean

	return p
}

func (s *YulBooleanContext) GetParser() antlr.Parser { return s.parser }

func (s *YulBooleanContext) YulTrue() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulTrue, 0)
}

func (s *YulBooleanContext) YulFalse() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulFalse, 0)
}

func (s *YulBooleanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulBooleanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulBooleanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulBoolean(s)
	}
}

func (s *YulBooleanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulBoolean(s)
	}
}

func (p *SolidityParser) YulBoolean() (localctx IYulBooleanContext) {
	localctx = NewYulBooleanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SolidityParserRULE_yulBoolean)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1284)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SolidityParserYulFalse || _la == SolidityParserYulTrue) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulLiteralContext is an interface to support dynamic dispatch.
type IYulLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YulDecimalNumber() antlr.TerminalNode
	YulStringLiteral() antlr.TerminalNode
	YulHexNumber() antlr.TerminalNode
	YulBoolean() IYulBooleanContext
	YulHexStringLiteral() antlr.TerminalNode

	// IsYulLiteralContext differentiates from other interfaces.
	IsYulLiteralContext()
}

type YulLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulLiteralContext() *YulLiteralContext {
	var p = new(YulLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulLiteral
	return p
}

func InitEmptyYulLiteralContext(p *YulLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulLiteral
}

func (*YulLiteralContext) IsYulLiteralContext() {}

func NewYulLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulLiteralContext {
	var p = new(YulLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulLiteral

	return p
}

func (s *YulLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *YulLiteralContext) YulDecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulDecimalNumber, 0)
}

func (s *YulLiteralContext) YulStringLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulStringLiteral, 0)
}

func (s *YulLiteralContext) YulHexNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulHexNumber, 0)
}

func (s *YulLiteralContext) YulBoolean() IYulBooleanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulBooleanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulBooleanContext)
}

func (s *YulLiteralContext) YulHexStringLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserYulHexStringLiteral, 0)
}

func (s *YulLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulLiteral(s)
	}
}

func (s *YulLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulLiteral(s)
	}
}

func (p *SolidityParser) YulLiteral() (localctx IYulLiteralContext) {
	localctx = NewYulLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SolidityParserRULE_yulLiteral)
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SolidityParserYulDecimalNumber:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1286)
			p.Match(SolidityParserYulDecimalNumber)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserYulStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1287)
			p.Match(SolidityParserYulStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserYulHexNumber:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1288)
			p.Match(SolidityParserYulHexNumber)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SolidityParserYulFalse, SolidityParserYulTrue:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1289)
			p.YulBoolean()
		}

	case SolidityParserYulHexStringLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1290)
			p.Match(SolidityParserYulHexStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYulExpressionContext is an interface to support dynamic dispatch.
type IYulExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YulPath() IYulPathContext
	YulFunctionCall() IYulFunctionCallContext
	YulLiteral() IYulLiteralContext

	// IsYulExpressionContext differentiates from other interfaces.
	IsYulExpressionContext()
}

type YulExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYulExpressionContext() *YulExpressionContext {
	var p = new(YulExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulExpression
	return p
}

func InitEmptyYulExpressionContext(p *YulExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SolidityParserRULE_yulExpression
}

func (*YulExpressionContext) IsYulExpressionContext() {}

func NewYulExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YulExpressionContext {
	var p = new(YulExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_yulExpression

	return p
}

func (s *YulExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *YulExpressionContext) YulPath() IYulPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulPathContext)
}

func (s *YulExpressionContext) YulFunctionCall() IYulFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulFunctionCallContext)
}

func (s *YulExpressionContext) YulLiteral() IYulLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYulLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYulLiteralContext)
}

func (s *YulExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YulExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YulExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.EnterYulExpression(s)
	}
}

func (s *YulExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityParserListener); ok {
		listenerT.ExitYulExpression(s)
	}
}

func (p *SolidityParser) YulExpression() (localctx IYulExpressionContext) {
	localctx = NewYulExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SolidityParserRULE_yulExpression)
	p.SetState(1296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1293)
			p.YulPath()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1294)
			p.YulFunctionCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1295)
			p.YulLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *SolidityParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 19:
		var t *ConstructorDefinitionContext = nil
		if localctx != nil {
			t = localctx.(*ConstructorDefinitionContext)
		}
		return p.ConstructorDefinition_Sempred(t, predIndex)

	case 22:
		var t *FunctionDefinitionContext = nil
		if localctx != nil {
			t = localctx.(*FunctionDefinitionContext)
		}
		return p.FunctionDefinition_Sempred(t, predIndex)

	case 23:
		var t *ModifierDefinitionContext = nil
		if localctx != nil {
			t = localctx.(*ModifierDefinitionContext)
		}
		return p.ModifierDefinition_Sempred(t, predIndex)

	case 24:
		var t *FallbackFunctionDefinitionContext = nil
		if localctx != nil {
			t = localctx.(*FallbackFunctionDefinitionContext)
		}
		return p.FallbackFunctionDefinition_Sempred(t, predIndex)

	case 25:
		var t *ReceiveFunctionDefinitionContext = nil
		if localctx != nil {
			t = localctx.(*ReceiveFunctionDefinitionContext)
		}
		return p.ReceiveFunctionDefinition_Sempred(t, predIndex)

	case 30:
		var t *StateVariableDeclarationContext = nil
		if localctx != nil {
			if tCtx, ok :=  localctx.(*StateVariableDeclarationContext); ok {
				t = tCtx
			} else if _, ok := localctx.(*IdentifierPathContext); ok {
				return true
			}
		}
		return p.StateVariableDeclaration_Sempred(t, predIndex)

	case 38:
		var t *TypeNameContext = nil
		if localctx != nil {
			t = localctx.(*TypeNameContext)
		}
		return p.TypeName_Sempred(t, predIndex)

	case 39:
		var t *ElementaryTypeNameContext = nil
		if localctx != nil {
			t = localctx.(*ElementaryTypeNameContext)
		}
		return p.ElementaryTypeName_Sempred(t, predIndex)

	case 40:
		var t *FunctionTypeNameContext = nil
		if localctx != nil {
			t = localctx.(*FunctionTypeNameContext)
		}
		return p.FunctionTypeName_Sempred(t, predIndex)

	case 43:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SolidityParser) ConstructorDefinition_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return !localctx.(*ConstructorDefinitionContext).payableSet

	case 1:
		return !localctx.(*ConstructorDefinitionContext).visibilitySet

	case 2:
		return !localctx.(*ConstructorDefinitionContext).visibilitySet

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) FunctionDefinition_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return !localctx.(*FunctionDefinitionContext).visibilitySet

	case 4:
		return !localctx.(*FunctionDefinitionContext).mutabilitySet

	case 5:
		return !localctx.(*FunctionDefinitionContext).virtualSet

	case 6:
		return !localctx.(*FunctionDefinitionContext).overrideSpecifierSet

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) ModifierDefinition_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return !localctx.(*ModifierDefinitionContext).virtualSet

	case 8:
		return !localctx.(*ModifierDefinitionContext).overrideSpecifierSet

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) FallbackFunctionDefinition_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return !localctx.(*FallbackFunctionDefinitionContext).visibilitySet

	case 10:
		return !localctx.(*FallbackFunctionDefinitionContext).mutabilitySet

	case 11:
		return !localctx.(*FallbackFunctionDefinitionContext).virtualSet

	case 12:
		return !localctx.(*FallbackFunctionDefinitionContext).overrideSpecifierSet

	case 13:
		return localctx.(*FallbackFunctionDefinitionContext).hasParameters

	case 14:
		return !localctx.(*FallbackFunctionDefinitionContext).hasParameters

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) ReceiveFunctionDefinition_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
		return !localctx.(*ReceiveFunctionDefinitionContext).visibilitySet

	case 16:
		return !localctx.(*ReceiveFunctionDefinitionContext).mutabilitySet

	case 17:
		return !localctx.(*ReceiveFunctionDefinitionContext).virtualSet

	case 18:
		return !localctx.(*ReceiveFunctionDefinitionContext).overrideSpecifierSet

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) StateVariableDeclaration_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 19:
		return !localctx.(*StateVariableDeclarationContext).visibilitySet

	case 20:
		return !localctx.(*StateVariableDeclarationContext).visibilitySet

	case 21:
		return !localctx.(*StateVariableDeclarationContext).visibilitySet

	case 22:
		return !localctx.(*StateVariableDeclarationContext).constantnessSet

	case 23:
		return !localctx.(*StateVariableDeclarationContext).overrideSpecifierSet

	case 24:
		return !localctx.(*StateVariableDeclarationContext).constantnessSet

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) TypeName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 25:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) ElementaryTypeName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 26:
		return localctx.(*ElementaryTypeNameContext).allowAddressPayable

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) FunctionTypeName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 27:
		return !localctx.(*FunctionTypeNameContext).visibilitySet

	case 28:
		return !localctx.(*FunctionTypeNameContext).mutabilitySet

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 29:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 30:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 31:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 32:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 33:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 34:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 35:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 36:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 37:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 38:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 39:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 40:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 41:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 42:
		return p.Precpred(p.GetParserRuleContext(), 26)

	case 43:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 44:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 45:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 46:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 47:
		return p.Precpred(p.GetParserRuleContext(), 18)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
